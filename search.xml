<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AsiaInfo ACSE Training - 安全威胁课程-恶意软件部分</title>
    <url>/AsiaInfo/1.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程技术部分第一节内容，即第二章《病毒与威胁基础》之任务 1《安全威胁课程-恶意软件部分》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<span id="more"></span>

<h1 id="目前用户面临的主要威胁"><a href="#目前用户面临的主要威胁" class="headerlink" title="目前用户面临的主要威胁"></a>目前用户面临的主要威胁</h1><h2 id="更多的-IOT，更多的-DDOS"><a href="#更多的-IOT，更多的-DDOS" class="headerlink" title="更多的 IOT，更多的 DDOS"></a>更多的 IOT，更多的 DDOS</h2><ol>
<li>IOT：Internet Of Thing 物联网</li>
<li>DDOS：分布式拒绝服务攻击</li>
</ol>
<h2 id="更大的利益，更多的勒索软件"><a href="#更大的利益，更多的勒索软件" class="headerlink" title="更大的利益，更多的勒索软件"></a>更大的利益，更多的勒索软件</h2><ol>
<li>WannaCry</li>
<li>Petya</li>
<li>Bad Rabbit</li>
</ol>
<h2 id="从机会攻击，到定向攻击：APT攻击"><a href="#从机会攻击，到定向攻击：APT攻击" class="headerlink" title="从机会攻击，到定向攻击：APT攻击"></a>从机会攻击，到定向攻击：APT攻击</h2><ol>
<li>APT 攻击：Advanced Persistent Threat 高级持续性威胁</li>
<li>不是利用某种服务或者漏洞的攻击，是一种攻击技术的集合</li>
<li>一定有针对性、定向攻击；有组织、分工明确；潜伏期长</li>
<li>常规 APT 攻击对内网的渗透过程<ol>
<li>情报收集：找到企业内部脆弱点</li>
<li>用技术或社工方式进行入侵</li>
<li>获得内网计算机权限后，横向移动</li>
<li>找到需要的资产或数据，回传获利信息</li>
</ol>
</li>
</ol>
<h1 id="什么是计算机病毒"><a href="#什么是计算机病毒" class="headerlink" title="什么是计算机病毒"></a>什么是计算机病毒</h1><h2 id="广义上的解释"><a href="#广义上的解释" class="headerlink" title="广义上的解释"></a>广义上的解释</h2><ol>
<li>凡能够引起计算机故障，破坏计算机数据的程序称为计算机病毒</li>
<li>早期称之为 Virus，但实际上指的应该是恶意软件 Malware（= Malicious + Software）</li>
</ol>
<h2 id="狭义上的解释"><a href="#狭义上的解释" class="headerlink" title="狭义上的解释"></a>狭义上的解释</h2><ol>
<li>恶意软件中的一种 —— 特指感染型病毒</li>
<li>在计算机程序中插入的破坏计算机功能，影响计算机使用（破坏性），并能 自我复制（感染性）的一组计算机指令或者程序代码</li>
</ol>
<h2 id="计算机病毒分类"><a href="#计算机病毒分类" class="headerlink" title="计算机病毒分类"></a>计算机病毒分类</h2><ol>
<li>文件感染型病毒<ol>
<li>直接感染病毒：一旦执行就会感染文件</li>
<li>内存驻留病毒：隐藏在内存区，直到内存中有宿主程序执行时才会感染可执行程序</li>
<li>都是利用 重写、协同、寄生 三种方式来感染宿主程序，唯一区别是感染宿主程序的时间不同</li>
</ol>
</li>
<li>引导区病毒：通过感染磁盘的引导区，在计算机进入操作系统之前控制系统的执行流程</li>
<li>混合型病毒：又称复合型病毒，顾名思义，就是既能感染引导区又可以感染文件的病毒</li>
</ol>
<h2 id="文件感染方式"><a href="#文件感染方式" class="headerlink" title="文件感染方式"></a>文件感染方式</h2><ol>
<li>重写病毒：将文件内容替换为恶意代码</li>
<li>协同病毒：修改原始文件扩展名，将病毒自身伪装成原始正常文件</li>
<li>寄生病毒：将恶意代码附加在正常文件中</li>
</ol>
<h2 id="恶意软件的分类（针对恶意软件行为进行分类）"><a href="#恶意软件的分类（针对恶意软件行为进行分类）" class="headerlink" title="恶意软件的分类（针对恶意软件行为进行分类）"></a>恶意软件的分类（针对恶意软件行为进行分类）</h2><h3 id="感染型病毒"><a href="#感染型病毒" class="headerlink" title="感染型病毒"></a>感染型病毒</h3><ol>
<li>可执行病毒（PE：Portable Executable 病毒）</li>
<li>宏病毒 —— 梅利莎 Melissa</li>
<li>脚本病毒 —— 爱宠病毒 ILoveYou</li>
</ol>
<h3 id="网络蠕虫"><a href="#网络蠕虫" class="headerlink" title="网络蠕虫"></a>网络蠕虫</h3><ol>
<li>利用网络服务，向网络中的其他系统进行自我复制的恶意软件</li>
<li>病毒和蠕虫的区别：是否需要宿主程序进行自我复制</li>
<li>基于传播特性分类：邮件蠕虫、文件共享蠕虫、及时通信蠕虫、局域网/互联网蠕虫</li>
</ol>
<h3 id="特洛伊木马（简称为木马）"><a href="#特洛伊木马（简称为木马）" class="headerlink" title="特洛伊木马（简称为木马）"></a>特洛伊木马（简称为木马）</h3><ol>
<li>一种能够伪装自身，诱骗用户执行的恶意软件</li>
<li>目的：破坏文件、软件或者系统本身</li>
</ol>
<h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><p>&emsp;&emsp;一般是指那些绕过安全性控制而获取对程序或系统访问权的程序方法</p>
<h3 id="远控木马"><a href="#远控木马" class="headerlink" title="远控木马"></a>远控木马</h3><ol>
<li>Remote Access Trojan（简称 RAT）</li>
<li>一种恶意管理工具，它具有后门功能，使攻击者具有受受感染主机的最高用户权限</li>
<li>有 UI 界面、客户端组件，可以实现一对多控制</li>
</ol>
<h3 id="勒索软件"><a href="#勒索软件" class="headerlink" title="勒索软件"></a>勒索软件</h3><ol>
<li>一种通过劫持用户文件等方式，使用户数据资产或计算资源无法正常使用，并以此为条件向用户勒索钱财的恶意软件</li>
<li>勒索软件形式：数据加密型、木马破坏型、用户锁定型</li>
</ol>
<h3 id="风险软件（灰色软件）"><a href="#风险软件（灰色软件）" class="headerlink" title="风险软件（灰色软件）"></a>风险软件（灰色软件）</h3><ol>
<li>具有一些可能会给计算机带来威胁的功能。如果被用于恶意用途，则可能带来危害。这类中性软件，我们叫做风险软件。风险软件也被称为灰色软件</li>
<li>分为：间谍软件、广告软件、黑客工具和玩笑程序，这类软件的区分具有地域性和主观性</li>
</ol>
<h2 id="恶意软件的行为"><a href="#恶意软件的行为" class="headerlink" title="恶意软件的行为"></a>恶意软件的行为</h2><h3 id="一般感染流程"><a href="#一般感染流程" class="headerlink" title="一般感染流程"></a>一般感染流程</h3><ol>
<li>通过介质感染</li>
<li>伪装自身</li>
<li>安装</li>
<li>设置自启动</li>
<li>清理痕迹</li>
<li>实施恶意指令</li>
</ol>
<h3 id="常见感染介质"><a href="#常见感染介质" class="headerlink" title="常见感染介质"></a>常见感染介质</h3><ol>
<li>物理媒介</li>
<li>电子邮件</li>
<li>即使通信和聊天软件</li>
<li>社交网络</li>
<li>URL 链接</li>
<li>文件共享</li>
<li>软件漏洞</li>
</ol>
<h1 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h1><ol>
<li>是一种攻击手段</li>
<li>作为私人信息获取目的而被使用</li>
<li>利用社工感染的特点</li>
<li>利用社工后的感染媒介，让用户感觉<ol>
<li>来源可靠</li>
<li>具有紧迫感和重要性</li>
<li>能够引起兴趣</li>
</ol>
</li>
<li>自启动方式<ol>
<li>主引导记录</li>
<li>引导扇区</li>
<li>批处理方式</li>
<li>任务调用</li>
<li>启动文件夹</li>
<li>注册表</li>
</ol>
</li>
</ol>
<h1 id="恶意软件行为"><a href="#恶意软件行为" class="headerlink" title="恶意软件行为"></a>恶意软件行为</h1><h2 id="弹出网页、占用高-CPU、网络资源、自动终止进程。我们要注意恶意软件的隐性行为：长期潜伏、网络交互和恶意指令"><a href="#弹出网页、占用高-CPU、网络资源、自动终止进程。我们要注意恶意软件的隐性行为：长期潜伏、网络交互和恶意指令" class="headerlink" title="弹出网页、占用高 CPU、网络资源、自动终止进程。我们要注意恶意软件的隐性行为：长期潜伏、网络交互和恶意指令"></a>弹出网页、占用高 CPU、网络资源、自动终止进程。我们要注意恶意软件的隐性行为：长期潜伏、网络交互和恶意指令</h2><h2 id="在系统中长期潜伏"><a href="#在系统中长期潜伏" class="headerlink" title="在系统中长期潜伏"></a>在系统中长期潜伏</h2><ol>
<li>隐藏性</li>
<li>Rootkit 技术 = Root（最高权限）+Kit（工具箱），即在用户不知情的情况下，通过获得 root 权限，完全控制操作系统</li>
</ol>
<h2 id="与攻击者交互"><a href="#与攻击者交互" class="headerlink" title="与攻击者交互"></a>与攻击者交互</h2><ol>
<li>反馈状态</li>
<li>获取命令</li>
<li>窃取信息</li>
</ol>
<h2 id="常见的由恶意软件发起的网络通信"><a href="#常见的由恶意软件发起的网络通信" class="headerlink" title="常见的由恶意软件发起的网络通信"></a>常见的由恶意软件发起的网络通信</h2><ol>
<li>尝试连接 baidu 来检查网络连通性</li>
<li>连接 NTP 检查时间和日期</li>
<li>连接 C&amp;C 服务器来检查命令</li>
<li>将窃取的数据上传到相应的服务器上</li>
</ol>
<h2 id="执行恶意指令"><a href="#执行恶意指令" class="headerlink" title="执行恶意指令"></a>执行恶意指令</h2><div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/AsiaInfo/2.html">《AsiaInfo ACSE Training - 反病毒技术发展》</a></p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>安全威胁</tag>
        <tag>恶意软件</tag>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>AsiaInfo ACSE Training - 反病毒技术发展</title>
    <url>/AsiaInfo/2.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程技术部分第二节内容，即第二章《病毒与威胁基础》之任务 2《反病毒技术发展》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/AsiaInfo/1.html">《AsiaInfo ACSE Training - 安全威胁课程-恶意软件部分》</a></p>
</div>

<span id="more"></span>

<h1 id="早期病毒"><a href="#早期病毒" class="headerlink" title="早期病毒"></a>早期病毒</h1><ol>
<li>文件感染方式</li>
<li>功能单一</li>
<li>防病毒应对：通过特征码匹配</li>
</ol>
<h1 id="特征码"><a href="#特征码" class="headerlink" title="特征码"></a>特征码</h1><ol>
<li>哈希散列</li>
<li>一串二进制字符串</li>
</ol>
<h1 id="扫描引擎"><a href="#扫描引擎" class="headerlink" title="扫描引擎"></a>扫描引擎</h1><ol>
<li>自动化恶意软件初理机制</li>
<li>规定恶意软件入口点</li>
<li>匹配特征</li>
<li>挑战<ol>
<li>资源占用</li>
<li>对抗变种能力</li>
<li>对抗免杀能力</li>
<li>稳定性、兼容性</li>
</ol>
</li>
</ol>
<h1 id="恶意软件检测技术"><a href="#恶意软件检测技术" class="headerlink" title="恶意软件检测技术"></a>恶意软件检测技术</h1><h2 id="特征码检测"><a href="#特征码检测" class="headerlink" title="特征码检测"></a>特征码检测</h2><ol>
<li>基于文件某部分特征</li>
<li>精确匹配技术</li>
<li>早期，一张软盘对应一种病毒</li>
<li>病毒库，从一周更新一次到每天更新</li>
<li>拖慢系统运行速度</li>
<li>无法及时识别新的恶意软件</li>
</ol>
<h2 id="云查杀"><a href="#云查杀" class="headerlink" title="云查杀"></a>云查杀</h2><ol>
<li>动态病毒库</li>
<li>实时、共享</li>
<li>查杀能力更为精确、有效</li>
<li>挑战<ol>
<li>隔离网络环境</li>
<li>加大自身体积</li>
<li>高速、自动化生成的变种</li>
</ol>
</li>
</ol>
<h2 id="启发式检测"><a href="#启发式检测" class="headerlink" title="启发式检测"></a>启发式检测</h2><ol>
<li>启发式特征：通过一系列预定义的规则集来判断文件是否为恶意的检测方式</li>
<li>相似度匹配</li>
</ol>
<h2 id="特征码检测-VS-启发式检测"><a href="#特征码检测-VS-启发式检测" class="headerlink" title="特征码检测 VS 启发式检测"></a>特征码检测 VS 启发式检测</h2><p>&emsp;&emsp;启发式检测不能替代特征码检测</p>
<table>
<thead>
<tr>
<th align="center">优缺点</th>
<th align="center">特征码检测</th>
<th align="center">启发式检测</th>
</tr>
</thead>
<tbody><tr>
<td align="center">误报率</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">未知病毒</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">实现难度</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
</tbody></table>
<h1 id="恶意软件分析技术"><a href="#恶意软件分析技术" class="headerlink" title="恶意软件分析技术"></a>恶意软件分析技术</h1><h2 id="静态扫描"><a href="#静态扫描" class="headerlink" title="静态扫描"></a>静态扫描</h2><ol>
<li>检测静态文件是否存在恶意代码的过程</li>
<li>静态扫描<ol>
<li>特征码检测</li>
<li>启发式检测：被动启发式检测</li>
<li>恶意软件对抗<ol>
<li>现象：一个硬盘中的文件在平时不会被检测为恶意软件，但是当他在内存中运行时就会被认为是恶意软件</li>
<li>技术：加壳、压缩</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="动态扫描"><a href="#动态扫描" class="headerlink" title="动态扫描"></a>动态扫描</h2><ol>
<li>动态分析是在恶意软件在运行过程中，抽取特征进行匹配</li>
<li>状态特征</li>
<li>行为特征</li>
</ol>
<h2 id="沙盒技术"><a href="#沙盒技术" class="headerlink" title="沙盒技术"></a>沙盒技术</h2><ol>
<li>可控的恶意软件运行环境，最小化恶意软件的感染范围</li>
<li>分析出以下信息：<ol>
<li>主机方面：系统修改、恶意软件在内存中的行为</li>
<li>网络方面：网络连接状态、数据包</li>
</ol>
</li>
<li>完全模拟恶意软件运行的环境，分析出的行为更接近真实效果</li>
</ol>
<h2 id="动态的安全防护（态势感知）"><a href="#动态的安全防护（态势感知）" class="headerlink" title="动态的安全防护（态势感知）"></a>动态的安全防护（态势感知）</h2><ol>
<li>态势感知指在特定时空下，对动态环境中各元素或对象的察觉、理解以及对未来状态的预测</li>
<li>依赖大数据的辅助和配合</li>
<li>多方位联动分析</li>
</ol>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><ol>
<li>目标：预判、处理、取证</li>
<li>常见应用：图像识别、人脸识别、语言翻译</li>
<li>应用于安全：机器学习、深度学习</li>
<li>反病毒技术：特征码检测 → 启发式检测</li>
<li>人工智能：模式识别 → 机器学习</li>
<li>机器学习：识别 → 理解 → 解释</li>
<li>已在使用中的机器学习<ol>
<li>C&amp;C 网络流量通信行为</li>
<li>动态域名识别</li>
<li>鼠标动态行为检测</li>
<li>手机触屏行为学习</li>
<li>web 攻击行为学习</li>
</ol>
</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/AsiaInfo/3.html">《AsiaInfo ACSE Training - 安全事件初理建议》</a></p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>恶意软件</tag>
        <tag>病毒</tag>
        <tag>反病毒技术发展</tag>
      </tags>
  </entry>
  <entry>
    <title>AsiaInfo ACSE Training - 安全事件处理建议</title>
    <url>/AsiaInfo/3.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程技术部分第三节内容，即第二章《病毒与威胁基础》之任务 3《安全事件处理建议》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/AsiaInfo/2.html">《AsiaInfo ACSE Training - 反病毒技术发展》</a></p>
</div>

<span id="more"></span>

<h1 id="亚信安全反病毒定义"><a href="#亚信安全反病毒定义" class="headerlink" title="亚信安全反病毒定义"></a>亚信安全反病毒定义</h1><h2 id="病毒名称定义"><a href="#病毒名称定义" class="headerlink" title="病毒名称定义"></a>病毒名称定义</h2><ol>
<li>不同反病毒厂商，对于恶意软件名称都有不同的定义</li>
<li>此处以亚信安全对病毒名称定义举例：PE_SALITY.RL -O（类型 _ 名称 . 变种 - 母体）</li>
</ol>
<h1 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h1><h2 id="扫毒模块"><a href="#扫毒模块" class="headerlink" title="扫毒模块"></a>扫毒模块</h2><ol>
<li>扫描并检测含有恶意代码的文件，对其进行识别</li>
<li>对于被文件型病毒感染的可执行文件进行修复</li>
<li>组件<ol>
<li>扫描引擎：VSAPI &amp; TMFilter</li>
<li>病毒码：LPT$VPN.xxx</li>
<li>间谍软件病毒码：TMAPTN.xxx</li>
<li>网络病毒码：TMFxxxxx.PTN</li>
</ol>
</li>
</ol>
<h2 id="损害清除服务（DCS）"><a href="#损害清除服务（DCS）" class="headerlink" title="损害清除服务（DCS）"></a>损害清除服务（DCS）</h2><ol>
<li>场景：对一个正在编辑的 word 文档要执行删除操作的时候。文档会报该文件正在被使用，无法执行删除操作</li>
<li>对于正在运行/已经加载的病毒进行清除</li>
<li>终止进程</li>
<li>脱钩 DLL 文件</li>
<li>删除文件</li>
<li>恢复被病毒修改过的注册表内容，起到修复系统的作用</li>
<li>可视为通用专杀工具</li>
<li>组件<ol>
<li>损害清除引擎（DCE）：TSC.EXE</li>
<li>损害清除模板（DCT）：TSC.PTN</li>
<li>间谍软件清除病毒码：TMADCE.PTN</li>
</ol>
</li>
</ol>
<h1 id="反病毒常见问题"><a href="#反病毒常见问题" class="headerlink" title="反病毒常见问题"></a>反病毒常见问题</h1><ol>
<li>病毒已经被检测出来，却提示处理失败</li>
<li>无法清除，无法隔离</li>
<li>有明显中毒现象，病毒未被查杀</li>
<li>误查正常文件</li>
<li>为什么会出现无法清除的病毒？（只能隔离）<ol>
<li>多数情况下可以通过清除措施处理恶意代码，修复正常文件</li>
<li>-O 母体类型，无法被清除，只能隔离</li>
<li>非感染性病毒，本身就是恶意软件，无法被清除，只能隔离</li>
</ol>
</li>
<li>为什么会出现无法隔离/删除的病毒？<ol>
<li>当病毒感染系统后<ol>
<li>病毒进程已经被系统加载</li>
<li>病毒 DLL 文件已经嵌入到正在运行的系统进程中</li>
<li>Windwos 自身的特性：对于已经加载的文件无法进行改动操作，从而导致病毒扫描引擎对检测到的文件无法操作</li>
</ol>
</li>
<li>已经加载的病毒不包含在损害清除模板（DCT）中</li>
</ol>
</li>
</ol>
<h1 id="安全事件处理流程"><a href="#安全事件处理流程" class="headerlink" title="安全事件处理流程"></a>安全事件处理流程</h1><h2 id="已知病毒（能够检测，但无法被清除、隔离、删除）"><a href="#已知病毒（能够检测，但无法被清除、隔离、删除）" class="headerlink" title="已知病毒（能够检测，但无法被清除、隔离、删除）"></a>已知病毒（能够检测，但无法被清除、隔离、删除）</h2><ol>
<li>在可能的情况下，拔除网线</li>
<li>收集病毒日志</li>
<li>确认病毒名称、路径和文件名</li>
<li>搜索病毒知识库，查找病毒的解决方法</li>
<li>根据方案，手动清理系统中的病毒</li>
<li>若找不到方案或方案无效可收集样本与系统信息由厂商协助处理</li>
</ol>
<h2 id="未知-可疑病毒（无法检测，但出现病毒现象，疑似出现病毒）"><a href="#未知-可疑病毒（无法检测，但出现病毒现象，疑似出现病毒）" class="headerlink" title="未知/可疑病毒（无法检测，但出现病毒现象，疑似出现病毒）"></a>未知/可疑病毒（无法检测，但出现病毒现象，疑似出现病毒）</h2><ol>
<li>在可能的情况下，拔除网线</li>
<li>使用 ATTK（信息收集）工具收集系统关键信息提交给亚信安全</li>
<li>如有明显可疑文件，压缩加密提交给亚信安全</li>
<li>亚信安全反馈病毒解决方案</li>
</ol>
<h2 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h2><ol>
<li>可执行文件恶意代码清除后，文件被破坏<br>&emsp;&emsp;提交感染前的文件和感染后的文件给厂商进行分析</li>
<li>宏病毒清除后打开异常或被隔离<br>&emsp;&emsp;收集原时样本提交给厂商</li>
<li>网络异常，怀疑 ARP 攻击<br>&emsp;&emsp;通过抓包，将抓包信息提交给厂商</li>
</ol>
<h1 id="手动处理建议"><a href="#手动处理建议" class="headerlink" title="手动处理建议"></a>手动处理建议</h1><ol>
<li>在安全模式下操作</li>
<li>终止所有可疑进行和不必要的进程</li>
<li>关闭系统还原</li>
<li>显示所有隐藏文件</li>
<li>通过以下信息判断可疑文件<ol>
<li>创建时间</li>
<li>按照日期排列文件，查看文件版本信息</li>
<li>可执行文件 .EXE、.COM、.SCR、.PIF</li>
<li>DLL 文件和 OCX 文件</li>
<li>LOG 文件 —— 有一些病毒会将 DLL 文件伪装成 LOG 后缀的文件，可疑直接双击打开查看其内容是否为文本。若为乱码，则可以。</li>
<li>可疑内容</li>
<li>路径<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span>SystemRoot<span class="meta">%</span>\</span><br><span class="line"><span class="meta">%</span>SystemRoot<span class="meta">%</span>\Syste<span class="name">m32</span>\</span><br><span class="line"><span class="meta">%</span>SystemRoot<span class="meta">%</span>\Syste<span class="name">m32</span>\drivers\</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>判断关键位置内容是否被篡改<ol>
<li>hosts 文件</li>
<li>注册表启动项</li>
<li>可疑服务</li>
</ol>
</li>
</ol>
<h1 id="常用工具介绍"><a href="#常用工具介绍" class="headerlink" title="常用工具介绍"></a>常用工具介绍</h1><h2 id="ATTK"><a href="#ATTK" class="headerlink" title="ATTK"></a>ATTK</h2><ol>
<li>ATTK（Anti-Threat ToolKit）反病毒工具集</li>
<li>下载 <span class="exturl" data-url="aHR0cDovL3N1cHBvcnQuYXNpYWluZm8tc2VjLmNvbS9BbnRpLVZpcnVzL0NsZWFuLVRvb2wvQVRUS19DTi8=">病毒查杀工具 或 系统信息收集工具<i class="fa fa-external-link-alt"></i></span></li>
<li>用管理员权限双击运行即可<div class="note warning"><p>不要关闭任何弹出的窗口，否则程序会自动退出</p>
</div></li>
<li>信息收集完成后，会自动弹出浏览器窗口和 C 盘根目录</li>
<li><strong>联网</strong>状态下，网页上会生成 <strong>临时 ID 号</strong>， C 盘下会生成一个 <strong>以主机名开头的压缩文件</strong>，将 ID 号和压缩文件提供给厂商进行分析</li>
</ol>
<h2 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h2><ol>
<li><span class="exturl" data-url="aHR0cDovL3N1cHBvcnQuYXNpYWluZm8tc2VjLmNvbS9BbnRpLVZpcnVzL1Rvb2wvV2lyZXNoYXJrLXdpbjMyLTEuOC4yLnppcA==">下载地址<i class="fa fa-external-link-alt"></i></span></li>
<li>安装完成后，在 Start 下选择相应的网卡 → Capture → Start，开始抓包</li>
<li>抓包过程中：Ping 其他机器、尝试打开网页</li>
<li>收集一段时间后，点击 Stop，将数据包文件加密、压缩，发送给厂商来进一步分析</li>
</ol>
<h2 id="Rootkit-Buster"><a href="#Rootkit-Buster" class="headerlink" title="Rootkit Buster"></a>Rootkit Buster</h2><ol>
<li>用于 MBR 问题的收集工具</li>
<li>可疑扫描隐藏在系统文件、注册表、进程和驱动中被劫持的服务</li>
<li>还具备清除有害文件、隐藏注册表、执行程序等功能</li>
<li><span class="exturl" data-url="aHR0cDovL3N1cHBvcnQuYXNpYWluZm8tc2VjLmNvbS9BbnRpLVZpcnVzL0NsZWFuLVRvb2wvVG9vbHMvUm9vdGtpdEJ1c3Rlci8=">下载地址<i class="fa fa-external-link-alt"></i></span></li>
<li>使用管理员方式运行此工具，接受协议</li>
<li>勾选需要扫描的项目，开始扫描</li>
<li>扫描完成后，将桌面上生成的 TMRBLog 文件夹压缩加密发送给厂商来进一步分析</li>
</ol>
<h1 id="典型案例分析"><a href="#典型案例分析" class="headerlink" title="典型案例分析"></a>典型案例分析</h1><h2 id="Worm-downad"><a href="#Worm-downad" class="headerlink" title="Worm_downad"></a>Worm_downad</h2><h3 id="主要传播手段"><a href="#主要传播手段" class="headerlink" title="主要传播手段"></a>主要传播手段</h3><ol>
<li>漏洞：MS08-067</li>
<li>移动存储</li>
</ol>
<h3 id="显性特征"><a href="#显性特征" class="headerlink" title="显性特征"></a>显性特征</h3><ol>
<li>阻止访问安全网站</li>
<li>安全配置失效</li>
<li>暴力猜解密码</li>
<li>禁用 Windows 自动更新</li>
<li>无法登陆系统</li>
<li>隐藏文件</li>
<li>445 端口的网络流量很高</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>通过日志找到感染源</li>
<li>优先在源头计算机安装补丁（建议所有计算机打上补丁）：<span class="exturl" data-url="aHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3RlY2huZXQvc2VjdXJpdHkvYnVsbGV0aW4vbXM5OC0wNjcubXNweA==">下载地址<i class="fa fa-external-link-alt"></i></span></li>
<li>使用亚信安全产品或专杀工具查杀 WadKiller：<span class="exturl" data-url="aHR0cDovL3N1cHBvcnQuYXNpYWluZm8tc2VjLmNvbS9BbnRpLVZpcnVzL0NsZWFuLVRvb2wvVG9vbHMvU3BlY2lhbCUyMFRvb2xzL3dhZGtpbGxlcjAuNi56aXA=">下载地址<i class="fa fa-external-link-alt"></i></span></li>
<li>修改域账号密码为强密码</li>
</ol>
<h2 id="PE-SALITY"><a href="#PE-SALITY" class="headerlink" title="PE_SALITY"></a>PE_SALITY</h2><h3 id="主要传播手段-1"><a href="#主要传播手段-1" class="headerlink" title="主要传播手段"></a>主要传播手段</h3><ol>
<li>漏洞：ms10-046</li>
<li>移动存储</li>
<li>网络共享</li>
<li>电子邮件</li>
</ol>
<h2 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h2><ol>
<li>终止安全相关软件和服务</li>
<li>禁用防火墙、任务管理器、注册表</li>
<li>阻止进入安全模式</li>
<li>共享目录及子文件夹存在 LNK 和 TMP 文件</li>
<li>存在恶意的 AUTORUN.INF</li>
</ol>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>通过日志找到感染源（或 -O 母体文件）</li>
<li>如果产品发生异常，使用 ATTK 先进行处理</li>
<li>关闭系统还原</li>
<li>安装漏洞补丁：<span class="exturl" data-url="aHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3RlY2huZXQvc2VjdXJpdHkvYnVsbGV0aW4vbXMxMC0wNDYubXNweA==">下载地址<i class="fa fa-external-link-alt"></i></span></li>
<li>对计算机进行全盘扫描</li>
</ol>
<h2 id="勒索病毒"><a href="#勒索病毒" class="headerlink" title="勒索病毒"></a>勒索病毒</h2><h3 id="两种类型"><a href="#两种类型" class="headerlink" title="两种类型"></a>两种类型</h3><ol>
<li>传统勒索病毒</li>
<li>勒索蠕虫</li>
</ol>
<h3 id="主要特征-1"><a href="#主要特征-1" class="headerlink" title="主要特征"></a>主要特征</h3><ol>
<li>文档被加密锁定</li>
<li>弹出勒索信息</li>
</ol>
<h3 id="传统勒索软件"><a href="#传统勒索软件" class="headerlink" title="传统勒索软件"></a>传统勒索软件</h3><ol>
<li>主要传入手段<ol>
<li>社工邮件（订单、银行账单）</li>
<li>带有宏病毒的 Word / Excel 附件</li>
</ol>
</li>
<li>特点：非常依赖人类交互</li>
</ol>
<h3 id="勒索蠕虫"><a href="#勒索蠕虫" class="headerlink" title="勒索蠕虫"></a>勒索蠕虫</h3><p>&emsp;&emsp;主要传入手段：MS17-010 漏洞及 Internet 传入</p>
<h3 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h3><ol>
<li>对于被加密文件，请使用此解密工具进行解密：<span class="exturl" data-url="aHR0cDovL3N1cHBvcnQuYXNpYWluZm8tc2VjLmNvbS9BbnRpLVZpcnVzL0NsZWFuLVRvb2wvVG9vbHMvUmFuc29td2FyZUZpbGVEZWNyeXB0b3I=">下载地址<i class="fa fa-external-link-alt"></i></span></li>
<li>收集信息：ATTK 日志及病毒日志</li>
</ol>
<h3 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h3><ol>
<li>增强员工安全意识</li>
<li>防御（以 OSCE 为例）</li>
<li>备份重要文档（3-2-1 规则）：三个副本，两种不同格式保存，异地存储</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/AsiaInfo/4.html">《AsiaInfo ACSE Training - 安全威胁课程——网络攻击》</a></p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>安全事件处理建议</tag>
        <tag>工具下载</tag>
        <tag>ATTK</tag>
      </tags>
  </entry>
  <entry>
    <title>AsiaInfo ACSE Training - 安全威胁课程——网络攻击</title>
    <url>/AsiaInfo/4.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程技术部分第四节内容，即第二章《病毒与威胁基础》之任务 4《安全威胁课程——网络攻击》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/AsiaInfo/3.html">《AsiaInfo ACSE Training - 安全事件处理建议》</a></p>
</div>

<span id="more"></span>

<h1 id="黑客分类"><a href="#黑客分类" class="headerlink" title="黑客分类"></a>黑客分类</h1><h2 id="白帽子创新者"><a href="#白帽子创新者" class="headerlink" title="白帽子创新者"></a>白帽子创新者</h2><ol>
<li>设计新系统</li>
<li>打破常规</li>
<li>精研技术</li>
<li>勇于创新</li>
</ol>
<h2 id="灰帽子破解者"><a href="#灰帽子破解者" class="headerlink" title="灰帽子破解者"></a>灰帽子破解者</h2><ol>
<li>破解已有系统</li>
<li>发现问题/漏洞</li>
<li>突破限制/禁制</li>
<li>展现自我</li>
</ol>
<h2 id="黑帽子破坏者"><a href="#黑帽子破坏者" class="headerlink" title="黑帽子破坏者"></a>黑帽子破坏者</h2><ol>
<li>随意使用资源</li>
<li>恶意破坏</li>
<li>散播蠕虫病毒</li>
<li>商业间谍</li>
</ol>
<h1 id="一般攻击流程"><a href="#一般攻击流程" class="headerlink" title="一般攻击流程"></a>一般攻击流程</h1><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ol>
<li>确定目标：获得目标域名或公网 IP</li>
<li>隐藏自身：使用代理、肉鸡作为跳板机</li>
<li>收集信息（占整个攻击流程的 60~70% 的精力）：收集目标的域名、子域名、CDN 使用情况、网站信息包括可社工的部分、对外服务的漏洞（如 web 服务器漏洞）</li>
</ol>
<h2 id="实施阶段"><a href="#实施阶段" class="headerlink" title="实施阶段"></a>实施阶段</h2><ol>
<li>漏洞利用：邮件攻击、社工、木马等等攻击手段</li>
<li>应用攻击</li>
<li>提权</li>
<li>获利</li>
</ol>
<h2 id="收尾阶段"><a href="#收尾阶段" class="headerlink" title="收尾阶段"></a>收尾阶段</h2><ol>
<li>消除攻击痕迹</li>
<li>植入后门</li>
</ol>
<h1 id="常见的攻击手段"><a href="#常见的攻击手段" class="headerlink" title="常见的攻击手段"></a>常见的攻击手段</h1><h2 id="网络钓鱼（phishing-Phone-fishing）"><a href="#网络钓鱼（phishing-Phone-fishing）" class="headerlink" title="网络钓鱼（phishing = Phone + fishing）"></a>网络钓鱼（phishing = Phone + fishing）</h2><ol>
<li>钓鱼邮件</li>
<li>钓鱼网站</li>
</ol>
<h2 id="邮件攻击"><a href="#邮件攻击" class="headerlink" title="邮件攻击"></a>邮件攻击</h2><ol>
<li>邮件钓鱼</li>
<li>垃圾邮件</li>
<li>伪装发件人</li>
<li>复合型邮件攻击</li>
<li>传统勒索软件结合邮件和社工入侵</li>
</ol>
<h2 id="XSS-跨站"><a href="#XSS-跨站" class="headerlink" title="XSS 跨站"></a>XSS 跨站</h2><ol>
<li>XXS 跨站脚本攻击（cross site script）</li>
<li>持久型 XSS：将对客户端攻击的脚本植入到服务器上，从而导致每个正常访问页面的用户都会遭到这段 XSS 脚本攻击</li>
<li>非持久型 XSS：把精心构造的恶意脚本包装到一个页面的 URL 中的某一个参数中，再将这个 URL 发布到网上，欺骗用户访问，从而对其进行攻击</li>
</ol>
<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p>&emsp;&emsp;利用现有的应用程序，将恶意 SQL 命令注入到后台数据库引擎中去执行，可以通过在 web 表单中输入恶意的 SQL 语句，得到一个存在安全漏洞的网站的数据库</p>
<h2 id="DDOS-攻击"><a href="#DDOS-攻击" class="headerlink" title="DDOS 攻击"></a>DDOS 攻击</h2><ol>
<li>分布式拒绝服务攻击 DDOS（Distributed Denial of Service）</li>
<li>干扰阻断正常的网络通讯</li>
<li>提交大量请求，使服务器超负荷</li>
<li>阻断某一用户访问服务器</li>
<li>阻断某服务于特定系统或个人的通讯</li>
<li>IOT 设备的 DDOS 攻击</li>
</ol>
<h2 id="挂马"><a href="#挂马" class="headerlink" title="挂马"></a>挂马</h2><h2 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h2><h2 id="APT-攻击（高级可持续攻击）"><a href="#APT-攻击（高级可持续攻击）" class="headerlink" title="APT 攻击（高级可持续攻击）"></a>APT 攻击（高级可持续攻击）</h2><ol>
<li>APT：Advanced Persistent Threat</li>
<li>锁定特定目标</li>
<li>有计划性</li>
<li>潜伏性</li>
<li>持续性</li>
<li>典型的 APT 攻击案例：震网病毒</li>
</ol>
<h1 id="黑色产业链"><a href="#黑色产业链" class="headerlink" title="黑色产业链"></a>黑色产业链</h1><p><img data-src="https://www.hackme.cc/resource/%E7%BD%91%E7%BB%9C%E9%BB%91%E8%89%B2%E4%BA%A7%E4%B8%9A%E9%93%BE.webp" alt="网络黑色产业链.webp"></p>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/AsiaInfo/5.html">《AsiaInfo ACSE Training - 安全威胁课程——防护和治理》</a></p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>安全威胁</tag>
        <tag>网络攻击</tag>
        <tag>黑客</tag>
      </tags>
  </entry>
  <entry>
    <title>AsiaInfo ACSE Training - OSCE XG 第一讲 产品概述</title>
    <url>/AsiaInfo/6.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程，第三章《ACSE 产品必修课程》之任务 1《OSCE XG学习计划》课程 1《OSCE XG 第一讲 产品概述》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/AsiaInfo/5.html">《AsiaInfo ACSE Training - 安全威胁课程——防护和治理》</a></p>
</div>

<span id="more"></span>

<h1 id="企业安全管理需求"><a href="#企业安全管理需求" class="headerlink" title="企业安全管理需求"></a>企业安全管理需求</h1><ol>
<li>员工多样化，多设备的管理可视性，大规模部署</li>
<li>企业防护范围之外的移动设备，流动员工与合作伙伴</li>
<li>混合云包括软件即服务的管理架构</li>
<li>主动式的内容防护</li>
<li>高级威胁智能关联分析，事件调查与研究</li>
<li>可扩张与集成第三方安全产品信息与联动</li>
<li>完整即使简易有效的本地化产品系列与安全服务</li>
</ol>
<h1 id="OSCE-概述"><a href="#OSCE-概述" class="headerlink" title="OSCE 概述"></a>OSCE 概述</h1><ol>
<li>防毒墙网络版 OfficeScan（即 OSCE）是一款可以保护企业网络免受可以软件、网络病毒、基于 Web 的威胁、间谍软件和混合威胁攻击的安全产品</li>
<li>OSCE 的保护对象：服务器、PC 终端、便携式计算机</li>
</ol>
<h1 id="产品架构"><a href="#产品架构" class="headerlink" title="产品架构"></a>产品架构</h1><p><img data-src="https://www.hackme.cc/source/OSCE%E4%BA%A7%E5%93%81%E6%9E%B6%E6%9E%84.webp" alt="OSCE产品架构.webp"></p>
<h1 id="OSCE-的主要功能"><a href="#OSCE-的主要功能" class="headerlink" title="OSCE 的主要功能"></a>OSCE 的主要功能</h1><h2 id="安全风险扫描（最重要的功能）"><a href="#安全风险扫描（最重要的功能）" class="headerlink" title="安全风险扫描（最重要的功能）"></a>安全风险扫描（最重要的功能）</h2><ol>
<li>通过扫描文件，对扫描到的风险执行处理措施，以保护计算机安全</li>
<li>扫描引擎：集成了 ATSE（高级威胁扫描引擎）功能，以 VSAPI（病毒扫描引擎）的输出作为启发式检测的基础，增强了对零日攻击的保护</li>
<li>病毒特征库：病毒特征库包含帮助 OSCE 客户端识别最新病毒/恶意软件和混合威胁攻击的信息</li>
<li>云安全智能防护：将存储的病毒/恶意软件和病毒码转移到云中，本地只保留基础的病毒码，解决了因病毒码数量过大而导致的性能、网络带宽使用率和存储的问题</li>
<li>OSCE 的云安全智能防护还提供以下服务：云端存储的防恶意软件签名、Web 信誉服务、文件信誉服务</li>
</ol>
<h2 id="恶意行为监控"><a href="#恶意行为监控" class="headerlink" title="恶意行为监控"></a>恶意行为监控</h2><p>&emsp;&emsp;通过<strong>恶意软件行为阻止</strong>和<strong>事件监控</strong>来保护终端。用户配置的例外列表和安全软件认证服务是对这两种功能的完善</p>
<h3 id="恶意软件行为阻止"><a href="#恶意软件行为阻止" class="headerlink" title="恶意软件行为阻止"></a>恶意软件行为阻止</h3><p>&emsp;&emsp;提供了一个必须的额外威胁保护层，通过观察一段时间内的系统事件，当程序执行不同的操作序列时，恶意软件行为阻止将检测已知的恶意行为并阻止关联的程序。</p>
<p>&emsp;&emsp;可确保在较高级别上抵御新的、未知的突发的威胁，尤其对于勒索软件，可以保护文档使其免受未授权的加密或修改，阻止通常与勒索软件相关的进程，保护用户终端不受勒索软件的威胁。</p>
<h3 id="事件监控"><a href="#事件监控" class="headerlink" title="事件监控"></a>事件监控</h3><p>&emsp;&emsp;通常病毒入侵计算机后，会实施一些恶意行为，包括擅自修改用户的注册表，未经允许修改系统文件、安全策略和程序配置等等，许多恶意程序使用 Windows 系统文件使用的文件名创建它们自身或其他恶意程序的副本，这通常导致覆盖或者替换系统文件，避开检测或阻碍用户删除恶意文件。</p>
<p>&emsp;&emsp;事件监控会监控系统区域中的某些事件，并允许管理员调整触发此类事件的程序，如发现重复的系统文件、host 文件被修改、安全策略被修改、系统文件被修改等等，通过管理员预先的配置来处理触发的事件。</p>
<h2 id="主机防火墙"><a href="#主机防火墙" class="headerlink" title="主机防火墙"></a>主机防火墙</h2><ol>
<li>应用程序过滤：过滤特定应用程序中的传入和传出流量</li>
<li>网络通信过滤：过滤所有传入和传出的网络通信</li>
<li>扫描网络病毒：扫描每个数据包中是否有网络病毒</li>
<li>安全软件认证列表：提供了可绕开防火墙策略安全级别的应用程序列表</li>
</ol>
<h2 id="事件爆发阻止"><a href="#事件爆发阻止" class="headerlink" title="事件爆发阻止"></a>事件爆发阻止</h2><ol>
<li>限制/拒绝访问共享文件夹</li>
<li>封闭易受攻击的端口</li>
<li>拒绝对文件和文件夹的写访问</li>
<li>拒绝访问压缩可执行文件</li>
<li>在恶意软件进程/文件上创建互相排斥处理</li>
</ol>
<h2 id="可疑样本提交"><a href="#可疑样本提交" class="headerlink" title="可疑样本提交"></a>可疑样本提交</h2><p>&emsp;&emsp;样本提交的要求：</p>
<ol>
<li>OSCE 服务端必须注册在 TMCM 6.0 SP3 Patch2 或更高的版本</li>
<li>TMCM 已注册了有 DDAN 5.1 或更高版本</li>
</ol>
<h2 id="机器学习功能"><a href="#机器学习功能" class="headerlink" title="机器学习功能"></a>机器学习功能</h2><h2 id="反漏洞防护"><a href="#反漏洞防护" class="headerlink" title="反漏洞防护"></a>反漏洞防护</h2><h1 id="OSCE-的优势特点"><a href="#OSCE-的优势特点" class="headerlink" title="OSCE 的优势特点"></a>OSCE 的优势特点</h1><h2 id="集中式管理架构"><a href="#集中式管理架构" class="headerlink" title="集中式管理架构"></a>集中式管理架构</h2><ol>
<li>客户端-服务器模型：该架构允许客户端由单个服务器控制的集中式框架上对多台计算机进行远程管理</li>
<li>外部管理：部署外部管理服务器 Edge Server，将其作为客户端的中转站进行管理，实现对企业外部的所有客户端的管理</li>
</ol>
<h2 id="多年终端安全经验积累"><a href="#多年终端安全经验积累" class="headerlink" title="多年终端安全经验积累"></a>多年终端安全经验积累</h2><ol>
<li>Gartner 终端安全魔力象限持续16年位居领导者</li>
<li>多年 AV-Test 遥遥领先</li>
</ol>
<h2 id="先进的安全技术"><a href="#先进的安全技术" class="headerlink" title="先进的安全技术"></a>先进的安全技术</h2><p>&emsp;&emsp;恶意软件防护、个人防火墙、间谍软件防护、入侵检测系统 IPS、Web 信誉评级、文件信誉评级、数据保护（DLP）、数据加密、变种保护、白名单检查、统计检查、行为分析、漏洞防护虚拟补丁、应用程序控制、沙盒分析、机器学习（ML）业内首创双重 ML、终端检测与相应（EDR）业内第一家方案提供商 Gartner</p>
<h2 id="互联威胁防御"><a href="#互联威胁防御" class="headerlink" title="互联威胁防御"></a>互联威胁防御</h2><p>&emsp;&emsp;基于本地威胁情报构建精密联动机制</p>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/AsiaInfo/7.html">《AsiaInfo ACSE Training - OSCE XG 第二讲 安装部署》</a></p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>OfficeScan</tag>
        <tag>防毒墙网络版</tag>
      </tags>
  </entry>
  <entry>
    <title>AsiaInfo ACSE Training - OSCE XG 第二讲 安装部署</title>
    <url>/AsiaInfo/7.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程，第三章《ACSE 产品必修课程》之任务 1《OSCE XG学习计划》课程 2《OSCE XG 第二讲 安装部署》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/AsiaInfo/6.html">《AsiaInfo ACSE Training - OSCE XG 第一讲 产品概述》</a></p>
</div>

<span id="more"></span>

<h1 id="部署前准备"><a href="#部署前准备" class="headerlink" title="部署前准备"></a>部署前准备</h1><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>&emsp;&emsp;参考 <span class="exturl" data-url="aHR0cDovL3N1cHBvcnQuYXNpYWluZm8tc2VjLmNvbS9UTS1Qcm9kY3QvUHJvZHVjdC9PU0NFL0pWLzEyLjBfWEdfSlYvRG9jL09mZmljZVNjYW4lMjBTeXN0ZW0lMjBSZXF1aXJlbWVudHMucGRm">需求文档<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="安全部署前准备"><a href="#安全部署前准备" class="headerlink" title="安全部署前准备"></a>安全部署前准备</h2><ol>
<li>准备好 OSCE 的镜像文件和激活码</li>
<li>确认账户具有管理员权限</li>
<li>确认服务器已安装 IIS 服务</li>
<li>确认以下服务已启用<ol>
<li>Remote Proceduce Call（RPC）</li>
<li>Remote Registry</li>
<li>Windows Installer</li>
</ol>
</li>
<li>确认磁盘共享是否正确<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\\</span> 本机 IP<span class="string">\C$</span></span><br></pre></td></tr></table></figure></li>
<li>确认 IE 版本为 IE10（及以上）</li>
<li>检查是否已部署第三方安全产品</li>
</ol>
<h1 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h1><h2 id="web-网页安装（较常用，需要终端用户操作）"><a href="#web-网页安装（较常用，需要终端用户操作）" class="headerlink" title="web 网页安装（较常用，需要终端用户操作）"></a>web 网页安装（较常用，需要终端用户操作）</h2><ol>
<li>确认是否具有管理员权限</li>
<li>确认 IE 浏览器版本是否为 10 以上</li>
<li>启用 ActiveX 控件</li>
<li>将控制台 URL 添加可信站点</li>
<li>打开 IE 窗口，输入<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>&lt;OfficeScan server name&gt;:<span class="number">4343</span>/officesacan</span><br></pre></td></tr></table></figure></li>
<li>点击登陆界面中的“安装程序”</li>
<li>安装完成后，验证客户端是否安装成功</li>
</ol>
<h2 id="打包程序安装（较为稳妥，适用于网络环境不佳）"><a href="#打包程序安装（较为稳妥，适用于网络环境不佳）" class="headerlink" title="打包程序安装（较为稳妥，适用于网络环境不佳）"></a>打包程序安装（较为稳妥，适用于网络环境不佳）</h2><ol>
<li>在服务端运行 ClnPack.exe 工具，路径：<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">&lt;服务器安装文件夹&gt;<span class="symbol">\P</span>CCSRV<span class="symbol">\A</span>dmin<span class="symbol">\U</span>tility<span class="symbol">\C</span>lientPackager</span><br></pre></td></tr></table></figure></li>
<li>按照向导创建程序包<ol>
<li>系统位数</li>
<li>扫描方法</li>
<li>安装选项（是否静默；是否预扫描）</li>
<li>……</li>
</ol>
</li>
<li>确认客户端终端是否具有管理员权限</li>
<li>将安装包发送至客户端并运行安装</li>
<li>安装完成后，验证客户端是否安装成功</li>
</ol>
<h2 id="远程安装（适合单台定点安装，管理员可独立完成安装）"><a href="#远程安装（适合单台定点安装，管理员可独立完成安装）" class="headerlink" title="远程安装（适合单台定点安装，管理员可独立完成安装）"></a>远程安装（适合单台定点安装，管理员可独立完成安装）</h2><ol>
<li>启用内置域管理员账户并为该账户设置密码</li>
<li>在开始 —— 程序 —— 管理工具 —— 高级安全，Windows 防火墙中，启用“文件和打印机共享”规则</li>
<li>检查 Remote Registry 和 Remote Proceduce Call 服务是否运行在客户端上</li>
<li>在 Web 控制台 —— 客户端 —— 客户端安装 —— 远程中，选择目标终端，进行安装</li>
<li>安装完成后，验证客户端是否安装成功</li>
</ol>
<h2 id="登陆脚本安装（较为简便，适合大规模部署和有域环境的企业）"><a href="#登陆脚本安装（较为简便，适合大规模部署和有域环境的企业）" class="headerlink" title="登陆脚本安装（较为简便，适合大规模部署和有域环境的企业）"></a>登陆脚本安装（较为简便，适合大规模部署和有域环境的企业）</h2><ol>
<li>在服务器上运行开始菜单 —— 登陆脚本安装</li>
<li>选择要修改登陆脚本的服务器，并输入管理员用户名和密码</li>
<li>选择要修改登陆脚本的用户配置文件，点击应用</li>
<li>用户在登陆域后，开始安装客户端。安装完成后，验证客户端是否安装成功</li>
</ol>
<h1 id="常见的客户端安装方法"><a href="#常见的客户端安装方法" class="headerlink" title="常见的客户端安装方法"></a>常见的客户端安装方法</h1><table>
<thead>
<tr>
<th align="center">对比</th>
<th align="center">网页安装</th>
<th align="center">打包安装</th>
<th align="center">远程安装</th>
<th align="center">登陆脚本安装</th>
</tr>
</thead>
<tbody><tr>
<td align="center">需要联网</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">独立安装</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">批量安装</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">需要在同 AD 域</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">通过工具</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><h2 id="升级前的准备"><a href="#升级前的准备" class="headerlink" title="升级前的准备"></a>升级前的准备</h2><h3 id="设置延迟通用防火墙驱动程序更新"><a href="#设置延迟通用防火墙驱动程序更新" class="headerlink" title="设置延迟通用防火墙驱动程序更新"></a>设置延迟通用防火墙驱动程序更新</h3><p>&emsp;&emsp;登陆 web 控制台 - 客户端 - 全局客户端设置，转至防火墙设置部分，确认已勾选“仅在系统重新启动后更新防毒墙网络版防火墙驱动程序”选项</p>
<h3 id="设置所有-OSCE-客户端不能升级"><a href="#设置所有-OSCE-客户端不能升级" class="headerlink" title="设置所有 OSCE 客户端不能升级"></a>设置所有 OSCE 客户端不能升级</h3><p>&emsp;&emsp;登陆 web 控制台 - 客户端 - 客户端管理，在设置选项卡中找到“权限和其他设置”，在其他设置选项卡中，勾选“防病毒网络客户端可以更新组件，但不能升级程序和 hotfix”</p>
<h3 id="备份-OSCE-的数据库和配置文件"><a href="#备份-OSCE-的数据库和配置文件" class="headerlink" title="备份 OSCE 的数据库和配置文件"></a>备份 OSCE 的数据库和配置文件</h3><ol>
<li>登录 web 控制台 - 管理 &gt; 数据库备份，备份数据库</li>
<li>停止 OfficeScan Master Service 服务</li>
<li>手动备份&lt;服务器安装文件夹&gt;\PCCSRV 下的文件<ol>
<li>ofcscan.ini：包含全局客户端设置</li>
<li>ous.ini：包含防病毒组件部署的更新源表</li>
<li>Private 文件夹：包括防火墙和更新源设置</li>
<li>Web\tmOPP 文件夹：包括爆发阻止设置</li>
<li>Pccnt\Common\OfcPfw*.dat：包含防火墙设置</li>
<li>Download\OfcPfw*.dat：包含防火墙部署设置</li>
<li>Log 文件夹：包含系统事件和连续验证日志</li>
<li>Virus 文件夹：包含隔离的文件</li>
<li>HTTPDB 文件夹：包含防毒墙网络版数据库</li>
</ol>
</li>
<li>使用证书工具备份证书</li>
</ol>
<h2 id="升级安装"><a href="#升级安装" class="headerlink" title="升级安装"></a>升级安装</h2><ol>
<li>安装程序的获取：OSCE XG 的 <span class="exturl" data-url="aHR0cDovL3N1cHBvcnQuYXNpYWluZm8tc2VjLmNvbS9UTS1Qcm9kdWN0L1Byb2R1Y3QvT1NDRS9KVi8xMi4wX1hHX0pWL09TQ0VfMTIuMF9KVl9CMTY1MS5leGU=">下载链接<i class="fa fa-external-link-alt"></i></span></li>
<li>执行安装程序</li>
<li>验证安装</li>
</ol>
<h1 id="重新安装"><a href="#重新安装" class="headerlink" title="重新安装"></a>重新安装</h1><h2 id="确认服务器信息"><a href="#确认服务器信息" class="headerlink" title="确认服务器信息"></a>确认服务器信息</h2><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">&lt;服务器安装目录&gt;<span class="regexp">/PCCSRV/</span>ofcscan.ini</span><br></pre></td></tr></table></figure>

<ol>
<li>Master_DomainName：服务器安装时使用的是 IP 地址方式安装还是域名方式安全</li>
<li>Master_DomainPort：服务端使用的通信端口是多少</li>
<li>Client_LocalServer_Port：客户端使用的通信端口是多少</li>
</ol>
<h2 id="备份数据库和配置文件（参考-4-1-3-备份-OSCE-的数据库和配置文件）"><a href="#备份数据库和配置文件（参考-4-1-3-备份-OSCE-的数据库和配置文件）" class="headerlink" title="备份数据库和配置文件（参考 4.1.3 备份 OSCE 的数据库和配置文件）"></a>备份数据库和配置文件（参考 4.1.3 备份 OSCE 的数据库和配置文件）</h2><h2 id="备份证书（导出证书）"><a href="#备份证书（导出证书）" class="headerlink" title="备份证书（导出证书）"></a>备份证书（导出证书）</h2><ol>
<li>在 OfficeScan 服务器上，打开命令提示符，并定位到证书管理器目录 &lt; 服务器安装文件夹 &gt;\Pccsrv\Admin\Utility\CertificateManger</li>
<li>输入指令：<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">CertificateManager</span>.</span></span>ext -b <span class="literal">[密码]</span> <span class="literal">[证书导出路径]</span></span><br><span class="line">例：<span class="module-access"><span class="module"><span class="identifier">CertificateManger</span>.</span></span>exe -b strongpassword D:\Test\<span class="module-access"><span class="module"><span class="identifier">Asiainfo</span>.</span></span>zip</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="卸载服务器并重新安装"><a href="#卸载服务器并重新安装" class="headerlink" title="卸载服务器并重新安装"></a>卸载服务器并重新安装</h2><div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/AsiaInfo/8.html">《AsiaInfo ACSE Training - OSCE XG 第三讲 病毒防护配置》</a></p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>OfficeScan</tag>
        <tag>防毒墙网络版</tag>
      </tags>
  </entry>
  <entry>
    <title>AsiaInfo ACSE Training - 安全威胁课程——防护和治理</title>
    <url>/AsiaInfo/5.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程技术部分第四节内容，即第二章《病毒与威胁基础》之任务 5《安全威胁课程——防护和治理》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/AsiaInfo/4.html">《AsiaInfo ACSE Training - 安全威胁课程——网络攻击》</a></p>
</div>

<span id="more"></span>

<h1 id="安全模型和要求"><a href="#安全模型和要求" class="headerlink" title="安全模型和要求"></a>安全模型和要求</h1><h2 id="CIA-三元组"><a href="#CIA-三元组" class="headerlink" title="CIA 三元组"></a>CIA 三元组</h2><ol>
<li>保密性：确保信息在存储、使用、传输过程中不会泄露给非授权用户或实体</li>
<li>完整性：确保信息在存储、使用、传输过程中不会被非授权篡改，防止授权用户或实体不恰当地修改信息，保持信息内部和外部的一致性</li>
<li>可用性：确保授权用户或实体对信息及资源的正常使用不会被异常拒绝，允许其可靠而及时地访问信息及资源</li>
</ol>
<h2 id="深度防御的安全控制分类"><a href="#深度防御的安全控制分类" class="headerlink" title="深度防御的安全控制分类"></a>深度防御的安全控制分类</h2><h3 id="行政管理控制"><a href="#行政管理控制" class="headerlink" title="行政管理控制"></a>行政管理控制</h3><h3 id="技术性控制（我们所关心的部分）"><a href="#技术性控制（我们所关心的部分）" class="headerlink" title="技术性控制（我们所关心的部分）"></a>技术性控制（我们所关心的部分）</h3><ol>
<li>网络安全</li>
<li>主机安全</li>
<li>应用安全</li>
<li>数据安全和备份恢复</li>
</ol>
<h3 id="物理性控制"><a href="#物理性控制" class="headerlink" title="物理性控制"></a>物理性控制</h3><h1 id="安全技术体系"><a href="#安全技术体系" class="headerlink" title="安全技术体系"></a>安全技术体系</h1><h2 id="安全技术体系方案设计"><a href="#安全技术体系方案设计" class="headerlink" title="安全技术体系方案设计"></a>安全技术体系方案设计</h2><h3 id="区域边界安全"><a href="#区域边界安全" class="headerlink" title="区域边界安全"></a>区域边界安全</h3><ol>
<li>网络安全域划分与隔离：隔离网闸、防火墙</li>
<li>网络入侵检测与防护：IDS / IPS</li>
<li>网络边界准入：网络准入、应用准入、客户端准入</li>
<li>边界内容控制：防病毒网关</li>
</ol>
<h3 id="通信网络"><a href="#通信网络" class="headerlink" title="通信网络"></a>通信网络</h3><ol>
<li>网络冗余：链路负载均衡、服务器负载均衡、双机热备</li>
<li>网络传输安全：VPN</li>
<li>网络设备安全检测：漏洞扫描</li>
</ol>
<h3 id="计算环境"><a href="#计算环境" class="headerlink" title="计算环境"></a>计算环境</h3><ol>
<li>应用安全：身份认证和权限划分、应用服务器统一监控</li>
<li>主机安全：终端安全管理、移动终端、终端入侵检测和反病毒</li>
<li>数据安全：通信与存储加密、本（异）地数据备份与恢复</li>
</ol>
<h2 id="基于原则和策略的安全治理"><a href="#基于原则和策略的安全治理" class="headerlink" title="基于原则和策略的安全治理"></a>基于原则和策略的安全治理</h2><h3 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h3><ol>
<li>软件防火墙</li>
<li>硬件防火墙<ol>
<li>静态的数据包过滤防火墙：网络层</li>
<li>应用级网关防火墙：应用层</li>
<li>状态检测防火墙（动态包过滤防火墙）：会话层和网络层</li>
</ol>
</li>
</ol>
<h3 id="IDS-IPS"><a href="#IDS-IPS" class="headerlink" title="IDS / IPS"></a>IDS / IPS</h3><p>&emsp;&emsp;假如说防火墙是一幢大楼的门锁，那入侵监测系统就是这幢大楼里的监视系统</p>
<ol>
<li>IDS（Instrusion Detection Systems）入侵检测系统<ol>
<li>基于规则检测</li>
<li>基于行为检测（基于启发式检测）</li>
</ol>
</li>
<li>IPS（Intrusion Prevention System）入侵防御系统<br>&emsp;&emsp;有阻断和处理功能的IDS</li>
</ol>
<h3 id="NAC（Network-Access-Control）网络准入控制"><a href="#NAC（Network-Access-Control）网络准入控制" class="headerlink" title="NAC（Network Access Control）网络准入控制"></a>NAC（Network Access Control）网络准入控制</h3><ol>
<li>节点检测</li>
<li>身份认证</li>
<li>安全检测</li>
<li>授权</li>
<li>策略执行</li>
<li>隔离修复</li>
<li>接入控制</li>
</ol>
<h3 id="防病毒网关"><a href="#防病毒网关" class="headerlink" title="防病毒网关"></a>防病毒网关</h3><ol>
<li>UTM（Unified Threat Management）统一威胁管理</li>
<li>NGFW（Next generation firewall）下一代防火墙</li>
</ol>
<h3 id="VPN（Virtual-Private-Network）虚拟专用网"><a href="#VPN（Virtual-Private-Network）虚拟专用网" class="headerlink" title="VPN（Virtual Private Network）虚拟专用网"></a>VPN（Virtual Private Network）虚拟专用网</h3><h3 id="漏洞评估-漏洞防护（虚拟补丁防护）"><a href="#漏洞评估-漏洞防护（虚拟补丁防护）" class="headerlink" title="漏洞评估/漏洞防护（虚拟补丁防护）"></a>漏洞评估/漏洞防护（虚拟补丁防护）</h3><ol>
<li>可以在不影响应用程序和其相关库，以及为其提供运行环境的操作系统的情况下，为应用系统安全虚拟补丁</li>
<li>如一个应用程序的早期版本已不再获得供应商支持，则此虚拟补丁是支持该早期版本的唯一方法</li>
<li>可抵御零日漏洞</li>
</ol>
<h3 id="数据加密技术"><a href="#数据加密技术" class="headerlink" title="数据加密技术"></a>数据加密技术</h3><h3 id="身份鉴别技术"><a href="#身份鉴别技术" class="headerlink" title="身份鉴别技术"></a>身份鉴别技术</h3><p>&emsp;&emsp;4A 统一安全管理平台解决方案</p>
<ol>
<li>Account 集中账号管理</li>
<li>Authentication 集中认证管理</li>
<li>Authorization 集中权限管理</li>
<li>Audit 集中审计管理</li>
</ol>
<h2 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a>安全审计</h2><ol>
<li>流量审计、行为升级、数据审计</li>
<li>评估漏洞及隐患</li>
<li>测试策略和操作情况</li>
<li>发现网络系统入侵</li>
<li>调查取证</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/AsiaInfo/6.html">《AsiaInfo ACSE Training - OSCE XG 第一讲 产品概述》</a></p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>安全威胁</tag>
        <tag>安全防护</tag>
        <tag>安全治理</tag>
      </tags>
  </entry>
  <entry>
    <title>AsiaInfo ACSE Training - OSCE XG 第三讲 病毒防护配置</title>
    <url>/AsiaInfo/8.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程，第三章《ACSE 产品必修课程》之任务 1《OSCE XG学习计划》课程 3《OSCE XG 第三讲 病毒防护配置》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/AsiaInfo/7.html">《AsiaInfo ACSE Training - OSCE XG 第二讲 安装部署》</a></p>
</div>

<span id="more"></span>

<h1 id="扫描配置"><a href="#扫描配置" class="headerlink" title="扫描配置"></a>扫描配置</h1><h2 id="基本配置（首次登陆-officescan-管理控制台）"><a href="#基本配置（首次登陆-officescan-管理控制台）" class="headerlink" title="基本配置（首次登陆 officescan 管理控制台）"></a>基本配置（首次登陆 officescan 管理控制台）</h2><ol>
<li>登陆管理控制台<ol>
<li>地址：https://&lt;服务器 FQDN 或 IP 地址&gt;/officeScan</li>
<li>用户名：root</li>
<li>密码：安装时设定的密码</li>
</ol>
</li>
<li>确认产品使用授权：管理 → 设置 → 产品使用授权</li>
<li>通知配置：管理 → 通知 → 常规设置、管理员、客户端</li>
</ol>
<h2 id="扫描方法"><a href="#扫描方法" class="headerlink" title="扫描方法"></a>扫描方法</h2><p>&emsp;&emsp;客户端 → 客户端管理 → 设置 → 扫描方法</p>
<ol>
<li>云安全扫描：使用云安全扫描的客户端将受益于文件信誉服务提供的本地扫描和云端扫描</li>
<li>传统扫描：使用传统扫描的客户端将所有 Officescan 组件存储在客户端终端上，并在本地扫描所有文件</li>
</ol>
<h2 id="扫描类型"><a href="#扫描类型" class="headerlink" title="扫描类型"></a>扫描类型</h2><ol>
<li>实时扫描：在接受、打开、下载、复制或修改终端上的文件时，会自动扫描该文件</li>
<li>手动扫描：由终端用户启动的扫描，扫描用户请求的一个文件或一组文件</li>
<li>预设扫描：根据配置的时间表，自动扫描终端上的文件</li>
<li>立即扫描：管理员启动的扫描，扫描一个或多个目标计算机上的文件</li>
</ol>
<h2 id="预设扫描"><a href="#预设扫描" class="headerlink" title="预设扫描"></a>预设扫描</h2><p>&emsp;&emsp;客户端 → 客户端管理 → 设置</p>
<h3 id="扫描对象"><a href="#扫描对象" class="headerlink" title="扫描对象"></a>扫描对象</h3><ol>
<li>所有可扫描文件</li>
<li>IntelliScan 扫描的文件类型<br> IntelliScan 通过使用真实文件类型识别检查文件头并且仅扫描已知可能包含恶意代码的文件类型来优化性能。<br> 真实文件类型识别有助于确定通过无害扩展名进行伪装的恶意代码。</li>
<li>带指定扩展名的文件</li>
<li>可设置扫描例外：例外目录、例外文件、文件扩展名例外</li>
</ol>
<h3 id="优化扫描"><a href="#优化扫描" class="headerlink" title="优化扫描"></a>优化扫描</h3><p>&emsp;&emsp;客户端 → 全局客户端配置 → 安全设置</p>
<ol>
<li>扫描设置</li>
<li>全局客户端扫描配置</li>
<li>CPU 使用率（实时扫描无法设置）</li>
</ol>
<h3 id="处理措施"><a href="#处理措施" class="headerlink" title="处理措施"></a>处理措施</h3><p>&emsp;&emsp;清除、隔离、删除、不予处理（不可用于实时扫描）、更名、ActiveAction</p>
<p>&emsp;&emsp;ActiveAction 是针对特定类型的病毒/恶意软件的一组预配置的扫描处理措施。如果您不确定对每种类型的病毒/恶意软件采取何种扫描处理措施，亚信安全建议您使用 ActiveAction</p>
<h3 id="扫描时间"><a href="#扫描时间" class="headerlink" title="扫描时间"></a>扫描时间</h3><p>&emsp;&emsp;客户端 → 全局客户端配置 → 安全设置</p>
<h1 id="扫毒功能测试"><a href="#扫毒功能测试" class="headerlink" title="扫毒功能测试"></a>扫毒功能测试</h1><p><span class="exturl" data-url="aHR0cDovL3d3dy5laWNhci5vcmcv">Eicar 验证<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>新建文本文档，输入<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">X5O!P%@<span class="keyword">AP</span>[4\PZX54(P^)7CC)7&#125;<span class="variable">$EICAR</span>-STANDARD-ANTIVIRUS-<span class="keyword">TEST</span>-<span class="keyword">FILE</span>!<span class="variable">$H</span>+<span class="keyword">H</span>*</span><br></pre></td></tr></table></figure></li>
<li>保存文本文档</li>
<li>检查 OfficeScan 是否会拦截</li>
</ol>
<h1 id="隔离恢复"><a href="#隔离恢复" class="headerlink" title="隔离恢复"></a>隔离恢复</h1><p>&emsp;&emsp;场景：公司终端查杀到病毒文件并进行隔离，但该文件中包含重要资料需要从隔离区恢复出来</p>
<ol>
<li>集中隔离恢复<br> 客户端 &gt; 客户端管理 &gt; 任务 &gt; 集中隔离恢复</li>
<li>工具恢复<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">&lt;客户端安装目录&gt;/VSEncode.exe     #被隔离文件在客户端</span><br><span class="line">&lt;服务器安装文件夹&gt;<span class="symbol">\P</span>CCSRV<span class="symbol">\A</span>dmin<span class="symbol">\U</span>tility<span class="symbol">\V</span>SEncrypt<span class="symbol">\V</span>sencode     #被隔离文件在服务端或指定目录</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="勒索软件防护"><a href="#勒索软件防护" class="headerlink" title="勒索软件防护"></a>勒索软件防护</h1><p>&emsp;&emsp;目的：通过启用恶意行为阻止，保护终端不受勒索软件的威胁</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>&emsp;&emsp;客户端 → 客户端管理 → 设置 → 其他服务设置</p>
<p>&emsp;&emsp;需先开启：未授权更改阻止服务</p>
<h2 id="勒索软件防护-1"><a href="#勒索软件防护-1" class="headerlink" title="勒索软件防护"></a>勒索软件防护</h2><p>&emsp;&emsp;客户端 → 客户端管理 → 设置 → 恶意行为监控设置</p>
<h2 id="Web-信誉联动"><a href="#Web-信誉联动" class="headerlink" title="Web 信誉联动"></a>Web 信誉联动</h2><ol>
<li>开启 Web 信誉服务：客户端 → 客户端管理 → 设置 → Web 信誉设置</li>
<li>启用监控最近遇到的程序：客户端 → 客户端管理 → 设置 → 恶意行为监控设置</li>
</ol>
<h1 id="反漏洞防护"><a href="#反漏洞防护" class="headerlink" title="反漏洞防护"></a>反漏洞防护</h1><h2 id="CVE-弱点攻击扫描"><a href="#CVE-弱点攻击扫描" class="headerlink" title="CVE 弱点攻击扫描"></a>CVE 弱点攻击扫描</h2><ol>
<li>ATSE（高级威胁扫描引擎）及时防护经由网页/电子邮件下载的文档漏洞利用（CVE）</li>
<li>客户端 → 客户端管理 → 设置 → 实时扫描</li>
</ol>
<h2 id="漏洞攻击行为阻止"><a href="#漏洞攻击行为阻止" class="headerlink" title="漏洞攻击行为阻止"></a>漏洞攻击行为阻止</h2><ol>
<li>终止表现出漏洞攻击相关的异常行为的程序</li>
<li>客户端 → 客户端管理 → 设置 → 恶意行为监控设置</li>
</ol>
<h1 id="时间监控"><a href="#时间监控" class="headerlink" title="时间监控"></a>时间监控</h1><p>&emsp;&emsp;客户端 → 客户端管理 → 设置 → 恶意行为监控设置</p>
<p>&emsp;&emsp;处理措施：评估、允许、必要时询问、拒绝</p>
<h1 id="未知威胁防护"><a href="#未知威胁防护" class="headerlink" title="未知威胁防护"></a>未知威胁防护</h1><h2 id="预测机器学习"><a href="#预测机器学习" class="headerlink" title="预测机器学习"></a>预测机器学习</h2><ol>
<li>目的：通过启用机器学习功能，保护终端不受新威胁和未知威胁的侵扰</li>
<li>前置条件<br> 客户端 → 客户端管理 → 设置 → 其他服务设置<br> 需先开启：未授权更改阻止服务、高级保护服务</li>
<li>开启机器学习功能：客户端 → 客户端管理 → 设置 → 预测机器学习设置</li>
</ol>
<h2 id="可疑连接服务"><a href="#可疑连接服务" class="headerlink" title="可疑连接服务"></a>可疑连接服务</h2><ol>
<li>目的：监控终端与可能的 C&amp;C 服务器建立的连接行为</li>
<li>开启服务<br> 客户端 → 客户端管理 → 设置 → 其他服务设置<br> 需先开启：可疑连接服务</li>
<li>编辑 IP 列表：客户端 → 全局客户端设置 → 编辑定义的 IP 列表</li>
<li>配置可疑连接：客户端 → 客户端管理 → 设置 → 可疑连接设置</li>
</ol>
<h2 id="样本提交"><a href="#样本提交" class="headerlink" title="样本提交"></a>样本提交</h2><ol>
<li>目的：将可能包含以前未识别的威胁的文件样本提交给沙盒虚拟平台</li>
<li>前置条件：确认 OSCE 已注册在 TMCM 上、TMCM 已注册 DDAN</li>
<li>开启样本提交：客户端 → 客户端管理 → 设置 → 样本提交</li>
</ol>
<h1 id="其他威胁防护"><a href="#其他威胁防护" class="headerlink" title="其他威胁防护"></a>其他威胁防护</h1><h2 id="移动设备管控（预防-U-盘病毒）"><a href="#移动设备管控（预防-U-盘病毒）" class="headerlink" title="移动设备管控（预防 U 盘病毒）"></a>移动设备管控（预防 U 盘病毒）</h2><p>&emsp;&emsp;客户端 → 客户端管理 → 设置 → 移动设备权限管理设置</p>
<p>&emsp;&emsp;存储设置的权限：完全访问、修改、读取和执行、读取、仅列出设备内容、阻止</p>
<h2 id="爆发阻止（可能会影响日常办公，谨慎操作）"><a href="#爆发阻止（可能会影响日常办公，谨慎操作）" class="headerlink" title="爆发阻止（可能会影响日常办公，谨慎操作）"></a>爆发阻止（可能会影响日常办公，<strong>谨慎操作</strong>）</h2><p>&emsp;&emsp;客户端 → 爆发阻止</p>
<ol>
<li>限制/禁止访问共享文件</li>
<li>封闭端口</li>
<li>禁止对文件和文件夹写入<div class="note warning"><p>无法拒绝对映射的网络驱动器进行写人访问</p>
</div></li>
<li>拒绝访问压缩可执行文件</li>
<li>在恶意软件进程/文件上创建互相排斥（互斥）处理</li>
</ol>
<h1 id="联动配置"><a href="#联动配置" class="headerlink" title="联动配置"></a>联动配置</h1><h2 id="与-TMCM"><a href="#与-TMCM" class="headerlink" title="与 TMCM"></a>与 TMCM</h2><p>&emsp;&emsp;管理 → 设置 → 控制管理中心</p>
<h2 id="与-DDAN"><a href="#与-DDAN" class="headerlink" title="与 DDAN"></a>与 DDAN</h2><ol>
<li>管理 → 设置 → 可疑对象列表</li>
<li>客户端 → 客户端管理 → 设置 → 样本提交</li>
</ol>
<h2 id="与-CTDI"><a href="#与-CTDI" class="headerlink" title="与 CTDI"></a>与 CTDI</h2><ol>
<li>CTDI web 控制台 → 探针 → 防毒墙集成</li>
<li>OSCE web 控制台 → 插件 → 注册</li>
<li>OSCE web 控制台 → 插件 → 管理程序</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/AsiaInfo/9.html">《AsiaInfo ACSE Training - OSCE XG 第四讲 日志和管理》</a></p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>OfficeScan</tag>
        <tag>防毒墙网络版</tag>
      </tags>
  </entry>
  <entry>
    <title>AsiaInfo ACSE Training - OSCE XG 第四讲 日志和管理</title>
    <url>/AsiaInfo/9.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是亚信安全认证安全专家 —— ACSE 认证培训课程，第三章《ACSE 产品必修课程》之任务 1《OSCE XG学习计划》课程 4《OSCE XG 第三讲 日志和管理》的<strong>学习笔记</strong>，内容仅供学习交流，<strong>非</strong><del>亚信安全官方课程文档</del>，若想进行 ACSE 课程学习或取得认证，请参阅 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNpYWluZm8tc2VjLmNvbS9wYXJ0bmVyL3JlY3J1aXQuaHRtbA==">亚信安全认证培训<i class="fa fa-external-link-alt"></i></span> 进行报名参训。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/AsiaInfo/8.html">《AsiaInfo ACSE Training - OSCE XG 第三讲 病毒防护配置》</a></p>
</div>

<span id="more"></span>

<h1 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h1><h2 id="更新原理"><a href="#更新原理" class="headerlink" title="更新原理"></a>更新原理</h2><ol>
<li>ActiveUpdate 服务器 → OfficeScan 服务器 → 客户端<br> 适用于：小型企业、测试环境、服务器管理客户端数比较少</li>
<li>ActiveUpdate 服务器（→ OfficeScan 服务器）→ 更新代理 → 客户端<br> 适用于：大型企业、服务器管理客户端数比较多</li>
<li>ActiveUpdate 服务器 → 遇到问题/正在漫游的客户端<br> 适用于：办公环境员工在外出、出差时使用笔记本电脑</li>
</ol>
<h2 id="更新原理（离线）"><a href="#更新原理（离线）" class="headerlink" title="更新原理（离线）"></a>更新原理（离线）</h2><p>&emsp;&emsp;用一台可以联网的计算机，下载安装 <span class="exturl" data-url="aHR0cDovL3N1cHBvcnQuYXNpYWluZm8tc2VjLmNvbS9UTS1Qcm9kdWN0L1Byb2R1Y3QvVE1VVC8=">TMUT<i class="fa fa-external-link-alt"></i></span>，OfficeScan 服务器将该终端作为更新源进行更新</p>
<p>&emsp;&emsp;适用于：内网封闭的工作环境</p>
<h1 id="服务器更新"><a href="#服务器更新" class="headerlink" title="服务器更新"></a>服务器更新</h1><h2 id="手动更新（适用于刚安装完或有病毒大爆发）"><a href="#手动更新（适用于刚安装完或有病毒大爆发）" class="headerlink" title="手动更新（适用于刚安装完或有病毒大爆发）"></a>手动更新（适用于刚安装完或有病毒大爆发）</h2><p>&emsp;&emsp;更新 → 服务器 → 手动更新</p>
<h2 id="预设更新（定期检查是否存在最新的组件更新）"><a href="#预设更新（定期检查是否存在最新的组件更新）" class="headerlink" title="预设更新（定期检查是否存在最新的组件更新）"></a>预设更新（定期检查是否存在最新的组件更新）</h2><p>&emsp;&emsp;更新 → 服务器 → 预设更新（推荐每小时一次）</p>
<h2 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h2><p>&emsp;&emsp;更新 → 服务器 → 更新源</p>
<h1 id="客户端更新"><a href="#客户端更新" class="headerlink" title="客户端更新"></a>客户端更新</h1><h2 id="手动更新"><a href="#手动更新" class="headerlink" title="手动更新"></a>手动更新</h2><p>&emsp;&emsp;更新 → 客户端 → 手动更新</p>
<h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h2><p>&emsp;&emsp;更新 → 客户端 → 自动更新</p>
<h1 id="客户端代理更新"><a href="#客户端代理更新" class="headerlink" title="客户端代理更新"></a>客户端代理更新</h1><ol>
<li>在配置之前，请规划好将哪些终端作为更新代理使用，这些更新代理又对应哪些终端</li>
<li>将指定客户端设置为代理：在客户端 ＞ 客户端管理，选中指定的更新代理，右键，选择更新代理设置，勾选组件更新</li>
<li>更改客户端更新源：在更新 ＞ 客户端 ＞ 更新源，将指定 IP 段的客户端更新源设置为代理客户端</li>
</ol>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h2><p>&emsp;&emsp;管理 → 设置 → 产品使用授权</p>
<h2 id="客户端状态验证"><a href="#客户端状态验证" class="headerlink" title="客户端状态验证"></a>客户端状态验证</h2><ol>
<li>客户端管理<br> 管理 &gt; 客户端管理中，查看客户端的连接状态</li>
<li>连接验证<br> 管理 &gt; 连接验证中，可以手动/预设验证客户端连接状态</li>
</ol>
<h2 id="控制台配置"><a href="#控制台配置" class="headerlink" title="控制台配置"></a>控制台配置</h2><p>&emsp;&emsp;管理 → 设置 → Web 控制台</p>
<p>&emsp;&emsp;可配置控制台自动刷新时间和账号登陆超时时间</p>
<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>&emsp;&emsp;管理 → 设置 → 代理服务器</p>
<h2 id="全局客户端设置"><a href="#全局客户端设置" class="headerlink" title="全局客户端设置"></a>全局客户端设置</h2><p>&emsp;&emsp;管理 → 全局客户端设置</p>
<p>&emsp;&emsp;可将“使用防毒墙网络版扫描”添加至 Windows 右键菜单</p>
<h1 id="日志分析与管理"><a href="#日志分析与管理" class="headerlink" title="日志分析与管理"></a>日志分析与管理</h1><h2 id="客户端日志"><a href="#客户端日志" class="headerlink" title="客户端日志"></a>客户端日志</h2><p>&emsp;&emsp;日志 → 客户端</p>
<p>&emsp;&emsp;记录了服务器从客户端接受到的日志：安全风险、客户端组件更新、连接验证、集中隔离恢复、间谍软件/灰色软件恢复</p>
<h2 id="服务器更新日志"><a href="#服务器更新日志" class="headerlink" title="服务器更新日志"></a>服务器更新日志</h2><p>&emsp;&emsp;记录服务器组件更新情况日志</p>
<h2 id="系统系统日志"><a href="#系统系统日志" class="headerlink" title="系统系统日志"></a>系统系统日志</h2><p>&emsp;&emsp;记录与服务器程序相关的事件日志，如关闭和启动、主服务运行情况、爆发阻止情况、数据库备份情况、基于角色的 Web 控制台访问、服务器认证</p>
<h1 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h1><h2 id="自动删除"><a href="#自动删除" class="headerlink" title="自动删除"></a>自动删除</h2><p>&emsp;&emsp;日志 → 日志维护</p>
<h2 id="手动删除"><a href="#手动删除" class="headerlink" title="手动删除"></a>手动删除</h2><p>&emsp;&emsp;客户端 → 客户端管理</p>
<h1 id="常见疑难解答"><a href="#常见疑难解答" class="headerlink" title="常见疑难解答"></a>常见疑难解答</h1><h2 id="如何备份证书（导出证书）？"><a href="#如何备份证书（导出证书）？" class="headerlink" title="如何备份证书（导出证书）？"></a>如何备份证书（导出证书）？</h2><p>&emsp;&emsp;在重新安装服务器时，如何备份证书？</p>
<ol>
<li>在 OfficeScan 服务器上，打开命令提示符，并定位到证书管理器目录 &lt;服务器安装文件夹&gt;\Pccsrv\Admin\Utility\CertificateManager</li>
<li>输入指令<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">CertificateManager</span>.</span></span>exe -b <span class="literal">[密码]</span> <span class="literal">[证书导出路径]</span></span><br><span class="line">例：<span class="module-access"><span class="module"><span class="identifier">CertificateManager</span>.</span></span>exe -b strongpassword D:\Test\<span class="module-access"><span class="module"><span class="identifier">Asiainfo</span>.</span></span>zip</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如何迁移客户端？"><a href="#如何迁移客户端？" class="headerlink" title="如何迁移客户端？"></a>如何迁移客户端？</h2><ol>
<li>场景一：更换新的服务器，原服务器端还能正常使用：管理 → 设置 → 客户端连接</li>
<li>场景二：原服务器端已经无法正常使用（使用 IpXfer 工具迁移客户端到指定服务器）<ol>
<li>打开服务器端文件夹 \PCCSRV\Admin\Utility\ipXfer，新建一文本文件：transfer<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">可执行文件名</span>&gt;</span> -s <span class="tag">&lt;<span class="name">服务器名称</span>&gt;</span> -p <span class="tag">&lt;<span class="name">服务器侦听端口</span>&gt;</span> -c <span class="tag">&lt;<span class="name">客户端侦听端口</span>&gt;</span> -d <span class="tag">&lt;<span class="name">域或域层次结构</span>&gt;</span> -e <span class="tag">&lt;<span class="name">证书位置和文件名</span>&gt;</span></span><br><span class="line">例：ipXfer.exe -s Server01 -p 8080 -c 21112 -d Workgroup -e c:\Certificate.zip</span><br></pre></td></tr></table></figure></li>
<li>将 transfer 与 IpXfer.exe 一起复制到想要转移的客户机</li>
<li>扩展名改为 .bat，双击后重启系统或者双击运行两次</li>
</ol>
</li>
<li>场景三：部分客户端需要迁移至其他服务器：客户端 → 客户端管理</li>
</ol>
<h2 id="如何迁移-SQL-数据库？"><a href="#如何迁移-SQL-数据库？" class="headerlink" title="如何迁移 SQL 数据库？"></a>如何迁移 SQL 数据库？</h2><p>&emsp;&emsp;将默认数据库 CodeBase 迁移到 SQL server：使用 SQL Server 迁移工具</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;服务器安装文件夹&gt;\PCCSRV\HTTPDB目录     # 原有数据库 CodeBase 路径</span><br><span class="line">&lt;服务器安装文件夹&gt;\PCCSRV\Admin\Utility\SQL     # SQL<span class="built_in"> Server </span>迁移工具路径</span><br></pre></td></tr></table></figure>

<h2 id="当-OfficeScan-出现异常情况时，如何收集产品调试日志？（日志收集-Debug-工具介绍）"><a href="#当-OfficeScan-出现异常情况时，如何收集产品调试日志？（日志收集-Debug-工具介绍）" class="headerlink" title="当 OfficeScan 出现异常情况时，如何收集产品调试日志？（日志收集 Debug 工具介绍）"></a>当 OfficeScan 出现异常情况时，如何收集产品调试日志？（日志收集 Debug 工具介绍）</h2><p>&emsp;&emsp;使用 CDT 日志收集工具，运行后收集 OfficeScan 调试日志，<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZGNlbnRlci50cmVuZG1pY3JvLmNvbS9pbmRleC5waHA/cmVncz1OQUJVJmNsaz1sYXRlc3QmY2xrdmFsPTQyNjEmbGFuZ19sb2M9MQ==">下载地址<i class="fa fa-external-link-alt"></i></span></p>
<div class="note danger"><p>ACSE 接下来的课程皆为亚信安全产品的介绍及使用，如同博主记录的 OSCE 笔记一样，单纯文字无法描述清楚，如有学习需要，请前往亚信安全官方渠道，博主将不再更新有关 ACSE 的产品学习课程内容，敬请谅解！</p>
</div>]]></content>
      <categories>
        <category>AsiaInfo</category>
      </categories>
      <tags>
        <tag>OfficeScan</tag>
        <tag>防毒墙网络版</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 1.1 ~ 1.10 / 汇编语言 1.1 ~ 1.10</title>
    <url>/Assembly-Language/1.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》1.1 ~ 1.10、《零基础入门学习汇编语言》P1 ~ 4</p>
<span id="more"></span>

<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h2><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>,<span class="built_in">BX</span>     # 寄存器 <span class="built_in">BX</span> 的内容送到 <span class="built_in">AX</span> 中</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;寄存器：简单的讲是 CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器。AX 是其中一个寄存器的代号，BX 是另一个寄存器的代号。</p>
<h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><p>&emsp;&emsp;汇编语言由以下 3 类组成：</p>
<ol>
<li>汇编指令（机器码的助记符）</li>
<li>伪指令（由编译器执行）</li>
<li>其它符号（由编译器识别）</li>
</ol>
<p>&emsp;&emsp;汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p>
<h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><p>&emsp;&emsp;要想让一个 CPU 工作，就必须向它提供指令和数据。<br>&emsp;&emsp;指令和数据在存储器中存放，也就是平时所说的内存。<br>&emsp;&emsp;磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被 CPU 使用。</p>
<h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><p>&emsp;&emsp;存储器被划分为若干个存储单元，每个存储单元从 0 开始顺序编号。<br>&emsp;&emsp;例如：一个存储器有 128 个存储单元，编号从 0~127。</p>
<h2 id="1-7-CPU-对存储器的读写"><a href="#1-7-CPU-对存储器的读写" class="headerlink" title="1.7 CPU 对存储器的读写"></a>1.7 CPU 对存储器的读写</h2><p>&emsp;&emsp;CPU 要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互</p>
<ol>
<li>存储单元的地址（地址信息）</li>
<li>器件的选择，读或写命令（控制信息）</li>
<li>读或写的数据（数据信息）</li>
</ol>
<p>&emsp;&emsp;在计算机中专门有连接 CPU 和其他芯片的导线，通常称为总线。</p>
<ol>
<li>物理上：一根根导线的集合</li>
<li>逻辑上划分为：<ol>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ol>
</li>
</ol>
<h2 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h2><p>&emsp;&emsp;CPU 是通过地址总线来指定存储单元的。<br>&emsp;&emsp;地址总线上能传送多少个不同的信息，CPU 就可以对多少个存储单元进行寻址。<br>&emsp;&emsp;一个 CPU 有 N 根地址总线，则可以说这个 CPU 的地址总线的宽度为 N。<br>&emsp;&emsp;这样的 CPU 最多可以寻找 $2^N$<br>&emsp;&emsp;个内存单元。</p>
<h2 id="1-9-数据总线"><a href="#1-9-数据总线" class="headerlink" title="1.9 数据总线"></a>1.9 数据总线</h2><p>&emsp;&emsp;CPU 与内存或其它器件之间的数据传送是通过数据总线来进行的。<br>&emsp;&emsp;数据总线的宽度决定了 CPU 和外界的数据传送速度。</p>
<h2 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h2><p>&emsp;&emsp;CPU 对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。<br>&emsp;&emsp;有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。<br>&emsp;&emsp;所以，控制总线的宽度决定了 CPU 对外部器件的控制能力。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>汇编指令是机器指令的助记符，同机器指令一一对应。</li>
<li>每一种 CPU 都有自己的汇编指令集。</li>
<li>CPU 可以直接使用的信息在存储器中存放。</li>
<li>在存储器中指令和数据没有任何区别，都是二进制信息。</li>
<li>存储单元从零开始顺序编号。</li>
<li>一个存储单元可以存储 8 个 bit（用作单位写成“b”），即 8 位二进制数。</li>
<li>1B=8b</li>
<li>每一个 CPU 芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个 CPU 可以引出三种总线的宽度标志了这个 CPU 的不同方面的性能<ol>
<li>地址总线的宽度决定了 CPU 的寻址能力</li>
<li>数据总线的宽度决定了 CPU 与其它器件进行数据传送时的一次数据传送量；</li>
<li>控制总线的宽度决定了 CPU 对系统中其它器件的控制能力。</li>
</ol>
</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/2.html">《Assembly Language 1.11 ~ 2.6 / 汇编语言 1.11 ~ 2.6》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>地址总线</tag>
        <tag>数据总线</tag>
        <tag>控制总线</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 8.1 / 汇编语言 8.1</title>
    <url>/Assembly-Language/10.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》8.1、《零基础入门学习汇编语言》P38</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/9.html">《Assembly Language 7.1 ~ 7.10 / 汇编语言 7.1 ~ 7.10》</a></p>
</div>

<span id="more"></span>

<h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><p>&emsp;&emsp;为了描述上的简洁，我们将使用两个描述性的符号 reg 来表示一个寄存器，用 sreg 表示一个段寄存器。</p>
<ol>
<li>reg 的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；</li>
<li>sreg 的集合包括：ds、ss、cs、es。</li>
</ol>
<h2 id="8-1-bx、si、di、bp"><a href="#8-1-bx、si、di、bp" class="headerlink" title="8.1 bx、si、di、bp"></a>8.1 bx、si、di、bp</h2><p>&emsp;&emsp;在 8086 CPU 中，只有这 4 个寄存器（bx、bp、si、di）可以用在“[…]”中来进行内存单元的寻址。<br>&emsp;&emsp;正确的指令</p>
<ol>
<li>mov ax,[bx]</li>
<li>mov ax,[bx+si]</li>
<li>mov ax,[bx+di]</li>
<li>mov ax,[bp]</li>
<li>mov ax,[bp+si]</li>
<li>mov ax,[bp+di]</li>
</ol>
<p>&emsp;&emsp;错误的指令：<del>mov ax,[cx]、mov ax,[ax]、mov ax,[dx]、mov ax,[ds]</del><br>&emsp;&emsp;在“[…]”中，这 4 个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现</p>
<ol>
<li>bx 和 si</li>
<li>bx 和 di</li>
<li>bp 和 si</li>
<li>bp 和 di</li>
</ol>
<p>&emsp;&emsp;错误的用法：<del>mov ax,[bx+bp]、mov ax,[si+di]</del><br>&emsp;&emsp;正确的用法</p>
<ol>
<li>mov ax,[bx]</li>
<li>mov ax,[si]</li>
<li>mov ax,[di]</li>
<li>mov ax,[bp]</li>
<li>mov ax,[bx+si]</li>
<li>mov ax,[bx+di]</li>
<li>mov ax,[bp+si]</li>
<li>mov ax,[bp+di]</li>
<li>mov ax,[bx+si+idata]</li>
<li>mov ax,[bx+di+idata]</li>
<li>mov ax,[bp+si+idata]</li>
<li>mov ax,[bp+di+idata]</li>
</ol>
<p>&emsp;&emsp;只要在 […] 中使用寄存器 bp，而指令中没有显性的给出段地址，段地址就默认在 ss 中。比如</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,[bp]</td>
<td>(ax)=((ss)×16+(bp))</td>
</tr>
<tr>
<td>mov ax,[bp+idata]</td>
<td>(ax)=((ss)×16+(bp)+idata)</td>
</tr>
<tr>
<td>mov ax,[bp+si]</td>
<td>(ax)=((ss)×16+(bp)+(si))</td>
</tr>
<tr>
<td>mov ax,[bp+si+idata]</td>
<td>(ax)=((ss)×16+(bp)+(si)+idata)</td>
</tr>
</tbody></table>
<h2 id="8-2-机器指令处理的数据所在的位置"><a href="#8-2-机器指令处理的数据所在的位置" class="headerlink" title="8.2 机器指令处理的数据所在的位置"></a>8.2 机器指令处理的数据所在的位置</h2><p>&emsp;&emsp;绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：读取、写入、运算<br>&emsp;&emsp;在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行的前一刻，它将要处理的数据所在的位置。<br>&emsp;&emsp;指令在执行前，所要处理的数据可以在三个地方：CPU 内部、内存、端口</p>
<table>
<thead>
<tr>
<th>机器码</th>
<th>汇编指令</th>
<th>指令执行前数据的位置</th>
</tr>
</thead>
<tbody><tr>
<td>8E1E0000</td>
<td>mov bx,[0]</td>
<td>内存，ds:0 单元</td>
</tr>
<tr>
<td>89C3</td>
<td>mov bx,ax</td>
<td>CPU 内部，ax 寄存器</td>
</tr>
<tr>
<td>BB0100</td>
<td>mov bx,1</td>
<td>CPU 内部，指令缓存器</td>
</tr>
</tbody></table>
<h2 id="8-3-汇编语言中数据位置的表达"><a href="#8-3-汇编语言中数据位置的表达" class="headerlink" title="8.3 汇编语言中数据位置的表达"></a>8.3 汇编语言中数据位置的表达</h2><p>&emsp;&emsp;汇编语言中用三个概念来表达数据的位置。</p>
<ol>
<li>立即数（idata）<br>&emsp;&emsp;对于直接包含在机器指令中的数据（执行前在 CPU 的指令缓存器中），在汇编语言中称为：立即数（idata），在汇编指令中直接给出。例如：mov ax,1，对应机器码：B80100，执行结果：(ax)=1</li>
<li>寄存器<br>&emsp;&emsp;指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：mov ax,bx，对应机器码：89D8，执行结果：(ax)=(bx)</li>
<li>段地址（SA）和偏移地址（EA）<br>&emsp;&emsp;指令要处理的数据在内存中，在汇编指令中可用 [X] 的格式给出 EA，SA 在某个段寄存器中。<ol>
<li>存放段地址的寄存器可以是默认的。<br>&emsp;&emsp;示例（段地址默认在 ss 中！）<ol>
<li>mov ax,[0]（此处只能是 0，表示没有偏移地址，如改为其它数字均报错）</li>
<li>mov ax,[bx]</li>
<li>mov ax,[bx+8]</li>
<li>mov ax,[bx+si]</li>
<li>mov ax,[bx+si+8]</li>
<li>mov ax,[bp]</li>
<li>mov ax,[bp+8]</li>
<li>mov ax,[bp+si]</li>
<li>mov ax,[bp+si+8]</li>
</ol>
</li>
<li>存放段地址的寄存器也可以是显性的给出。<br>&emsp;&emsp;示例</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,ds:[bp]</td>
<td>(ax)=((ds)×16+(bp))</td>
</tr>
<tr>
<td>mov ax,es:[bx]</td>
<td>(ax)=((es)×16+(bx))</td>
</tr>
<tr>
<td>mov ax,ss:[bx+si]</td>
<td>(ax)=((ss)×16+(bx)+(si))</td>
</tr>
<tr>
<td>mov ax,cs:[bx+si+8]</td>
<td>(ax)=((cs)×16+(bx)+(si)+8)</td>
</tr>
</tbody></table>
<h2 id="8-4-寻址方式"><a href="#8-4-寻址方式" class="headerlink" title="8.4 寻址方式"></a>8.4 寻址方式</h2><p>&emsp;&emsp;当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。<br>&emsp;&emsp;8086 CPU 多种寻址方式小结</p>
<p><img data-src="https://www.hackme.cc/source/8086CPU%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93.webp" alt="8086CPU寻址方式小结.webp"></p>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/11.html">《Assembly Language 8.5 ~ 8.9 / 汇编语言 8.5 ~ 8.9》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>寻址方式</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 8.5 ~ 8.9 / 汇编语言 8.5 ~ 8.9</title>
    <url>/Assembly-Language/11.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》8.5 ~ 8.9、《零基础入门学习汇编语言》P39 ~ 41</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/10.html">《Assembly Language 8.1 / 汇编语言 8.1》</a></p>
</div>

<span id="more"></span>

<h2 id="8-5-指令要处理的数据有多长"><a href="#8-5-指令要处理的数据有多长" class="headerlink" title="8.5 指令要处理的数据有多长"></a>8.5 指令要处理的数据有多长</h2><p>&emsp;&emsp;8086 CPU 的指令，可以处理两种尺寸的数据，byte 和 word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。</p>
<ol>
<li>通过寄存器名指明要处理的数据的尺寸<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"># 下面的指令中，寄存器指明了指令进行的是字操作</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"># 下面的指令中，寄存器指明了指令进行的是字节操作</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">al</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">100</span></span><br></pre></td></tr></table></figure></li>
<li>在没有寄存器名存在的情况下，用操作符 X ptr 指明内存单元的长度，X 在汇编指令中可以为 word 或 byte<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"># 下面的指令中，用 <span class="built_in">word</span> <span class="built_in">ptr</span> 指明了指令访问的内存单元是一个字单元</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="number">1</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 下面的指令中，用 <span class="built_in">byte</span> <span class="built_in">ptr</span> 指明了指令访问的内存单元是一个字节单元</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="number">1</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>其他方法（有些指令默认了访问的是字单元还是字节单元）<br>比如：push [1000H] 就不用指明访问的是字单元还是字节单元，因为 push 指令只进行字操作。</li>
</ol>
<h2 id="8-7-div-指令"><a href="#8-7-div-指令" class="headerlink" title="8.7 div 指令"></a>8.7 div 指令</h2><p>&emsp;&emsp;div 是除法指令（division），使用 div 作除法的时候</p>
<ol>
<li>除数：8 位或 16 位，在寄存器或内存单元种</li>
<li>被除数：（默认）放在 AX 或 DX 和 AX 中</li>
</ol>
<table>
<thead>
<tr>
<th align="center">除数</th>
<th align="center">被除数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8 位</td>
<td align="center">16 位 (AX)</td>
</tr>
<tr>
<td align="center">16 位</td>
<td align="center">32 位 (DX+AX)</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;结果放在</p>
<table>
<thead>
<tr>
<th align="center">除数</th>
<th align="center">8 位</th>
<th align="center">16 位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">商</td>
<td align="center">AL</td>
<td align="center">AX</td>
</tr>
<tr>
<td align="center">余数</td>
<td align="center">AH</td>
<td align="center">DX</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;div 指令格式</p>
<ol>
<li>div reg</li>
<li>div 内存单元</li>
</ol>
<p>&emsp;&emsp;div 指令示例与含义</p>
<ol>
<li>div byte ptr ds:[0]<ol>
<li>(al)=(ax)/((ds)×16+0) 的商；</li>
<li>(ah)=(ax)/((ds)×16+0) 的余数</li>
</ol>
</li>
<li>div word ptr es:[0]<ol>
<li>(ax)=[(dx)×10000H+(ax)]/((ds)×16+0) 的商；</li>
<li>(<strong>dx</strong>)=[(dx)×10000H+(ax)]/((ds)×16+0) 的余数</li>
</ol>
</li>
<li>div byte ptr [bx+si+8]<ol>
<li>(al)=(ax)/((ds)×16+(bx)+(si)+8) 的商；</li>
<li>(ah)=(ax)/((ds)×16+(bx)+(si)+8) 的余数</li>
</ol>
</li>
<li>div word ptr [bx+si+8]<ol>
<li>(ax)=[(dx)+10000H+(ax)]/((ds)×16+(bx)+(si)+8) 的商；</li>
<li>(dx)=[(dx)+10000H+(ax)]/((ds)×16+(bx)+(si)+8) 的余数</li>
</ol>
</li>
</ol>
<h3 id="编程：利用除法指令计算-100001-100。"><a href="#编程：利用除法指令计算-100001-100。" class="headerlink" title="编程：利用除法指令计算 100001/100。"></a>编程：利用除法指令计算 100001/100。</h3><p>&emsp;&emsp;我们首先分析一下，被除数 100001 大于 65535，不能用 ax 寄存器存放，所以我们要用 dx 和 ax 两个寄存器联合存放 100001，也就是说要进行 16 位的除法。<br>&emsp;&emsp;除数 100 小于 255，可以在一个 8 位寄存器中存放，但是，因为被除数是 32 位的，除数应为 16 位，所以要用一个 16 位寄存器来存放除数 100。<br>&emsp;&emsp;因为要分别为 dx 和 ax 赋 100001 的高 16 位值和低 16 位值，所以应先将 100001 表示为十六进制形式：186A1H。<br>&emsp;&emsp;编程实现</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">86A1H</span>     # (<span class="built_in">dx</span>)×<span class="number">10000H</span>+(<span class="built_in">ax</span>)=<span class="number">100001</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">100</span></span><br><span class="line"><span class="keyword">div</span> <span class="built_in">bx</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;程序执行后，(ax)=03E8H（即 1000），(dx)=1（余数为 1）。</p>
<h2 id="8-8-伪指令-dd"><a href="#8-8-伪指令-dd" class="headerlink" title="8.8 伪指令 dd"></a>8.8 伪指令 dd</h2><p>&emsp;&emsp;我们用 db 和 dw 定义字节型数据和字型数据。<br>&emsp;&emsp;dd 是用来定义 dword（double word 双字）型数据的。<br>&emsp;&emsp;示例</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span> <span class="string">segment</span></span><br><span class="line"><span class="attr">db</span> <span class="string">1</span></span><br><span class="line"><span class="attr">dw</span> <span class="string">1</span></span><br><span class="line"><span class="attr">dd</span> <span class="string">1</span></span><br><span class="line"><span class="attr">data</span> <span class="string">ends</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 data 段中定义了三个数据</p>
<ol>
<li>第一个数据为 01H，在 data:0 处，占 1 个字节；</li>
<li>第二个数据为 0001H，在 data:1 处，占 1 个字；</li>
<li>第三个数据为 00000001H，在 data:3 处，占 2 个字；</li>
</ol>
<h2 id="8-9-dup"><a href="#8-9-dup" class="headerlink" title="8.9 dup"></a>8.9 dup</h2><p>&emsp;&emsp;dup 是一个操作符，在汇编语言中同 db、dw、dd 等一样，也是由编译器识别处理的符号。<br>&emsp;&emsp;它是和 db、dw、dd 等数据定义伪指令配合使用的，用来进行数据的重复。<br>&emsp;&emsp;dup 示例</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">db <span class="number">3</span> dup (<span class="number">0</span>)     # 定义了 <span class="number">3</span> 个字节，它们的值都是 <span class="number">0</span>，相当于 db <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">db <span class="number">3</span> dup (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)     # 定义了 <span class="number">9</span> 个字节，它们是 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>，相当于 db <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">db <span class="number">3</span> dup (<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;ABC&#x27;</span>)     # 定义了 <span class="number">18</span> 个字节，它们是 <span class="string">&#x27;abcABCabcABCabcABC&#x27;</span>，相当于 db<span class="string">&#x27;abcABCabcABCabcABC&#x27;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可见，dup 的使用格式如下</p>
<ol>
<li>db 重复的次数 dup (重复的字节型数据)</li>
<li>dw 重复的次数 dup (重复的字型数据)</li>
<li>dd 重复的次数 dup (重复的双字数据)</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/12.html">《Assembly Language 9.1 ~ 9.6 / 汇编语言 9.1 ~ 9.6》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>div</tag>
        <tag>dd</tag>
        <tag>dup</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 9.1 ~ 9.6 / 汇编语言 9.1 ~ 9.6</title>
    <url>/Assembly-Language/12.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》9.1 ~ 9.6、《零基础入门学习汇编语言》P43 ~ 44</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/11.html">《Assembly Language 8.5 ~ 8.9 / 汇编语言 8.5 ~ 8.9》</a></p>
</div>

<span id="more"></span>

<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><p>&emsp;&emsp;8086 CPU 的转移指令分为以下几类</p>
<ol>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程</li>
<li>中断</li>
</ol>
<h2 id="9-1-操作符-offset"><a href="#9-1-操作符-offset" class="headerlink" title="9.1 操作符 offset"></a>9.1 操作符 offset</h2><p>&emsp;&emsp;操作符 offset 在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址，比如下面的程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,offset start     # 相当于 <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,offset s     # 相当于 <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="9-2-jmp-指令"><a href="#9-2-jmp-指令" class="headerlink" title="9.2 jmp 指令"></a>9.2 jmp 指令</h2><p>&emsp;&emsp;jmp 为无条件转移，可以只修改 IP，也可以同时修改 CS 和 IP；<br>&emsp;&emsp;jmp 指令要给出两种信息</p>
<ol>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ol>
<h2 id="9-3-依据位移进行转移的-jmp-指令"><a href="#9-3-依据位移进行转移的-jmp-指令" class="headerlink" title="9.3 依据位移进行转移的 jmp 指令"></a>9.3 依据位移进行转移的 jmp 指令</h2><p>&emsp;&emsp;jmp short 标号（转到标号处执行指令）：这种格式的 jmp 指令实现的是<strong>段内短转移</strong>，它对 IP 的修改范围为 -128~127，也就是说，它向前转移时可以最多越过 128 个字节，向后转移可以最多越过 127 个字节。<br>&emsp;&emsp;汇编指令与机器码的对应示例</p>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>机器指令</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,0123</td>
<td>B8 23 01</td>
</tr>
<tr>
<td>mov ax,ds:[0123]</td>
<td>A1 23 01</td>
</tr>
<tr>
<td>push ds:[0123]</td>
<td>FF 36 23 01</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;可以看到，在一般的汇编指令中，汇编指令中的 idata（立即数），不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为 CPU 执行的是机器指令，它必须要处理这些数据或地址。</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>机器码</th>
<th>伪指令</th>
</tr>
</thead>
<tbody><tr>
<td>0BBD:0000</td>
<td>B80000</td>
<td>MOV AX,0000</td>
</tr>
<tr>
<td>0BBD:0003</td>
<td>BB0000</td>
<td>MOV BX,0000</td>
</tr>
<tr>
<td>0BBD:0006</td>
<td>EB03</td>
<td>JMP 000B</td>
</tr>
<tr>
<td>0BBD:0008</td>
<td>050100</td>
<td>ADD AX,0001</td>
</tr>
<tr>
<td>0BBD:000B</td>
<td>40</td>
<td>INC AX</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;jmp short s 指令的读取和执行过程</p>
<ol>
<li>(CS)=0BBDH，(IP)=0006，CS:IP 指向 EB 03（jmp short s 的机器码）；</li>
<li>读取指令码 EB 03 进入指令缓冲器；</li>
<li>(IP)=(IP)+ 所读取指令的长度 =(IP)+2=0008，CS:IP 指向 add ax,1；</li>
<li>CPU 执行指令缓冲器中的指令 EB 03；</li>
<li>指令 EB 03 执行后，(IP)=000BH，CS:IP 指向 inc ax。</li>
</ol>
<p>&emsp;&emsp;实际上，指令“jmp short 标号”的功能为 (IP)=(IP)+8 位位移。</p>
<ol>
<li>8 位位移 =“标号”处的地址 -jmp 指令后的第一个字节的地址；</li>
<li>short 指明此处的位移为 8 位位移；</li>
<li>8 位位移的范围为 -128~127，用<strong>补码</strong>表示</li>
<li>8 位位移由编译程序在编译时算出。</li>
</ol>
<p>&emsp;&emsp;还有一种和指令“jmp short 标号”功能相近的指令格式：jmp near ptr 标号<br>&emsp;&emsp;它实现的是<strong>段内近转移</strong>。<br>&emsp;&emsp;指令“jmp near ptr 标号”的功能为：(IP)=(IP)+16 位位移。<br>&emsp;&emsp;指令“jmp near ptr 标号”的说明</p>
<ol>
<li>16 位位移 =“标号”处的地址 -jmp 指令后的第一个字节的地址；</li>
<li>near ptr 指明此处的位移为 16 位位移，进行的是<strong>段内近转移</strong>；</li>
<li>16 位位移的范围为 -32768~32767，用补码表示；</li>
<li>16 位位移由编译程序在编译时算出。</li>
</ol>
<h2 id="9-4-转移的目的地址在指令中的-jmp-指令"><a href="#9-4-转移的目的地址在指令中的-jmp-指令" class="headerlink" title="9.4 转移的目的地址在指令中的 jmp 指令"></a>9.4 转移的目的地址在指令中的 jmp 指令</h2><p>&emsp;&emsp;前面讲的 jmp 指令，其对应的机器码中并没有转移的目的地址，而是相对于当前 IP 的转移位移。<br>&emsp;&emsp;指令“jmp far ptr 标号”实现的是段间转移，又称为<strong>远转移</strong>。<br>&emsp;&emsp;指令“jmp far ptr 标号”功能如下</p>
<ol>
<li>(CS)= 标号所在段的段地址；</li>
<li>(IP)= 标号所在段中的偏移地址。</li>
<li>far ptr 指明了指令用标号的段地址和偏移地址修改 CS 和 IP。</li>
</ol>
<h2 id="9-6-转移地址在内存中的-jmp-指令"><a href="#9-6-转移地址在内存中的-jmp-指令" class="headerlink" title="9.6 转移地址在内存中的 jmp 指令"></a>9.6 转移地址在内存中的 jmp 指令</h2><p>&emsp;&emsp;转移地址在内存中的 jmp 指令有两种格式</p>
<ol>
<li>jmp word ptr 内存单元地址（<strong>段内转移</strong>）<ol>
<li>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</li>
<li>内存单元地址可用寻址方式的任一格式给出。</li>
<li>示例<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]     # 相当于 <span class="keyword">jmp</span> <span class="built_in">ax</span></span><br><span class="line">执行后，(<span class="built_in">IP</span>)=<span class="number">0123H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123H</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>]</span><br><span class="line">执行后，(<span class="built_in">IP</span>)=<span class="number">0123H</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>jmp dword ptr 内存单元地址（<strong>段间转移</strong>）<ol>
<li>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</li>
<li>(CS)=(内存单元地址+2)</li>
<li>(IP)=(内存单元地址)</li>
<li>内存单元地址可用寻址方式的任一格式给出。</li>
<li>示例<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">执行后，(<span class="built_in">CS</span>)=<span class="number">0</span>，(<span class="built_in">IP</span>)=<span class="number">0123H</span>，<span class="built_in">CS</span>:<span class="built_in">IP</span> 指向 <span class="number">0000</span>:<span class="number">0123</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123H</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>]</span><br><span class="line">执行后，(<span class="built_in">CS</span>)=<span class="number">0</span>，(<span class="built_in">IP</span>)=<span class="number">0123H</span>，<span class="built_in">CS</span>:<span class="built_in">IP</span> 指向 <span class="number">0000</span>:<span class="number">0123</span>。</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/13.html">《Assembly Language 9.7 ~ 9.9 / 汇编语言 9.7 ~ 9.9》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>jmp</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 9.7 ~ 9.9 / 汇编语言 9.7 ~ 9.9</title>
    <url>/Assembly-Language/13.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》9.7 ~ 9.9、《零基础入门学习汇编语言》P45 ~ 46</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/12.html">《Assembly Language 9.1 ~ 9.6 / 汇编语言 9.1 ~ 9.6》</a></p>
</div>

<span id="more"></span>

<h2 id="9-7-jcxz-指令"><a href="#9-7-jcxz-指令" class="headerlink" title="9.7 jcxz 指令"></a>9.7 jcxz 指令</h2><p>&emsp;&emsp;jcxz 指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为 -128~127。<br>&emsp;&emsp;指令格式：jcxz 标号（如果 (cx)=0，则转移到标号处执行。）<br>&emsp;&emsp;jcxz 标号指令操作</p>
<ol>
<li>当 (cx)=0 时，(IP)=(IP)+8 位位移<ol>
<li>8 位位移 =“标号”处的地址 -jcxz 指令后的第一个字节的地址；</li>
<li>8 位位移的范围为 -128~127，用补码表示；</li>
<li>8 位位移由编译程序在编译时算出。</li>
</ol>
</li>
<li>当 (cx)≠0 时，什么也不做（程序向下执行）。</li>
</ol>
<p>&emsp;&emsp;指令“jcxz 标号”的功能相当于</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">if((cx)==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">jmp </span><span class="keyword">short </span>标号;</span><br></pre></td></tr></table></figure>

<h2 id="9-8-loop-指令"><a href="#9-8-loop-指令" class="headerlink" title="9.8 loop 指令"></a>9.8 loop 指令</h2><p>&emsp;&emsp;loop 指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为 -128~127<br>&emsp;&emsp;指令格式：loop 标号（(cx)=(cx)-1，如果 (cx)≠0，转移到标号处执行。）<br>&emsp;&emsp;loop 标号指令操作</p>
<ol>
<li>(cx)=(cx)-1；</li>
<li>如果 (cx)≠0，(IP)=(IP)+8 位位移。<ol>
<li>8 位位移 =“标号”处的地址 -loop 指令后的第一个字节的地址；</li>
<li>8 位位移的范围为 -128~127，用补码表示；</li>
<li>8 位位移由编译程序在编译时算出。</li>
</ol>
</li>
<li>当 (cx)=0 时，什么也不做（程序向下执行）。</li>
</ol>
<p>&emsp;&emsp;指令“loop 标号”的功能相当于</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">cx</span>)--<span class="comment">;</span></span><br><span class="line">if((<span class="built_in">cx</span>)≠<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">jmp</span> short 标号<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-9-根据位移进行转移的意义"><a href="#9-9-根据位移进行转移的意义" class="headerlink" title="9.9 根据位移进行转移的意义"></a>9.9 根据位移进行转移的意义</h2><ol>
<li>jmp short 标号</li>
<li>jmp near ptr 标号</li>
<li>jcxz 标号</li>
<li>loop 标号</li>
</ol>
<p>&emsp;&emsp;它们对 IP 的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。<br>&emsp;&emsp;这样设计，方便了程序段在内存中的浮动装配。<br>&emsp;&emsp;例如</p>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>机器代码</th>
</tr>
</thead>
<tbody><tr>
<td>mov cx,6</td>
<td>B9 06 00</td>
</tr>
<tr>
<td>mov ax,10</td>
<td>B8 10 00</td>
</tr>
<tr>
<td>s:add ax,ax</td>
<td>01 C0</td>
</tr>
<tr>
<td>loop s</td>
<td>E2 FC</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;这段程序装在内存中的不同位置都可正确执行，因为 loop s 在执行时只涉及到 s 的位移（-4，前移 4 个字节，补码表示为 FCH），而不是 s 的地址。</p>
<div class="note info"><p>形如“jmp 2000:0100”的转移指令，是在 Debug 中使用的汇编指令，汇编编译器并不认识。如果在源程序中使用，编译时也会报错。</p>
</div>

<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/14.html">《Assembly Language 10.1 ~ 10.7 / 汇编语言 10.1 ~ 10.7》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>jcxz</tag>
        <tag>loop</tag>
        <tag>位移</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 10.1 ~ 10.7 / 汇编语言 10.1 ~ 10.7</title>
    <url>/Assembly-Language/14.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》10.1 ~ 10.7、《零基础入门学习汇编语言》P47 ~ 49</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/13.html">《Assembly Language 9.7 ~ 9.9 / 汇编语言 9.7 ~ 9.9》</a></p>
</div>

<span id="more"></span>

<h1 id="第十章-Call-和-Ret-指令"><a href="#第十章-Call-和-Ret-指令" class="headerlink" title="第十章 Call 和 Ret 指令"></a>第十章 Call 和 Ret 指令</h1><p>&emsp;&emsp;call 和 ret 指令都是转移指令，它们都修改 IP，或同时修改 CS 和 IP。<br>&emsp;&emsp;它们经常被共同用来实现程序的设计。</p>
<h2 id="10-1-ret-和-retf"><a href="#10-1-ret-和-retf" class="headerlink" title="10.1 ret 和 retf"></a>10.1 ret 和 retf</h2><p>&emsp;&emsp;ret 指令用栈中的数据，修改 IP 的内容，从而实现近转移。<br>&emsp;&emsp;CPU 执行 ret 指令时，进行下面的两步操作</p>
<ol>
<li>(IP)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
</ol>
<p>&emsp;&emsp;retf 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移；<br>&emsp;&emsp;CPU 执行 retf 指令时，进行下面几步操作：</p>
<ol>
<li>(IP)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
<li>(cs)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
</ol>
<p>&emsp;&emsp;可以看出，如果我们用汇编语法来解释 ret 和 retf 指令，则</p>
<ol>
<li>CPU 执行 ret 指令时，相当于进行<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">IP</span></span><br></pre></td></tr></table></figure></li>
<li>CPU 执行 retf 指令时，相当于进行<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="10-2-call-指令"><a href="#10-2-call-指令" class="headerlink" title="10.2 call 指令"></a>10.2 call 指令</h2><p>call 指令经常跟 ret 指令配合使用，因此 CPU 执行 call 指令，进行两步操作</p>
<ol>
<li>将当前的 IP 或 CS 和 IP 压入栈中；</li>
<li>转移（jmp）。</li>
</ol>
<div class="note warning"><p>call 指令<strong>不能实现</strong><del>短转移</del>，除此之外，call 指令实现转移的方法和 jmp 指令的原理相同。</p>
</div>

<h2 id="10-3-依据位移进行转移的-call-指令"><a href="#10-3-依据位移进行转移的-call-指令" class="headerlink" title="10.3 依据位移进行转移的 call 指令"></a>10.3 依据位移进行转移的 call 指令</h2><p>call 标号（将当前的 IP 压栈后，转到标号处执行指令）<br>CPU 执行此种格式的 call 指令时，进行如下的操作</p>
<ol>
<li>(sp)=(sp)-2</li>
<li>((ss)*16+(sp))=(IP)</li>
<li>(IP)=(IP)+16 位位移</li>
</ol>
<p>16 位位移 =“标号”处的地址 -call 指令后的第一个字节的地址；<br>16 位位移的范围为 -32768~32767，用补码表示；<br>16 位位移由编译程序在编译时算出。<br>从上面的描述中，可以看出，如果用汇编语法来解释此种格式的 call 指令。则<br>CPU 执行指令“call 标号”时，相当于进行</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>

<h2 id="10-4-转移的目的地址在指令中的-call-指令"><a href="#10-4-转移的目的地址在指令中的-call-指令" class="headerlink" title="10.4 转移的目的地址在指令中的 call 指令"></a>10.4 转移的目的地址在指令中的 call 指令</h2><p>call 指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前 IP 的转移位移。<br>指令“call far ptr 标号”实现的是段间转移。<br>CPU 执行“call far ptr 标号”这种格式的 call 指令时的操作</p>
<ol>
<li>(sp)=(sp)-2</li>
<li>((ss)×16+(sp))=(CS)</li>
<li>(sp)=(sp)-2</li>
<li>((ss)×16+(sp))=(IP)</li>
<li>(CS)= 标号所在的段地址</li>
<li>(IP)= 标号所在的偏移地址</li>
</ol>
<p>从上面的描述中可以看出，如果我们用汇编语法来解释此种格式的 call 指令，则<br>CPU 执行指令“call far ptr 标号”时，相当于进行</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>

<h2 id="10-5-转移地址在寄存器中的-call-指令"><a href="#10-5-转移地址在寄存器中的-call-指令" class="headerlink" title="10.5 转移地址在寄存器中的 call 指令"></a>10.5 转移地址在寄存器中的 call 指令</h2><p>&emsp;&emsp;指令格式：call 16 位寄存器<br>&emsp;&emsp;功能</p>
<ol>
<li>(sp)=(sp)-2</li>
<li>((ss)×16+(sp))=(IP)</li>
<li>(IP)=(16 位寄存器)</li>
</ol>
<p>&emsp;&emsp;汇编语法解释此种格式的 call 指令，CPU 执行 call 16 位 reg 时，相当于进行</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16 位寄存器</span><br></pre></td></tr></table></figure>

<h2 id="10-6-转移地址在内存中的-call-指令"><a href="#10-6-转移地址在内存中的-call-指令" class="headerlink" title="10.6 转移地址在内存中的 call 指令"></a>10.6 转移地址在内存中的 call 指令</h2><p>&emsp;&emsp;转移地址在内存中的 call 指令有两种格式</p>
<ol>
<li>call word ptr 内存单元地址<ol>
<li>汇编语法解释<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure></li>
<li>示例<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">10h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]     # 执行后，(<span class="built_in">IP</span>)=<span class="number">0123H</span>，(<span class="built_in">sp</span>)=<span class="number">0EH</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>call dword ptr 内存单元地址<ol>
<li>汇编语法解释<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure></li>
<li>示例<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">10h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]     # 执行后，(<span class="built_in">CS</span>)=<span class="number">0</span>，(<span class="built_in">IP</span>)=<span class="number">0123H</span>，(<span class="built_in">sp</span>)=<span class="number">0CH</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="10-7-call-和-ret-的配合使用"><a href="#10-7-call-和-ret-的配合使用" class="headerlink" title="10.7 call 和 ret 的配合使用"></a>10.7 call 和 ret 的配合使用</h2><p>&emsp;&emsp;前面，我们已经分别学习了 ret 和 call 指令的原理。现在我们看一下，如何将它们配合使用来实现子程序的机制。</p>
<h2 id="问题-10-1"><a href="#问题-10-1" class="headerlink" title="问题 10.1"></a>问题 10.1</h2><p>&emsp;&emsp;下面程序返回前，bx 中的值是多少？</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3</span></span><br><span class="line">	<span class="keyword">call</span> s</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">	s:</span></span><br><span class="line">		<span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">loop</span> s</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们来看一下 CPU 执行这个程序的主要过程</p>
<ol>
<li>CPU 将 call s 指令的机器码读入，IP 指向了 call s 后的指令 mov bx,ax，然后 CPU 执行 call s 指令，将当前的 IP 值（指令 mov bx,ax 的偏移地址）压栈，并将 IP 的值改变为标号 s 处的偏移地址；</li>
<li>CPU 从标号 s 处开始执行指令，loop 循环完毕，(ax)=8；</li>
<li>CPU 将 ret 指令的机器码读入，IP 指向了 ret 指令后的内存单元，然后 CPU 执行 ret 指令，从栈中弹出一个值（即 call 先前压入的 mov bx,ax 指令的偏移地址）送入 IP 中。则 CS:IP 指向指令 mov bx,ax；</li>
<li>CPU 从 mov bx,ax 开始执行指令，直至完成。</li>
</ol>
<p>&emsp;&emsp;因此，程序返回前，(bx)=8。我们可以看出，从标号 s 到 ret 的程序段的作用是计算 2 的 N 次方，计算前，N 的值由 CX 提供。</p>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/15.html">《Assembly Language 10.8 ~ 10.12 / 汇编语言 10.8 ~ 10.12》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>call</tag>
        <tag>ret</tag>
        <tag>retf</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 10.8 ~ 10.12 / 汇编语言 10.8 ~ 10.12</title>
    <url>/Assembly-Language/15.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》10.8 ~ 10.12、《零基础入门学习汇编语言》P49 ~ 51</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/14.html">《Assembly Language 10.1 ~ 10.7 / 汇编语言 10.1 ~ 10.7》</a></p>
</div>

<span id="more"></span>

<h2 id="10-8-mul-指令"><a href="#10-8-mul-指令" class="headerlink" title="10.8 mul 指令"></a>10.8 mul 指令</h2><p>&emsp;&emsp;因下面要用到，我们介绍一下 mul 指令，mul 是乘法指令，使用 mul 做乘法的时候</p>
<ol>
<li>相乘的两个数：要么<strong>都</strong>是 8 位，要么<strong>都</strong>是 16 位。<ol>
<li>8 位：AL 中和 8 位寄存器或内存<strong>字节</strong>单元中；</li>
<li>16 位：AX 中和 16 位寄存器或内存<strong>字</strong>单元中。</li>
</ol>
</li>
<li>结果<ol>
<li>8 位：AX 中；</li>
<li>16 位：DX（高位）和 AX（低位）中。</li>
</ol>
</li>
</ol>
<p>&emsp;&emsp;格式如下</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mul</span> reg</span><br><span class="line"><span class="keyword">mul</span> 内存单元</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;内存单元可以用不同的寻址方式给出，比如</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mul</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]     # 含义为：(<span class="built_in">ax</span>)=(<span class="built_in">al</span>)×((<span class="built_in">ds</span>)×<span class="number">16</span>+<span class="number">0</span>)</span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>+<span class="number">8</span>]</span><br><span class="line">含义为：</span><br><span class="line">(<span class="built_in">ax</span>)=(<span class="built_in">ax</span>)×((<span class="built_in">ds</span>)×<span class="number">16</span>+(<span class="built_in">bx</span>)+(<span class="built_in">si</span>)+<span class="number">8</span>) 结果的低 <span class="number">16</span> 位；</span><br><span class="line">(<span class="built_in">dx</span>)=(<span class="built_in">ax</span>)×((<span class="built_in">ds</span>)×<span class="number">16</span>+(<span class="built_in">bx</span>)+(<span class="built_in">si</span>)+<span class="number">8</span>) 结果的高 <span class="number">16</span> 位；</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;例如</p>
<ol>
<li>计算 100×10<br>100 和 10 小于 255，可以做 8 位乘法，程序如下<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">100</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">10</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">bl</span></span><br><span class="line">结果：(<span class="built_in">ax</span>)=<span class="number">1000</span>（<span class="number">03E8H</span>）</span><br></pre></td></tr></table></figure></li>
<li>计算 100×10000<br>100 小于 255，可 10000 大于 255，所以必须做 16 位乘法，程序如下<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">100</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">10000</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">结果：(<span class="built_in">ax</span>)=<span class="number">4240H</span>，(<span class="built_in">dx</span>)=<span class="number">000FH</span>（<span class="number">F4240H</span>=<span class="number">1000000</span>）</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="10-9-模块化程序设计"><a href="#10-9-模块化程序设计" class="headerlink" title="10.9 模块化程序设计"></a>10.9 模块化程序设计</h2><p>&emsp;&emsp;从上面我们看到，call 与 ret 指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。<br>&emsp;&emsp;因为现实的问题比较复杂，对现实问题进行分析时，把它转化成相互联系、不同层次的子问题，是必须的解决方法。<br>&emsp;&emsp;而 call 和 ret 指令对这种分析方法提供了程序实现上的支持。利用 call 和 ret 指令，我们可以用简洁的方法，实现多个互相联系、功能独立的子程序来解决一个夫复杂的问题。</p>
<h2 id="10-10-参数和结果传递的问题"><a href="#10-10-参数和结果传递的问题" class="headerlink" title="10.10 参数和结果传递的问题"></a>10.10 参数和结果传递的问题</h2><p>&emsp;&emsp;子程序一般都要根据提供的参数处理一定的事务，处理后，将结果（返回值）提供给调用者。<br>&emsp;&emsp;其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。<br>&emsp;&emsp;我们设计一个子程序，可以根据提供的 N，来计算 N 的 3 次方。<br>&emsp;&emsp;这里有两个问题</p>
<ol>
<li>我们将参数 N 存储在什么地方？</li>
<li>计算得到的数值，我们存储在什么地方？</li>
</ol>
<p>&emsp;&emsp;很显然，我们可以用寄存器来存储，可以将参数放到 bx 中；<br>&emsp;&emsp;因为子程序中要计算 N×N×N，可以使用多个 mul 指令，为了方便，可将结果放到 dx 和 ax 中。<br>&emsp;&emsp;子程序</p>
<ol>
<li>说明：计算 N 的 3 次方</li>
<li>参数：(bx)=N</li>
<li>结果：(dx:ax)= $N^3$<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cube:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">mul</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br></pre></td></tr></table></figure></li>
</ol>
<div class="note info"><p>我们在编程的时候要注意良好的风格，对于程序应有详细的注释。子程序的注释信息应该包含对子程序的功能、参数和结果的说明。</p>
</div>

<p>&emsp;&emsp;用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反</p>
<ol>
<li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值；</li>
<li>子程序从参数寄存器中取到参数，将返回值送入结果寄存器。</li>
</ol>
<h2 id="10-11-批量数据的传递"><a href="#10-11-批量数据的传递" class="headerlink" title="10.11 批量数据的传递"></a>10.11 批量数据的传递</h2><p>&emsp;&emsp;前面的例程中，子程序 cube 只有一个参数，放在 bx 中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的参数有 3 个、4 个或更多直至 N 个，我们怎样存放呢？<br>&emsp;&emsp;寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递的数据。对于返回值，也有同样的问题。<br>&emsp;&emsp;在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。<br>&emsp;&emsp;对于具有批量数据的返回结果，也可用同样的方法。<br>&emsp;&emsp;编程：将 data 段中的字符串转化为大写。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">&#x27;conversation&#x27;</span></span><br><span class="line">date ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span>     # <span class="built_in">ds</span>:<span class="built_in">si</span> 指向字符串（批量数据）所在空间的首地址</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">12</span>     # <span class="built_in">cx</span> 存放字符串的长度</span><br><span class="line">	<span class="keyword">call</span> capital</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital:</span></span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">loop</span> capital</span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<div class="note info"><p>除了寄存器、内存传递参数外，还有一种通用的方法使用栈来传递参数。关于这种技巧请参看附注 4。</p>
</div>

<h2 id="10-12-寄存器冲突的问题"><a href="#10-12-寄存器冲突的问题" class="headerlink" title="10.12 寄存器冲突的问题"></a>10.12 寄存器冲突的问题</h2><p>&emsp;&emsp;设计一个子程序</p>
<ol>
<li>功能：将一个全是字母，以 0 结尾的字符串，转化为大写。</li>
<li>程序要处理的字符串以 0 作为结尾符，这个字符串可以如下定义</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">db</span> <span class="string">&#x27;conversation&#x27;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;分析</p>
<ol>
<li>应用这个子程序，字符串的内容后面定要有一个 0，标记字符串的结束。子程序可以依次读取每个字符进行检测，如果不是 0，就进行大写的转化，如果是 0，就结束处理。</li>
<li>由于可通过检测 0 而知道是否已经处理完整个字符串，所以子程序可以不需要字符串的长度作为参数。我们可以直接用 jcxz 来检测 0。</li>
</ol>
<p>&emsp;&emsp;子程序实现代码</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">capital:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jcxz</span> ok     # 如果 (<span class="built_in">cx</span>)=<span class="number">0</span>，结束；如果不是 <span class="number">0</span>，处理。</span><br><span class="line">	<span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span>     # 将 <span class="built_in">ds</span>:<span class="built_in">si</span> 所指单元中的字母转化为大写</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span>     # <span class="built_in">ds</span>:<span class="built_in">si</span> 指向下一个单元</span><br><span class="line">	<span class="keyword">jmp</span> short capital</span><br><span class="line"><span class="symbol">ok:</span><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;子程序的应用<br>&emsp;&emsp;将 data 段中的字符串全部转化为大写</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">assume</span> <span class="string">cs:code</span></span><br><span class="line"><span class="attr">data</span> <span class="string">segment</span></span><br><span class="line">	<span class="attr">db</span> <span class="string">&#x27;word&#x27;,0</span></span><br><span class="line">	<span class="attr">db</span> <span class="string">&#x27;unix&#x27;,0</span></span><br><span class="line">	<span class="attr">db</span> <span class="string">&#x27;wind&#x27;,0</span></span><br><span class="line">	<span class="attr">db</span> <span class="string">&#x27;good&#x27;.0</span></span><br><span class="line"><span class="attr">data</span> <span class="string">ends</span></span><br></pre></td></tr></table></figure>

<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/16.html">《Assembly Language 11.1 ~ 11.6 / 汇编语言 11.1 ~ 11.6》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>mul</tag>
        <tag>模块化</tag>
        <tag>子程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 11.1 ~ 11.6 / 汇编语言 11.1 ~ 11.6</title>
    <url>/Assembly-Language/16.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》11.1 ~ 11.6、《零基础入门学习汇编语言》P54 ~ 55</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/15.html">《Assembly Language 10.8 ~ 10.12 / 汇编语言 10.8 ~ 10.12》</a></p>
</div>

<span id="more"></span>

<h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><p>&emsp;&emsp;8086 CPU 的标志寄存器有 16 位，其中存储的信息通常被称为程序状态字（PSW）。<br>&emsp;&emsp;我们已经使用过 8086 CPU 的 ax、bx、cx、dx、si、di、bp、sp、ip、cs、ss、ds、es 等 13 个寄存器了。<br>&emsp;&emsp;本章中的标志寄存器（以下简称为 flag）是我们要学习的最后一个寄存器。<br>&emsp;&emsp;flag 和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。<br>&emsp;&emsp;而 flag 寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。<br>&emsp;&emsp;flag 的 1、3、5、12、13、14、15 位在 8086 CPU 中没有使用，不具有任何含义。而 0、2、4、6、7、8、9、10、11 位都具有特殊的含义。</p>
<h2 id="11-1-ZF-标志"><a href="#11-1-ZF-标志" class="headerlink" title="11.1 ZF 标志"></a>11.1 ZF 标志</h2><p>flag 的第 6 位是 ZF，零标志位。它记录相关指令执行后</p>
<ol>
<li>结果为 0，ZF=1</li>
<li>结果不为 0，ZF=0</li>
</ol>
<p>&emsp;&emsp;例如</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mov ax,<span class="number">1</span></span><br><span class="line">sub ax,<span class="number">1</span></span><br><span class="line">指令执行后，结果为 <span class="number">0</span>，则 ZF=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">mov ax,<span class="number">2</span></span><br><span class="line">sub ax,<span class="number">1</span></span><br><span class="line">指令执行后，结果为 <span class="number">1</span>，则 ZF=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于 ZF 的值，我们可以这样来看，ZF 标记相关指令的计算结果是否为 0，如果为 0，则在 ZF 要记录下“是 0”这样的肯定信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mov ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">and</span> ax,<span class="number">0</span></span><br><span class="line">执行后，结果为 <span class="number">0</span>，则 ZF=<span class="number">1</span>，表示“结果是 <span class="number">0</span>”</span><br><span class="line"></span><br><span class="line">mov ax,<span class="number">1</span></span><br><span class="line"><span class="keyword">or</span> ax,<span class="number">0</span></span><br><span class="line">执行后，结果不为 <span class="number">0</span>，则 ZF=<span class="number">0</span>，表示“结果非 <span class="number">0</span>”</span><br></pre></td></tr></table></figure>

<div class="note info"><p>在 8086 CPU 的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and 等，它们大都是运算指令（进行逻辑或算术运算）；<br>有的指令的执行对标志寄存器没有影响，比如：mov、push、pop 等，它们大都是传送指令。</p>
</div>

<p>&emsp;&emsp;我们在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标记寄存器的哪些标志位造成影响。</p>
<h2 id="11-2-PF-标志"><a href="#11-2-PF-标志" class="headerlink" title="11.2 PF 标志"></a>11.2 PF 标志</h2><p>flag 的第 2 位是 PF，奇偶标志位。它记录指令执行后，结果的所有二进制中 1 的个数</p>
<ol>
<li>为偶数，PF=1</li>
<li>为奇数，PF=0</li>
</ol>
<p>&emsp;&emsp;示例</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mov al,<span class="number">1</span></span><br><span class="line">add al,<span class="number">10</span></span><br><span class="line">执行后，结果为 <span class="number">00001011</span>B，其中有 <span class="number">3</span>（奇数）个 <span class="number">1</span>，则 PF=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">mov al,<span class="number">1</span></span><br><span class="line"><span class="keyword">or</span> al,<span class="number">10</span></span><br><span class="line">执行后，结果为 <span class="number">00000011</span>B，其中有 <span class="number">2</span>（偶数）个 <span class="number">1</span>，则 PF=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="有符号数与补码"><a href="#有符号数与补码" class="headerlink" title="有符号数与补码"></a>有符号数与补码</h2><p>&emsp;&emsp;我们知道计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。<br>&emsp;&emsp;比如</p>
<ol>
<li>00000001B，可以看作为无符号数 1，或有符号数 +1</li>
<li>10000001B，可以看作为无符号数 129，也可以看作有符号数 -127</li>
</ol>
<p>&emsp;&emsp;这也就是说，对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算。</p>
<h2 id="11-3-SF-标志"><a href="#11-3-SF-标志" class="headerlink" title="11.3 SF 标志"></a>11.3 SF 标志</h2><p>flag 的第 7 位是 SF，符号标志位。它记录指令执行后</p>
<ol>
<li>结果为负，SF=1</li>
<li>结果为正，SF=0</li>
</ol>
<p>&emsp;&emsp;示例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000001B</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">结果：(<span class="built_in">al</span>)=<span class="number">10000010B</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以将 add 指令进行的运算当作无符号数的运算，那么 add 指令相当于计算 129+1，结果为 130（10000010B）；<br>&emsp;&emsp;也可以将 add 指令进行的运算当作有符号数的运算，那么 add 指令相当于计算 -127+1，结果为 -126（10000010B）。<br>&emsp;&emsp;不管我们如何看待，CPU 在执行 add 等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。<br>&emsp;&emsp;关键在于我们的程序需要哪一种结果。<br>&emsp;&emsp;SF 标志，就是 CPU 对有符号数运算结果的一种记录，它记录数据的正负。<br>&emsp;&emsp;在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。<br>&emsp;&emsp;如果我们将数据当作无符号数来运算，SF 的值则没有意义，虽然相关的指令影响了它的值。<br>&emsp;&emsp;这也就是说，CPU 在执行 add 等指令时，是必须然要影响到 SF 标志位的值的。<br>&emsp;&emsp;至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算了。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000001B</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">执行后，结果为 <span class="number">10000010B</span>，SF=<span class="number">1</span></span><br><span class="line">表示：如果指令进行的是有符号数运算，那么结果为负</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10000001B</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">01111111B</span></span><br><span class="line">执行后，结果为 <span class="number">0</span>，SF=<span class="number">0</span></span><br><span class="line">表示：如果指令进行的是有符号数运算，那么结果为非负。</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;某些指令将影响标志寄存器中的多个标志位。这些被影响的标记为比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。<br>&emsp;&emsp;比如指令 sub al,al 执行后，ZF、PF、SF 等标志位都要受到影响，它们分别为：1、1、0。</p>
<h2 id="11-4-CF-标志"><a href="#11-4-CF-标志" class="headerlink" title="11.4 CF 标志"></a>11.4 CF 标志</h2><p>&emsp;&emsp;flag 的第 0 位是 CF，进位标志位。<br>&emsp;&emsp;一边情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的错位值。<br>&emsp;&emsp;对于位数为 N 的无符号数来说，其对应的二进制信息的最高位，即第 N-1 位的最高有效位，而假想存在的第 N 位，就是相对于最高有效位的更高位。<br>&emsp;&emsp;我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进行。<br>&emsp;&emsp;比如，两个 8 位数据：98H+98H，将产生进位。由于这个进位值在 8 位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了。<br>&emsp;&emsp;其实 CPU 在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。<br>&emsp;&emsp;8086 CPU 就用 flag 的 CF 位来记录这个进位值。<br>&emsp;&emsp;另外一种情况，而当两个数据做减法的时候，有可能向更高位借位。<br>&emsp;&emsp;比如，两个 8 位数据：91H-98H，将产生借位，借位后，相当于计算 197H-98H。<br>&emsp;&emsp;而 flag 的 CF 位也可以用来记录这个借位值。</p>
<h2 id="11-5-OF-标志"><a href="#11-5-OF-标志" class="headerlink" title="11.5 OF 标志"></a>11.5 OF 标志</h2><p>&emsp;&emsp;在进行有符号数运算的时候，如超过了机器所能表示的范围称为溢出。<br>&emsp;&emsp;比如：add al,3，那么对于 8 位的有符号数据，机器所能表示的范围就是 -128~127。<br>&emsp;&emsp;如果运算结果超出了机器所能表达的范围，将产生溢出。</p>
<div class="note warning"><p>这里所讲的溢出，只是对有符号数运算而言。（就像进位只是相对于无符号数而言！）</p>
</div>

<p>&emsp;&emsp;就上面的两个例子来说</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">98</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">99</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;add 指令运算的结果是 (al)=0C5H，因为进行的是有符号数运算，所以 al 中存储的是有符号数，而 0C5H 是有符号数 -59 的补码。<br>&emsp;&emsp;如果我们用 add 指令进行的是有符号数运算，则 98+99=-59 这样的结果让人无法接受。<br>&emsp;&emsp;造成这种情况的原因，就是实际的结果 197，作为一个有符号数，在 8 位寄存器 al 中存放不下。<br>&emsp;&emsp;由于在进行有符号数运算时，可能发生溢出而造成结果的错误。所以 CPU 需要对指令执行后是否产生溢出进行记录。因此有了 OF</p>
<div class="note info"><p>记住，一定要注意 CF 和 OF 的区别</p>
<ol>
<li>CF 是对无符号数运算有意义的标志位</li>
<li>而 OF 是对有符号数运算有意义的标志位</li>
</ol>
</div>

<p>&emsp;&emsp;对于无符号数运算，CPU 用 CF 位来记录是否产生了进位；<br>&emsp;&emsp;对于有符号数运算，CPU 用 OF 位来记录是否产生了溢出，<br>&emsp;&emsp;当然，还要用 SF 位来记录结果的符号。</p>
<div class="note info"><p>对于有无符号，计算机是分不清楚状况的，因此他必须<strong>两种都记载着</strong>，要怎么用，看的是你当他是什么！</p>
</div>

<p>&emsp;&emsp;例如</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">98d</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">99d</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于无符号数运算，98+99 没有进位，CF=0；<br>&emsp;&emsp;对于有符号数运算，98+99 发生溢出，OF=1。</p>
<h2 id="11-6-adc-指令"><a href="#11-6-adc-指令" class="headerlink" title="11.6 adc 指令"></a>11.6 adc 指令</h2><p>adc 是带进位加法指令，它利用了 CF 位上记录的进位值。</p>
<ol>
<li>格式：adc 操作对象 1,操作对象 2</li>
<li>功能：操作对象 1=操作对象 1+操作对象 2+CF</li>
<li>比如：adc ax,bx 实现的功能是：(ax)=(ax)+(bx)+CF</li>
</ol>
<p>adc 指令示例</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">1</span>     # 执行后，(<span class="built_in">ax</span>)=<span class="number">4</span></span><br><span class="line"><span class="keyword">adc</span> 执行时，相当于计算：(<span class="built_in">ax</span>)+<span class="number">1</span>+CF=<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">3</span>     # 执行后，(<span class="built_in">ax</span>)=<span class="number">5</span></span><br><span class="line"><span class="keyword">adc</span> 执行时，相当于计算：(<span class="built_in">ax</span>)+<span class="number">3</span>+CF=<span class="number">2</span>+<span class="number">3</span>+<span class="number">0</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">98H</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">al</span>,<span class="number">3</span>     # 执行后，(<span class="built_in">ax</span>)=<span class="number">34H</span></span><br><span class="line"><span class="keyword">adc</span> 执行时，相当于计算：(<span class="built_in">ax</span>)+<span class="number">3</span>+CF=<span class="number">30H</span>+<span class="number">3</span>+<span class="number">1</span>=<span class="number">34H</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面的指令和 add ax,bx 具有相同的结果</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="keyword">adc</span> <span class="number">ah</span>,<span class="number">bh</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看来 CPU 提供 adc 指令的目的，就是来进行加法的第二步运算的。<br>&emsp;&emsp;adc 指令和 add 指令相配合就可以对更大的数据进行加法运算。</p>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/17.html">《Assembly Language 11.7 ~ 11.9 / 汇编语言 11.7 ~ 11.9》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>标志寄存器</tag>
        <tag>flag</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 11.7 ~ 11.9 / 汇编语言 11.7 ~ 11.9</title>
    <url>/Assembly-Language/17.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》11.7 ~ 11.9、《零基础入门学习汇编语言》P56 ~ 57</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/16.html">《Assembly Language 11.1 ~ 11.6 / 汇编语言 11.1 ~ 11.6》</a></p>
</div>

<span id="more"></span>

<p>&emsp;&emsp;编程计算 1EF000H+201000H，结果放在 ax（高 16 位）和 bx（低 16 位）中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001EH</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0F000H</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">0020H</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;adc 指令执行后，也可能产生进位值，所以也会对 CF 位进行设置。<br>&emsp;&emsp;由于有这样的功能，我们就可以对任意大的数据进行加法运算。<br>&emsp;&emsp;例如，编程计算 1EF0001000H+2010001EF0H，结果放在 ax（高 16 位）bx（次高 16 位）cx（低 16 位）中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001EH</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0F000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">cx</span>,<span class="number">1EF0H</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">adc</span> <span class="built_in">ax</span>,<span class="number">0020H</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面我们，编写一个子程序，对两个 128 位数据进行相加<br>&emsp;&emsp;参数：ds:si 指向存储第一个数的内存空间，因数据为 128 位，所以需要 8 个字单元，由低地址单元到高地址单元依次存放 128 位数据由低到高的各个字。运算结果存储在第一个数的存储空间中。<br>&emsp;&emsp;ds:di 指向存储第二个数的内存空间</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span>,<span class="number">88h</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,<span class="number">11h</span>,</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">call</span> add128</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">add128:</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="built_in">ax</span>     # 将 CF 设置为 <span class="number">0</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">si</span>]</span><br><span class="line">	<span class="keyword">adc</span> <span class="built_in">ax</span>,[<span class="built_in">di</span>]</span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;思考：inc 和 loop 指令不影响 CF 位，上面的程序中，能不能将 4 个 inc 指令，用</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span><span class="bash"> si,2</span></span><br><span class="line"><span class="keyword">add</span><span class="bash"> di,2</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;取代？答：不能，因为 add 会影响 CF 位。</p>
<h2 id="11-7-sbb-指令"><a href="#11-7-sbb-指令" class="headerlink" title="11.7 sbb 指令"></a>11.7 sbb 指令</h2><p>sbb 是带借位减法指令，它利用了 CF 位上记录的借位值。</p>
<ol>
<li>格式：sbb 操作对象 1,操作对象 2</li>
<li>功能：操作对象 1= 操作对象 1- 操作对象 2-CF</li>
<li>比如：sbb ax,bx</li>
<li>实现功能：(ax)=(ax)-(bx)-CF</li>
</ol>
<p>&emsp;&emsp;利用 sbb 指令我们可以对任意大的数据进行减法运算。<br>&emsp;&emsp;计算 003E1000H-00202000H，结果放在 ax，bx 中，程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">003EH</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="number">2000H</span></span><br><span class="line"><span class="keyword">sbb</span> <span class="built_in">ax</span>,<span class="number">0020H</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;sbb 和 adc 是基于同样的思想设计的两条指令，在应用思路上和 adc 类似。在这里，我们就不再进行过多的讨论。<br>&emsp;&emsp;通过学习这两条指令，我们可以进一步领会一下标志寄存器 CF 位的作用和意义。</p>
<h2 id="11-8-cmp-指令"><a href="#11-8-cmp-指令" class="headerlink" title="11.8 cmp 指令"></a>11.8 cmp 指令</h2><p>&emsp;&emsp;cmp 是比较指令，功能相当于减法指令，只是不保存结果。<br>&emsp;&emsp;cmp 指令执行后，将对标志寄存器产生影响。<br>&emsp;&emsp;其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</p>
<ol>
<li>格式：cmp 操作对象 1,操作对象 2</li>
<li>功能：计算操作对象 1- 操作对象 2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</li>
<li>比如：cmp ax,ax</li>
<li>做 (ax)-(ax) 的运算，结果为 0，但并不在 ax 中保存，仅影响 flag 的相关各位。</li>
</ol>
<p>&emsp;&emsp;指令执行后</p>
<ol>
<li>ZF=1</li>
<li>PF=1</li>
<li>SF=0</li>
<li>CF=0</li>
<li>OF=0</li>
</ol>
<p>&emsp;&emsp;下面的指令</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mov ax,8</span><br><span class="line">mov bx,3</span><br><span class="line">cmp ax,bx     # 执行后：(ax)=8</span><br><span class="line"><span class="attribute">ZF</span>=0</span><br><span class="line"><span class="attribute">PF</span>=1</span><br><span class="line"><span class="attribute">SF</span>=0</span><br><span class="line"><span class="attribute">CF</span>=0</span><br><span class="line"><span class="attribute">OF</span>=0</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其实，我们通过 cmp 指令执行后，相关标志位的值就可以看出比较的结果。<br>&emsp;&emsp;例如：cmp ax,bx</p>
<table>
<thead>
<tr>
<th>如果</th>
<th>则</th>
<th>所以</th>
</tr>
</thead>
<tbody><tr>
<td>(ax)=(bx)</td>
<td>(ax)-(bx)=0</td>
<td>ZF=1</td>
</tr>
<tr>
<td>(ax)≠(bx)</td>
<td>(ax)-(bx)≠0</td>
<td>ZF=0</td>
</tr>
<tr>
<td>(ax)＜(bx)</td>
<td>(ax)-(bx) 将产生借位</td>
<td>CF=1</td>
</tr>
<tr>
<td>(ax)≥(bx)</td>
<td>(ax)-(bx) 不必借位</td>
<td>CF=0</td>
</tr>
<tr>
<td>(ax)＞(bx)</td>
<td>(ax)-(bx) 既不必借位，结果又不为0</td>
<td>CF=0 且 ZF=0</td>
</tr>
<tr>
<td>(ax)≤(bx)</td>
<td>(ax)-(bx) 既可能借位，结果可能为 0</td>
<td>CF=1 或 ZF=1</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;现在我们可以看出比较指令的设计思路<br>&emsp;&emsp;即：通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果。<br>&emsp;&emsp;反过来看上面的例子 cmp ax,ax</p>
<table>
<thead>
<tr>
<th>如果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ZF=1</td>
<td>(ax)=(bx)</td>
</tr>
<tr>
<td>ZF=0</td>
<td>(ax)≠(bx)</td>
</tr>
<tr>
<td>CF=1</td>
<td>(ax)＜(bx)</td>
</tr>
<tr>
<td>CF=0</td>
<td>(ax)≥(bx)</td>
</tr>
<tr>
<td>CF=0 且 ZF=0</td>
<td>(ax)＞(bx)</td>
</tr>
<tr>
<td>CF=1 或 ZF=1</td>
<td>(ax)≤(bx)</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;同 add、sub 指令一样，CPU 在执行 cmp 指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。<br>&emsp;&emsp;所以利用 cmp 指令可以对无符号数进行比较，也可以对有符号数进行比较。<br>&emsp;&emsp;下面我们再来看一下如果用 cmp 来进行有符号数比较时，我们要注意哪些标志位！<br>&emsp;&emsp;我们以 cmp ah,bh 为例进行说明</p>
<table>
<thead>
<tr>
<th>如果</th>
<th>则</th>
<th>所以</th>
</tr>
</thead>
<tbody><tr>
<td>(ah)=(bh)</td>
<td>(ah)-(bh)=0</td>
<td>ZF=1</td>
</tr>
<tr>
<td>(ah)≠(bh)</td>
<td>(ah)-(bh)≠0</td>
<td>ZF=0</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;所以我们根据指令执行后 ZF 的值，就可以知道两个数据是否相等。<br>&emsp;&emsp;我们继续看，如果 (ah)＜(bh) 则可能发生什么情况呢？<br>&emsp;&emsp;对于有符号数运算，在 (ah)＜(bh) 情况下，(ah)-(bh) 显然可能引起 SF=1，即结果为负。<br>&emsp;&emsp;比如：(ah)=1，(bh)=2：则 (ah)-(bh)=0FFH，0FFH 为 -1 的补码，因为结果为负，所以 SF=1。<br>&emsp;&emsp;(ah)=0FEH，(bx)=0FFH：则 (ah)-(bh)=(-2)-(-1)=0FFH，因为结果为负，所以 SF=1。</p>
<div class="note danger"><p>cmp 操作对象 1, 操作对象 2 指令执行后，SF=1，<strong>不能</strong><del>说明 操作对象 1＜ 操作对象 2</del></p>
</div>

<p>&emsp;&emsp;(ah)=22H，(bh)=0A0H：则 (ah)-(bh)=34-(-96)=130=82H，82H 是 -126 的补码，所以 SF=1。<br>&emsp;&emsp;这里虽然 SF=1，但是并不能说明 (ah)＜(bh)，因为显然 34＞-96。<br>&emsp;&emsp;两个有符号数 A 和 B 相减，得到的是负数，那么可以肯定 A＜B，这个思路没有错误；<br>&emsp;&emsp;关键在于我们根据什么来断定得到的是一个负数。<br>&emsp;&emsp;CPU 将 cmp 指令得到的结果记录在 flag 的相关标志位中。<br>&emsp;&emsp;我们可以根据指令执行后，相关标志位的值来判断比较的结果。<br>&emsp;&emsp;单纯的考察 SF 的值不可能知道结果的正负。因为 SF 记录的只是可以在计算机中存放的相应位数的结果的正负。<br>&emsp;&emsp;比如 add ah,al 执行后，SF 记录的是 ah 中 8 位二进制信息所表示的数据的正负。<br>&emsp;&emsp;如果没有发生溢出的话，那么实际结果的正负和逻辑上真正的结果正负就一致了。<br>&emsp;&emsp;所以，我们应该在考察 SF（得知实际结果的正负）的同时考察 OF（得知有没有溢出）就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。<br>&emsp;&emsp;下面，我们以 cmp ah,bh 为例，总结一下 CPU 执行 cmp 结果后，SF 和 OF 的值是如何来说明比较的结果的。</p>
<ol>
<li>如果 SF=1，而 OF=0<ol>
<li>OF=0，说明没有溢出，逻辑上真正结果的正负 = 实际结果的正负</li>
<li>SF=1，实际结果为负，所以逻辑上真正的结果为负，所以 (ah)＜(bh)</li>
</ol>
</li>
<li>如果 SF=1，而 OF=1<ol>
<li>OF=1，说明有溢出，逻辑上真正结果的正负 ≠ 实际结果的正负</li>
<li>简单分析一下，就可以看出，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。这样，SF=1，OF=1，说明了 (ah)＞(bh)</li>
</ol>
</li>
<li>如果 SF=0，而 OF=1<ol>
<li>OF=1，说明有溢出，逻辑上真正结果的正负 ≠ 实际结果的正负</li>
<li>简单分析一下，就可以看出，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负，这样，SF=0，OF=1，说明了 (ah)＜(bh)</li>
</ol>
</li>
<li>如果 SF=0，而 OF=0<ol>
<li>OF=0，说明没有溢出，逻辑上真正结果的正负 = 实际结果的正负</li>
<li>因 SF=0，实际结果非负，所以逻辑上真正的结果必然非负。所以 (ah)≥(bh)</li>
</ol>
</li>
</ol>
<p>&emsp;&emsp;（博主将以上几点总结为表格形式如下表所示）</p>
<table>
<thead>
<tr>
<th>SF</th>
<th>说明</th>
<th>OF</th>
<th>说明</th>
<th>所以</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>结果非负</td>
<td>0</td>
<td>没有溢出，逻辑正负 = 实际正负</td>
<td>(ah)≥(bh)</td>
</tr>
<tr>
<td>0</td>
<td>结果非负</td>
<td>1</td>
<td>有溢出，逻辑正负 ≠ 实际正负</td>
<td>(ah)＜(bh)</td>
</tr>
<tr>
<td>1</td>
<td>实际为负</td>
<td>0</td>
<td>没有溢出，逻辑正负 = 实际正负</td>
<td>(ah)＜(bh)</td>
</tr>
<tr>
<td>1</td>
<td>实际为负</td>
<td>1</td>
<td>有溢出，逻辑正负 ≠ 实际正负</td>
<td>(ah)＞(bh)</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;上面，我们深入讨论了 cmp 指令在进行有符号数和无符号数比较时，对 flag 相关标志位的影响，和 CPU 如何通过相关的标志位来表示比较的结果。<br>&emsp;&emsp;在学习中，要注意领会 8086 CPU 这种工作机制的设计思想。实际上，这种设计思想对于各种处理机来说是普遍的。</p>
<h2 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h2><p>&emsp;&emsp;下面的内容中我们将学习一些根据 cmp 指令的比较结果（即，cmp 指令执行后，相关标志位的值）进行工作的指令。<br>&emsp;&emsp;它们检测的是哪些标志位呢？<br>&emsp;&emsp;就是被 cmp 指令影响的那些，表示比较结果的标志位。<br>&emsp;&emsp;这些条件转移指令通常都和 cmp 相配合使用，就好像 call 和 ret 指令通常相配合使用一样。<br>&emsp;&emsp;因为 cmp 指令可以同时进行两种比较，无符号数和有符号数比较，所以根据 cmp 指令的比较结果进行转移的指令也分为两种，即</p>
<ol>
<li>根据无符号数的比较结果进行转移的条件转移指令，它们检测 ZF、CF 的值</li>
<li>根据有符号数的比较结果进行转移的条件转移指令，它们检测 SF、OF 和 ZF 的值</li>
</ol>
<p>&emsp;&emsp;条件转移指令小结</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>ZF=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>ZF=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>CF=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>CF=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>CF=0，ZF=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>CF=1 或 ZF=1</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;这些指令比较常年用，它们都很好记忆，它们的第一个字母都是 j，表示 jump；后面的</p>
<ol>
<li>e：表示 equal</li>
<li>ne：表示 not equal</li>
<li>b：表示 below</li>
<li>nb：表示 not below</li>
<li>a：表示 above</li>
<li>na：表示 not above</li>
</ol>
<p>&emsp;&emsp;注意观察一下它们所检测的标志位，都是 cmp 指令进行无符号数比较时候，记录比较结果的标志位。<br>&emsp;&emsp;比如 je，检测 ZF 位，当 ZF=1 的时候进行转移，如果在 je 前面使用了 cmp 指令，那么 je 对 ZF 的检测，实际上就是间接地检测 cmp 的比较结果是否为两数相等。</p>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/18.html">《Assembly Language 11.9 ~ 11.11 / 汇编语言 11.9 ~ 11.11》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>adc</tag>
        <tag>sbb</tag>
        <tag>cmp</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 11.9 ~ 11.11 / 汇编语言 11.9 ~ 11.11</title>
    <url>/Assembly-Language/18.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》11.9 ~ 11.11、《零基础入门学习汇编语言》P58 ~ 59</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/17.html">《Assembly Language 11.7 ~ 11.9 / 汇编语言 11.7 ~ 11.9》</a></p>
</div>

<span id="more"></span>

<p>&emsp;&emsp;虽然 je 的逻辑含义是“相等则转移”，但它进行的操作是，ZF=1 时则转移。<br>&emsp;&emsp;“相等则转移”这种逻辑含义，是通过和 cmp 指令配合使用来体现的，因为是 cmp 指令为“ZF=1”赋予了“两数相等”的含义。<br>&emsp;&emsp;至于究竟在 je 之前使不使用 cmp 指令，在于我们的安排。<br>&emsp;&emsp;je 检测的是 ZF 位置，不管 je 前面是什么指令，只要 CPU 执行 je 指令时，ZF=1，那么就会发生转移。<br>&emsp;&emsp;比如</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">je</span> s</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">ax</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行后，(ax)=1。add ax,0 使得 ZF=1，所以 je 指令将进行转移。<br>&emsp;&emsp;可在这个时候发生的转移确不带有“相等则转移”的含义。因为此处的 je 指令检测到的 ZF=1，不是由 cmp 等比较指令设置的，而是由 add 指令设置的，并不具有“两数相等”的含义。<br>&emsp;&emsp;但无论“ZF=1”的含义如何，是什么指令设置的，只要是 ZF=1，就可以使得 je 指令发生转移。<br>&emsp;&emsp;CPU 提供了 cmp 指令，也提供了 je 等条件转移指令，如果将它们配合使用，可以实现根据比较结果进行转移的功能。<br>&emsp;&emsp;但这只是“如果”，只是一种合理的建议，和事实上常用的方法。<br>&emsp;&emsp;但究竟是否配合使用它们，完全是你自己的事情。<br>&emsp;&emsp;这就好像，call 和 ret 指令的关系一样。<br>&emsp;&emsp;对于 jne、jb、jnb、ja、jna 等指令和 cmp 指令配合使用的思想和 je 相同，可以自己分析一下。<br>&emsp;&emsp;我们来看一组程序：data 段中的 8 个字节如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db <span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">38</span></span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编程：统计 data 段中数值为 8 的字节的个数，用 ax 保存统计结果。<br>&emsp;&emsp;编程思路：初始设置 (ax)=0，然后用循环依次比较每个字节的值，找到一个和 8 相等的数就将 ax 的值加 1。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">38</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>     # <span class="built_in">ds</span>:<span class="built_in">bx</span> 执行第一个字节</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>     # 初始化累加器</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">8</span>     # 和 <span class="number">8</span> 进行比较</span><br><span class="line">	<span class="keyword">jne</span> next     # 如果不相等转到 next，继续循环</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">ax</span>     # 如果相等就将计数值加 <span class="number">1</span></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"># 第二种方案</span><br><span class="line"></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">38</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>     # <span class="built_in">ds</span>:<span class="built_in">bx</span> 指向第一个字节</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>     # 初始化累加器</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">8</span>     # 和 <span class="number">8</span> 进行比较</span><br><span class="line">	<span class="keyword">je</span> ok     # 如果相等就转到 ok，继续循环</span><br><span class="line">	<span class="keyword">jmp</span> short next     # 如果不相等就转到 next，继续循环</span><br><span class="line"><span class="symbol">ok:</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">ax</span>     # 如果相等就将计数值加 <span class="number">1</span></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">	loops</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">比起第一个程序，它直接的遵循了“等于 <span class="number">8</span> 则计数值加 <span class="number">1</span>”的原则，用 <span class="keyword">je</span> 指令检测等于 <span class="number">8</span>  的情况，但是没有第一个程序精简。</span><br><span class="line">第一个程序用 <span class="keyword">jne</span> 检测不等于 <span class="number">8</span> 的情况，从而间接地检测等于 <span class="number">8</span> 的情况。</span><br></pre></td></tr></table></figure>

<div class="note info"><p>注意：使用 cmp 和条件转移指令时的这种编程思想</p>
</div>

<p>&emsp;&emsp;编程：统计 data 段中数值大于 8 的字节的个数，用 ax 保存统计结果。<br>&emsp;&emsp;编程思路：初始设置 (ax)=0，然后用循环依次比较每个字节的值，找到一个大于 8 的数就将 ax 的值加 1。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">38</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>     # <span class="built_in">ds</span>:<span class="built_in">bx</span> 指向第一个字节</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>     # 初始化累加器</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">0</span>     # 和 <span class="number">8</span> 进行比较</span><br><span class="line">	<span class="keyword">jna</span> next     # 如果不大于 <span class="number">8</span> 转到 next，继续循环</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">ax</span>     # 如果大于 <span class="number">8</span> 就将计数值加 <span class="number">1</span></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">loop</span> s     # 程序执行后，(<span class="built_in">ax</span>)=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编程：统计 data 段中数值小于 8 的字节的个数，用 ax 保存统计结果。<br>&emsp;&emsp;编程思路：初始设置 (ax)=0，然后用循环依次比较每个字节的值，找到一个小于 8 的数就将 ax 的值加 1。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">38</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>     # <span class="built_in">ds</span>:<span class="built_in">bx</span> 指向第一个字节</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>     # 初始化累加器</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">8</span>     # 和 <span class="number">8</span> 进行比较</span><br><span class="line">	<span class="keyword">jnb</span> next     # 如果不小于 <span class="number">8</span> 转到 next，继续循环</span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">ax</span>     # 如果小于 <span class="number">8</span> 就将计数值加 <span class="number">1</span></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">loop</span> s     # 程序执行后：(<span class="built_in">ax</span>)=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面讲解了根据无符号数的比较结果进行转移的条件转移指令。<br>&emsp;&emsp;根据有符号数的比较结果进行转移的条件转移指令的工作原理和无符号数相同，只是检测了不同的标志位。<br>&emsp;&emsp;我们在这里主要探讨的是 cmp、标志寄存器的相关位、条件转移指令三者配合应用的原理，这个原理具有普遍性，而不是逐条讲解条件转移指令。</p>
<h2 id="11-10-DF-标志和串传送指令"><a href="#11-10-DF-标志和串传送指令" class="headerlink" title="11.10 DF 标志和串传送指令"></a>11.10 DF 标志和串传送指令</h2><p>&emsp;&emsp;flag 的第 10 位是 DF，方向标志位。<br>&emsp;&emsp;在串处理指令中，控制每次操作后 si、di 的增减</p>
<ol>
<li>DF=0：每次操作后 si、di 递增</li>
<li>DF=1：每次操作后 si、di 递减</li>
</ol>
<p>&emsp;&emsp;格式 1：movsb<br>&emsp;&emsp;功能（以<strong>字节</strong>为单位传送）：((es)×16+(di))=((ds)×16+(si))</p>
<ol>
<li>如果 DF=0 则<ol>
<li>(si)=(si)+1</li>
<li>(di)=(di)+1</li>
</ol>
</li>
<li>如果 DF=1 则<ol>
<li>(si)=(si)-1</li>
<li>(di)=(di)-1</li>
</ol>
</li>
</ol>
<p>&emsp;&emsp;movsb 的功能是将 ds:si 指向的内存单元中的字节送入 es:di 中，然后根据标志寄存器 DF 位的值，将 si 和 di 递增或递减。<br>&emsp;&emsp;当然，也可以传送一个字：movsw<br>&emsp;&emsp;格式 2：movsw<br>&emsp;&emsp;功能（以<strong>字</strong>为单位传送）：将 ds:si 指向的内存字单元中 word 送入 es:di 中，然后根据标志寄存器 DF 位的值，将 si 和 di 递增 2 或递减 2。<br>&emsp;&emsp;movsb 和 movsw 进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都和 rep 配合使用，格式如下：rep movsb<br>&emsp;&emsp;rep 的作用是根据 cx 的值，重复执行后面的串传送指令。<br>&emsp;&emsp;由于每执行一次 movsb 指令 si 和 di 都会递增或递减指向后一个单元或前个单元，则 rep movsb 就可以循环实现 (cx) 个字符的传送。<br>&emsp;&emsp;由于 flag 的 DF 位决定着串传送指令执行后，si 和 di 改变的方向，所以 CPU 应该提供相应的指令来对 DF 位进行设置，从而使程序员能够决定传送的方向。<br>&emsp;&emsp;8086 CPU 提供下面两条指令对 DF 位进行设置</p>
<ol>
<li>cld 指令：将标志寄存器的 DF 位置 0</li>
<li>std 指令：将标志寄存器的 DF 位置 1</li>
</ol>
<p>&emsp;&emsp;我们来看两个程序<br>&emsp;&emsp;编程 1：用串传送指令，将 data 段中的第一个字符串复制到它后面的空间中。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> segment</span></span><br><span class="line">	db &#x27;<span class="type">Welcome</span> to masm!&#x27;</span><br><span class="line">	db <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="class"><span class="keyword">data</span> ends</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息，它们是</p>
<ol>
<li>传送的原始位置：ds:si</li>
<li>传送的目的位置：es:di</li>
<li>传送的长度：cx</li>
<li>传送的方向：DF</li>
</ol>
<p>&emsp;&emsp;在这个问题中，这些信息如下</p>
<ol>
<li>传送的原始位置：data:0</li>
<li>传送的目的位置：data:16</li>
<li>传送的长度：16</li>
<li>传送的方向：因为正向传送（每次串传送指令执行后，si 和 di 递增）比较方便，所以设置 DF=0<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="string">&#x27;Welcome to masm!&#x27;</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span>     # <span class="built_in">ds</span>:<span class="built_in">si</span> 指向 data:<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span>     # <span class="built_in">es</span>:<span class="built_in">di</span> 指向 data:<span class="number">16</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">16</span>     # (<span class="built_in">cx</span>)=<span class="number">16</span>，<span class="keyword">rep</span> 循环 <span class="number">16</span> 次</span><br><span class="line"></span><br><span class="line">	<span class="keyword">cld</span>     #（clear df）小甲鱼猜测的含义</span><br><span class="line">	<span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;&emsp;编程 2：用串传送指令，将 F000H 段中的最后 16 个字符复制到 data 段中。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> segment</span></span><br><span class="line">	db <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line"><span class="class"><span class="keyword">data</span> ends</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们还是先来看一下应该为串传送指令提供什么样的信息：<br>&emsp;&emsp;要传送的字符串位于 F000H 段的最后 16 个单元中，那么它的最后一个字符的位置：F000:FFFF，是显而易见的。<br>&emsp;&emsp;我们可以将 ds:si 指向 F000H 段的最后一个单元，将 es:di 指向 data 段中的最后一个单元，然后逆向（即从高地址向低地址）传送 16 个字节即可。<br>&emsp;&emsp;相关信息如下</p>
<ol>
<li>传送的原始位置：F000:FFFF</li>
<li>传送的目的位置：data:15</li>
<li>传送的长度：16</li>
<li>传送的方向：因为逆向传送（每次串传送指令执行后，si 和 di 递减）比较方便，所以设置 DF=1<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0f000h</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0ffffh</span>     # <span class="built_in">ds</span>:<span class="built_in">si</span> 指向 f000:ffff</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">15</span>     # <span class="built_in">es</span>:<span class="built_in">di</span> 指向 data:<span class="number">15</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">16</span>     # (<span class="built_in">cx</span>)=<span class="number">16</span>，<span class="keyword">rep</span> 循环 <span class="number">16</span> 次</span><br><span class="line"></span><br><span class="line">	<span class="keyword">std</span>     # 设置 DF=<span class="number">1</span>，逆向传送</span><br><span class="line">	<span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="11-11-pushf-和-popf"><a href="#11-11-pushf-和-popf" class="headerlink" title="11.11 pushf 和 popf"></a>11.11 pushf 和 popf</h2><p>pushf：将标志寄存器的值压栈；<br>popf：从栈中弹出数据，送入标志寄存器中。<br>pushf 和 popf，为直接访问标志寄存器提供了一种方法。</p>
<div class="note success"><p>哦对了，顺便说一下：我们学习破解的同学，到这里应该可以算是功德圆满了。因为以后的内容是真正的 8086 汇编的内容，跟破解是无关的，大家可以到这里为止😃</p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>cmp</tag>
        <tag>条件转移指令</tag>
        <tag>DF</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 1.11 ~ 2.6 / 汇编语言 1.11 ~ 2.6</title>
    <url>/Assembly-Language/2.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》1.11 ~ 2.6、《零基础入门学习汇编语言》P5 ~ 8</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/1.html">《Assembly Language 1.1 ~ 1.10 / 汇编语言 1.1 ~ 1.10》</a></p>
</div>

<span id="more"></span>

<h2 id="1-11-内存地址空间（概述）"><a href="#1-11-内存地址空间（概述）" class="headerlink" title="1.11 内存地址空间（概述）"></a>1.11 内存地址空间（概述）</h2><p>&emsp;&emsp;一个 CPU 的地址线宽度为 10，那么可以寻址 1024 个内存单元，这 1024 个可寻到的内存单元就构成这个 CPU 的内存地址空间。</p>
<h2 id="1-13-接口卡"><a href="#1-13-接口卡" class="headerlink" title="1.13 接口卡"></a>1.13 接口卡</h2><p>&emsp;&emsp;CPU 对外部设备不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。</p>
<h2 id="1-14-各类存储器芯片"><a href="#1-14-各类存储器芯片" class="headerlink" title="1.14 各类存储器芯片"></a>1.14 各类存储器芯片</h2><ol>
<li>从读写属性上分两类<ol>
<li>随机存储器（RAM）</li>
<li>只读存储器（ROM）</li>
</ol>
</li>
<li>从功能和连接上分类<ol>
<li>随机存储器 RAM</li>
<li>装有 BIOS 的 ROM</li>
<li>接口卡上的 RAM</li>
</ol>
</li>
</ol>
<h2 id="1-15-内存地址空间"><a href="#1-15-内存地址空间" class="headerlink" title="1.15 内存地址空间"></a>1.15 内存地址空间</h2><p>&emsp;&emsp;最终运行程序的是 CPU，我们用汇编编程的时候，<strong>必须要从 CPU 角度考虑问题</strong>（学习汇编的核心思维）。</p>
<h1 id="第二章-寄存器（CPU工作原理）"><a href="#第二章-寄存器（CPU工作原理）" class="headerlink" title="第二章 寄存器（CPU工作原理）"></a>第二章 寄存器（CPU工作原理）</h1><p>&emsp;&emsp;一个典型的 CPU 由<strong>运算器、控制器、寄存器</strong>等器件组成，这些器件靠内部总线相连。<br>&emsp;&emsp;8086 CPU 有 14 个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PWS。</p>
<h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>&emsp;&emsp;8086 CPU 所有的寄存器都是 16 位的，可以存放两个字节。<br>&emsp;&emsp;AX、BX、CX、DX 通常用来存放一般性数据被称为通用寄存器。<br>&emsp;&emsp;一个 16 位寄存器所能存储的数据的最大值为 $2^{16}-1$<br>&emsp;&emsp;8086 上一代 CPU 中的寄存器都是 8 位的，所以为保证兼容性，这四个寄存器都可以分为两个独立的 8 位寄存器使用：AX 可以分为 AH 和 AL；BX 可以分为 BH 和 BL，以此类推。</p>
<h2 id="2-2-字在寄存器中的存储"><a href="#2-2-字在寄存器中的存储" class="headerlink" title="2.2 字在寄存器中的存储"></a>2.2 字在寄存器中的存储</h2><p>&emsp;&emsp;一个字可以存在一个 16 位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高 8 位寄存器和低 8 位寄存器中。</p>
<h2 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h2><div class="note info"><p>汇编指令不区分大小写</p>
</div>

<table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制 CPU 完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,18</td>
<td>将 18 送入 AX</td>
<td>AH = 18</td>
</tr>
<tr>
<td>mov ah,78</td>
<td>将 78 送入 AH</td>
<td>AH = 78</td>
</tr>
<tr>
<td>add ax,8</td>
<td>将寄存器 AX 中的数值加上 8</td>
<td>AX = AX + 8</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将寄存器 BX 中的数据送入寄存器 AX</td>
<td>AX = BX</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将 AX，BX 中的内容相加，结果存在 AX 中</td>
<td>AX = AX + BX</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;CPU 执行下表中的程序段的每条指令后，对寄存器中的数据进行的改变。</p>
<p>问1：原 AX 中的值：0000H，原 BX 中的值：0000H）</p>
<table>
<thead>
<tr>
<th>程序段中的指令</th>
<th>指令执行后 AX 中的数据</th>
<th>指令执行后 BX 中的数据</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,4E20H</td>
<td>4E20H</td>
<td>0000H</td>
</tr>
<tr>
<td>add ax,1406H</td>
<td>6226H</td>
<td>0000H</td>
</tr>
<tr>
<td>mov bx,2000H</td>
<td>6226H</td>
<td>2000H</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>8226H</td>
<td>2000H</td>
</tr>
<tr>
<td>mov bx,ax</td>
<td>8226H</td>
<td>8226H</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>?</td>
<td>8226H</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;答案：044CH（原本 8226H+8226H=<strong>1</strong>044CH，但是 ax 只放得下两个字所以是 044CH）</p>
<p>问2：原 AX 中的值：0040H</p>
<table>
<thead>
<tr>
<th>程序段中的指令</th>
<th>指令执行后 AX 中的数据</th>
</tr>
</thead>
<tbody><tr>
<td>add al,85H</td>
<td>00C5H</td>
</tr>
<tr>
<td>add al,93H</td>
<td>?</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;答案：0058H（因为 add 的地方是 al 八位寄存器，所以原本属于 ax 高位 ah 的 01 进位值会被丢失。这里的丢失，指的是进位值不能在 8 位寄存器中保存，但是 CPU 并不是真的丢弃这个进位值）</p>
<h2 id="2-4-物理地址"><a href="#2-4-物理地址" class="headerlink" title="2.4 物理地址"></a>2.4 物理地址</h2><p>&emsp;&emsp;CPU 访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，这个唯一的地址称为物理地址。</p>
<h2 id="2-5-16-位结构的-CPU"><a href="#2-5-16-位结构的-CPU" class="headerlink" title="2.5 16 位结构的 CPU"></a>2.5 16 位结构的 CPU</h2><p>&emsp;&emsp;概括的讲，16 位结构描述了一个 CPU 具有以下几个方面特征</p>
<ol>
<li>运算器一次最多可以处理 16 位的数据。</li>
<li>寄存器的最大宽度为 16 位。</li>
<li>寄存器和运算器之间的通路是 16 位的。</li>
</ol>
<h2 id="2-6-8086-CPU-给出物理地址的方法"><a href="#2-6-8086-CPU-给出物理地址的方法" class="headerlink" title="2.6 8086 CPU 给出物理地址的方法"></a>2.6 8086 CPU 给出物理地址的方法</h2><p>&emsp;&emsp;8086 有 20 位地址总线，可传送 20 位地址，寻址能力为 1M（ $2^{20}=1MB$ ）<br>&emsp;&emsp;8086 内部为 16 位结构，它只能传送 16 位的地址，表现出的寻址能力就只有64K（ $2^{16}=64KB$ ）<br>&emsp;&emsp;8086 CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址<br>&emsp;&emsp;地址加法器合成物理地址的方法：物理地址 = 段地址 × 16 + 偏移地址<br>&emsp;&emsp;“段地址 × 16”有一个更为常用的说法就是数据左移 4 位（二进制位）。</p>
<table>
<thead>
<tr>
<th>移位位数</th>
<th>二进制</th>
<th>十六进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>10B</td>
<td>2H</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>100B</td>
<td>4H</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>1000B</td>
<td>8H</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>10000B</td>
<td>10H</td>
<td>16</td>
</tr>
<tr>
<td>4</td>
<td>100000B</td>
<td>20H</td>
<td>32</td>
</tr>
</tbody></table>
<ol>
<li>通过观察上表（移位次数和各种形式数据的关系）得出<ol>
<li>一个数据的二进制形式左移 1 位，相当于该数据乘以 2；</li>
<li>一个数据的二进制形式左移 N 位，相当于该数据乘以 $2^N$</li>
<li>地址加法器完成段地址 × 16 的运算即以二进制形式存放的段地址左移 4 位。</li>
</ol>
</li>
<li>进一步思考可得<ol>
<li>一个数据的十六进制形式左移 1 位，相当于乘以 16；</li>
<li>一个数据的十进制形式左移 1 位，相当于乘以 10；</li>
<li>一个数据的 X 进制形式左移 1 位，相当于乘以 X。</li>
</ol>
</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/3.html">《Assembly Language 2.8 ~ 2.12 / 汇编语言 2.8 ~ 2.12》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
        <tag>运算器</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 2.8 ~ 2.12 / 汇编语言 2.8 ~ 2.12</title>
    <url>/Assembly-Language/3.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》2.8 ~ 2.12、《零基础入门学习汇编语言》P9、10</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/2.html">《Assembly Language 1.11 ~ 2.6 / 汇编语言 1.11 ~ 2.6》</a></p>
</div>

<span id="more"></span>

<h2 id="2-8-段的概念"><a href="#2-8-段的概念" class="headerlink" title="2.8 段的概念"></a>2.8 段的概念</h2><p>&emsp;&emsp;错误认识：<del>内存被划分成了一个一个的段，每一个段有一个段地址。</del><br>&emsp;&emsp;其实：内存并没有分段，段的划分来自于 CPU，由于 8086 CPU 用“（段地址×16）+ 偏移地址 = 物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。<br>&emsp;&emsp;段地址×16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数；<br>&emsp;&emsp;偏移地址为 16 位，16 位地址的寻址能力为 64K，所以一个段的长度最大为 64K。<br>&emsp;&emsp;CPU 访问内存单元时，必须向内存提供内存单元的物理地址。<br>&emsp;&emsp;8086 CPU 在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。</p>
<table>
<thead>
<tr>
<th align="center">物理地址</th>
<th align="center">段地址</th>
<th align="center">偏移地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">21F60H</td>
<td align="center">2000H</td>
<td align="center">1F60H</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">2100H</td>
<td align="center">0F60H</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">21F0H</td>
<td align="center">0F60H</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">21F6H</td>
<td align="center">0000H</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">1F00H</td>
<td align="center">2F60H</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;上表可得：CPU 可以用不同的段地址和偏移地址形成同一个物理地址。<br>&emsp;&emsp;给定一个段地址，仅通过变化偏移地址来进行寻址，最多可以定位 64K 个内存单元（偏移地址 16 位，变化范围为 0 ~ FFFFH），比如：给定段地址 1000H，用偏移地址寻址，CPU 的寻址范围为：10000H ~ 1FFFFH。</p>
<h2 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h2><ol>
<li>在 8086 PC 机中，存储单元的地址用两个元素来描述。即段地址和偏移地址。</li>
<li>“数据在 21F60H 内存单元中。”对于 8086 PC 机的两种描述<ol>
<li>数据存在内存 2000:1F60 单元中；</li>
<li>数据存在内存的 2000 段中的 1F60H 单元中。</li>
</ol>
</li>
<li>可根据需要，将地址连续、起始地址为 16 的倍数的一组内存单元定义为一个段。</li>
</ol>
<h2 id="2-9-段寄存器"><a href="#2-9-段寄存器" class="headerlink" title="2.9 段寄存器"></a>2.9 段寄存器</h2><p>&emsp;&emsp;段寄存器就是提供段地址的。<br>&emsp;&emsp;8086 CPU 有 4 个段寄存器</p>
<ol>
<li>CS（Code Segment）代码段寄存器</li>
<li>DS（Data Segment）数据段寄存器</li>
<li>SS（Stack Segment）堆栈段寄存器</li>
<li>ES（Extra Segment）附加段寄存器</li>
</ol>
<p>&emsp;&emsp;当 8086 CPU 要访问内存时，由这 4 个段寄存器提供内存单元的段地址。</p>
<h2 id="2-10-CS-和-IP"><a href="#2-10-CS-和-IP" class="headerlink" title="2.10 CS 和 IP"></a>2.10 CS 和 IP</h2><p>&emsp;&emsp;CS 和 IP 是 8086 CPU 中最关键的寄存器，它们指示了 CPU 当前要读取指令的地址。<br>&emsp;&emsp;CS 为代码段寄存器，IP 为指令指针寄存器。<br>&emsp;&emsp;8086 PC 工作过程的简要描述</p>
<ol>
<li>工作流程<ol>
<li>从 CS:IP 指向内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP = IP + 所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。转到步骤 1，重复这个过程。</li>
</ol>
</li>
<li>在 8086 CPU 加电启动或复位后（即 CPU 刚开始工作时）CS 和 IP 被设置为 CS=FFFFH，IP=0000H。即在 8086 PC 机刚启动时，CPU 从内存 FFFF0H 单元中读取指令执行。FFFF0H 单元中的指令是 8086 PC 机开启后执行的第一条指令。</li>
</ol>
<p>&emsp;&emsp;在任何时候，CPU 将 CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。<br>&emsp;&emsp;如果说，内存中的一段信息曾被 CPU 执行过的话，那么，它所在的内存单元必然被 CS:IP 指向过。<br>&emsp;&emsp;在 CPU 中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对 CPU 的控制。<br>&emsp;&emsp;CPU 从何处执行指令是由 CS、IP 中的内容决定的，程序员可以通过改变 CS、IP 中的内容来控制 CPU 执行目标指令。</p>
<h2 id="2-11-修改-CS、IP-的指令"><a href="#2-11-修改-CS、IP-的指令" class="headerlink" title="2.11 修改 CS、IP 的指令"></a>2.11 修改 CS、IP 的指令</h2><p>&emsp;&emsp;如：mov ax,123，mov 指令可以改变 8086 CPU 大部分寄存器的值，被称为传送指令。</p>
<div class="note warning"><p>mov 指令（传送指令）不能用于设置 CS、IP 的值</p>
</div>

<p>&emsp;&emsp;同时修改 CS、IP 的内容：jmp 段地址:偏移地址，功能：用指令中给出的段地址修改 CS，偏移地址修改 IP。</p>
<table>
<thead>
<tr>
<th>转移指令</th>
<th>物理地址</th>
</tr>
</thead>
<tbody><tr>
<td>jmp 2AE3:3</td>
<td>2AE33H</td>
</tr>
<tr>
<td>jmp 3:0B16</td>
<td>00B46H（=0003×10+0B16）</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;仅修改 IP 的内容：jmp 某一合法寄存器，如：jmp ax（<strong>类似于</strong> mov IP,ax），功能：用寄存器中的值修改 IP。</p>
<h2 id="2-12-代码段"><a href="#2-12-代码段" class="headerlink" title="2.12 代码段"></a>2.12 代码段</h2><p>&emsp;&emsp;对于 8086 PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。<br>&emsp;&emsp;可以将长度为 N（N≤64KB）的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。<br>&emsp;&emsp;将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。</p>
<div class="note warning"><p>CPU 只认被 CS:IP 指向的内存单元中的内容为指令。</p>
</div>

<p>&emsp;&emsp;所以要将 CS:IP 指向所定义的代码段中的第一条指令的首地址。</p>
<h2 id="2-12-小结"><a href="#2-12-小结" class="headerlink" title="2.12 小结"></a>2.12 小结</h2><ol>
<li>段地址在 8086 CPU 的寄存器中存放。当 8086 CPU 要访问内存时，由段寄存器提供内存单元的段地址。8086 CPU 有 4 个段寄存器，其中 CS 用来存放指令的段地址。</li>
<li>CS 存放指令的段地址，IP 存放指令的偏移地址。</li>
<li>8086 机中，任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。</li>
<li>8086 CPU 的工作过程<ol>
<li>从 CS:IP 指向内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP 指向下一条指令；</li>
<li>执行指令。（转到步骤 1，重复这个过程。）</li>
</ol>
</li>
<li>8086 CPU 提供转移指令修改 CS、IP 的内容。</li>
</ol>
<h2 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h2><p>&emsp;&emsp;R 命令查看、改变 CPU 寄存器的内容；<br>&emsp;&emsp;D 命令查看内存中的内容；<br>&emsp;&emsp;E 命令改写内存中的内容；<br>&emsp;&emsp;U 命令将内存中的机器指令翻译成汇编指令；<br>&emsp;&emsp;T 命令执行一条机器指令；<br>&emsp;&emsp;A 命令以汇编指令的格式在内存中写入一条机器指令。</p>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/4.html">《Assembly Language 3.1 ~ 3.5 / 汇编语言 3.1 ~ 3.5》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>IP</tag>
        <tag>传送指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 4.1 ~ 4.9 / 汇编语言 4.1 ~ 4.9</title>
    <url>/Assembly-Language/6.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》4.1 ~ 4.9、《零基础入门学习汇编语言》P20 ~ 22</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/5.html">《Assembly Language 3.6 ~ 3.10 / 汇编语言 3.6 ~ 3.10》</a></p>
</div>

<span id="more"></span>

<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h2><h3 id="4-2-1-定义一个段"><a href="#4-2-1-定义一个段" class="headerlink" title="4.2.1 定义一个段"></a>4.2.1 定义一个段</h3><p>&emsp;&emsp;segment 和 ends 是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。<br>&emsp;&emsp;segment 和 ends 的功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。<br>&emsp;&emsp;一个段必须有一个名称来标识，使用格式为</p>
<ol>
<li>段名 segment</li>
<li>段名 ends</li>
</ol>
<p>&emsp;&emsp;End 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。<br>&emsp;&emsp;如果程序写完了，要在结尾处加上伪指令 end。否则，编译器在编译程序时，无法知道程序在何处结束。</p>
<div class="note warning"><p>注意 end 和 ends 的区别。ends 只是段的结束，而 end 是整个程序的结束。</p>
</div>

<p>&emsp;&emsp;assume：含义为“假设”。<br>&emsp;&emsp;它假设假设某一段寄存器和程序中的某一个用 segment…ends 定义的段相关联。通过 assume 说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</p>
<table>
<thead>
<tr>
<th>目的</th>
<th>相关指令</th>
<th>指令性质</th>
<th>指令执行者</th>
</tr>
</thead>
<tbody><tr>
<td>通知编译器一个段结束</td>
<td>段名 ends</td>
<td>伪指令</td>
<td>编译时，由编译器执行</td>
</tr>
<tr>
<td>通知编译器程序结束</td>
<td>end</td>
<td>伪指令</td>
<td>编译时，由编译器执行</td>
</tr>
<tr>
<td>程序返回</td>
<td>mov ax,4c00H    int 21H</td>
<td>汇编指令</td>
<td>编译时，由 CPU 执行</td>
</tr>
</tbody></table>
<h3 id="4-2-2-标号"><a href="#4-2-2-标号" class="headerlink" title="4.2.2 标号"></a>4.2.2 标号</h3><p>&emsp;&emsp;一个标号指代了一个地址。<br>&emsp;&emsp;放在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>程序加载后，ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0，则程序所在的内存区的地址为：ds:0；</li>
<li>这个内存区的前 256 个字节中存放的是 PSP，dos 用来和程序进行通信。</li>
<li>从 256 字节处向后的空间存放的是程序。<ol>
<li>所以，我们从 ds 中可以得到 PSP 的段地址 SA，PSP 的偏移地址为 0，则物理地址为 SA×16+0。</li>
<li>因为 PSP 占 256（100H）字节，所以程序的物理地址是：SA×16+0+256=SA×16+16×16=（SA+16）×16+0</li>
<li>可用段地址和偏移地址表示为：SA+10:0。</li>
</ol>
</li>
</ol>
<h2 id="4-9-程序执行过程的跟踪"><a href="#4-9-程序执行过程的跟踪" class="headerlink" title="4.9 程序执行过程的跟踪"></a>4.9 程序执行过程的跟踪</h2><ol>
<li>debug 命令使用<ol>
<li>用 U 命令查看一下其他指令</li>
<li>用 T 命令单步执行程序中的每一条指令，并观察每条指令的执行结果</li>
<li>到了 Int 21，我们要用 P 命令执行。int 21 执行后，显示“Program terminated normally”，返回到 Debug 中。</li>
</ol>
</li>
<li>DOS 程序执行过程<ol>
<li>需要注意的是，在 DOS 中运行程序时，是 command 将程序加载入内存；</li>
<li>所以程序运行结束后返回到 command 中，而在这里是 debug 将程序加载入内存，所以程序运行结束后要返回到 Debug 中。</li>
<li>使用 Q 命令退出 Debug，将返回到 command 中，因为 Debug 是由 command 加载运行的。</li>
</ol>
</li>
<li>DOS 程序执行过程举例<ol>
<li>我们在 DOS 中用“Debug 1.exe”运行 Debug 对 1.exe 进行跟踪时，程序加载的顺序是：command 加载 Debug，Debug 加载 1.exe。</li>
<li>返回的顺序是：从 1.exe 中的程序返回到 Debug，从 Debug 返回到 command。</li>
</ol>
</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/7.html">《Assembly Language 5.1 ~ 5.4 / 汇编语言 5.1 ~ 5.4》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>段</tag>
        <tag>标号</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 3.6 ~ 3.10 / 汇编语言 3.6 ~ 3.10</title>
    <url>/Assembly-Language/5.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》3.6 ~ 3.10、《零基础入门学习汇编语言》P16 ~ 19</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/4.html">《Assembly Language 3.1 ~ 3.5 / 汇编语言 3.1 ~ 3.5》</a></p>
</div>

<span id="more"></span>

<h2 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h2><p>&emsp;&emsp;栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，<strong>最后</strong>进入这个空间的数据，<strong>最先</strong>出去。<br>&emsp;&emsp;栈有两个基本的操作：入栈和出栈。</p>
<ol>
<li>入栈：将一个新的元素放到栈顶</li>
<li>出栈：从栈顶取出一个元素</li>
</ol>
<p>&emsp;&emsp;栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。<br>&emsp;&emsp;栈的操作规则：LIFO（Last In First Out，后进先出）</p>
<h2 id="3-7-CPU-提供的栈机制"><a href="#3-7-CPU-提供的栈机制" class="headerlink" title="3.7 CPU 提供的栈机制"></a>3.7 CPU 提供的栈机制</h2><p>&emsp;&emsp;8086 CPU 提供相关的指令来以栈的方式访问内存空间。<br>&emsp;&emsp;我们在基于 8086 CPU 编程的时候，可以将一段内存当作栈来使用。<br>&emsp;&emsp;8086 CPU 提供入栈和出栈指令（最基本的）：PUSH（入栈）、POP（出栈）</p>
<ol>
<li>push ax：将寄存器 ax 中的数据送入栈中；</li>
<li>pop ax：从栈顶取出数据送入 ax。</li>
</ol>
<p>&emsp;&emsp;8086 CPU 的入栈和出栈操作都是以<strong>字</strong>为单位进行的。<br>&emsp;&emsp;字型数据用两个单元存放，高地址单元放高 8 位，低地址单元放低 8 位。<br>&emsp;&emsp;8086 CPU 中，有两个寄存器</p>
<ol>
<li>段寄存器 SS：存放栈顶的段地址</li>
<li>寄存器 SP：存放栈顶的偏移地址</li>
</ol>
<p>&emsp;&emsp;任意时刻，SS:SP 指向栈顶元素。<br>&emsp;&emsp;push ax</p>
<ol>
<li>SP=SP-2</li>
<li>将 ax 中的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新栈顶。</li>
</ol>
<p>&emsp;&emsp;我们将 10000H~1000FH 这段空间当作栈段，SS=1000H，栈空间大小为 16 字节，栈最底部的字单元地址为 1000:000E。<br>&emsp;&emsp;任意时刻，SS:SP 指向栈顶，当栈中只有一个元素的时候，SS=1000H，SP=000EH。<br>&emsp;&emsp;栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2，SP 原来为 000EH，加 2 后 SP=10H。所以，当栈为空的时候，SS=1000H，SP=10H。<br>&emsp;&emsp;pop ax</p>
<ol>
<li>将 SS:SP 指向的内存单元处的数据送入 ax 中；</li>
<li>SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ol>
<h2 id="3-9-push、pop-指令"><a href="#3-9-push、pop-指令" class="headerlink" title="3.9 push、pop 指令"></a>3.9 push、pop 指令</h2><p>&emsp;&emsp;push 和 pop 指令的格式</p>
<ol>
<li>针对寄存器<ol>
<li>push 寄存器：将一个寄存器中的数据入栈</li>
<li>pop 寄存器：出栈，用一个寄存器接受出栈的数据</li>
</ol>
</li>
<li>针对段寄存器<ol>
<li>push 段寄存器：将一个段寄存器中的数据入栈，如：push ds</li>
<li>pop 段寄存器：出栈，用一个段寄存器接收出栈的数据，如：pop es</li>
</ol>
</li>
<li>针对内存单元<ol>
<li>push 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）</li>
<li>pop 内存单元：出栈，用一个内存字单元接收出栈的数据</li>
<li>指令执行时，CPU 要知道内存单元的地址，可以在 push、pop 指令中给出内存单元的偏移地址，段地址在指令执行时，CPU 从 ds 中取得。</li>
</ol>
</li>
</ol>
<div class="note warning"><p>push 和 pop 指令还要改变 SP 中的内容：push 是<strong>先</strong> SP=SP-2，pop 是<strong>后</strong> SP=SP+2。push 和 pop 指令同 mov 指令不同，CPU 执行 mov 指令只需一步操作，就是传送，而执行 push、pop 指令却需要两步操作。</p>
</div>

<p>&emsp;&emsp;push、pop 等栈操作指令，修改的只是 SP。栈顶的变化范围最大为：0~FFFFH</p>
<h2 id="栈的综述"><a href="#栈的综述" class="headerlink" title="栈的综述"></a>栈的综述</h2><ol>
<li>在 SS、SP 中存放栈顶的段地址和偏移地址；提供入栈和出栈指令，他们根据 SS:SP 指示的地址，按照栈的方式访问内存单元。</li>
<li>push 指令的执行步骤<ol>
<li>SP=SP-2</li>
<li>向 SS:SP 指向的字单元中送入数据</li>
</ol>
</li>
<li>pop 指令的执行步骤<ol>
<li>从 SS:SP 指向的字单元中读取数据</li>
<li>SP=SP+2</li>
</ol>
</li>
<li>任意时刻，SS:SP 指向栈顶元素。</li>
<li>8086 CPU 只记录栈顶，栈空间的大小我们要自己管理。</li>
</ol>
<h2 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h2><p>&emsp;&emsp;我们将 10000H~1FFFFH 这段空间当作栈段，SS=1000H，栈空间大小为 64KB，栈最底部字单元地址为 1000:FFFE。任意时刻，SS:SP 指向栈顶，当栈中只有一个元素的时候，SS=1000H，SP=FFFEH。<br>&emsp;&emsp;栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2。SP 原来为 FFFEH，加 2 后 SP=0，所以，当栈为空的时候，SS=1000H，SP=0。<br>&emsp;&emsp;一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。</p>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/6.html">《Assembly Language 4.9 ~ 4.9 / 汇编语言 4.1 ~ 4.9》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>栈段</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 3.1 ~ 3.5 / 汇编语言 3.1 ~ 3.5</title>
    <url>/Assembly-Language/4.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》3.1 ~ 3.5、《零基础入门学习汇编语言》P13 ~ 15</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/3.html">《Assembly Language 2.8 ~ 2.12 / 汇编语言 2.8 ~ 2.12》</a></p>
</div>

<span id="more"></span>

<h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h2><p>&emsp;&emsp;任何两个地址连续的内存单元，N 号单元和 N+1 号单元，可以将它们看成两个内存单元，也可以看成一个地址为 N 的子单元中的高位字节单元和低位字节单元。</p>
<h2 id="3-2-DS-和-address"><a href="#3-2-DS-和-address" class="headerlink" title="3.2 DS 和 address"></a>3.2 DS 和 address</h2><p>&emsp;&emsp;CPU 要读取一个内存单元的时候，必须先给出这个内存单元的地址；<br>&emsp;&emsp;在 8086 PC 中，内存地址由段地址和偏移地址组成。<br>&emsp;&emsp;8086 CPU 中有一个 DS 寄存器，通常用来存放要访问的数据的段地址。<br>&emsp;&emsp;已知的 mov 指令可完成的两种传送功能</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span>     # 将数据直接送入寄存器；</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>     # 将一个寄存器中的内容送入另一个寄存器中</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;除此之外，mov 指令还可以将一个内存单元中的内容送入一个寄存器。<br>&emsp;&emsp;例如：我们要读取 10000H 单元的内容可以用如下程序段进行</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="number">0</span>]     # <span class="keyword">mov</span> 指令的格式：<span class="keyword">mov</span> 寄存器名,内存单元地址，“[…]”表示一个内存单元，“[…]”中的 <span class="number">0</span> 表示内存单元的偏移地址</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面三条指令将 10000H（1000:0）中的数据读到 al 中。<br>&emsp;&emsp;执行指令时，8086 CPU 自动取 DS 中的数据为内存的单元的段地址。<br>&emsp;&emsp;用 mov 指令从 1000H 中读取数据</p>
<ol>
<li>10000H 表示为 1000:0（段地址:偏移地址）</li>
<li>将段地址 1000H 放入 ds</li>
<li>用 mov al,[0] 完成传送（mov 指令中的 [] 说明操作对象是一个内存单元，[] 中的 0 说明这个内存单元的偏移地址是 0，它的段地址默认放在 ds 中）</li>
</ol>
<p>&emsp;&emsp;8086 CPU <strong>不支持</strong><del>将数据直接送入段寄存器</del>的操作，ds 是一个段寄存器。（硬件设计问题）</p>
<div class="note warning"><p>数据 → 通用寄存器 → 段寄存器，<strong>不能</strong><del>直接将数据送入段寄存器</del></p>
</div>

<p>&emsp;&emsp;将数据从寄存器送入内存单元</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="number">0</span>],<span class="built_in">al</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3 字的传送"></a>3.3 字的传送</h2><p>&emsp;&emsp;因为 8086 CPU 是 16 位结构，有 16 根数据线，所以可以一次性传送 16 位的数据，也就是一次性传送一个字。</p>
<h2 id="3-4-mov、add、sub-指令"><a href="#3-4-mov、add、sub-指令" class="headerlink" title="3.4 mov、add、sub 指令"></a>3.4 mov、add、sub 指令</h2><p>&emsp;&emsp;已学 mov 指令的几种形式</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">6</span>     # <span class="keyword">mov</span> 寄存器,数据</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>     # <span class="keyword">mov</span> 寄存器,寄存器</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="number">0</span>]     # <span class="keyword">mov</span> 寄存器,内存单元</span><br><span class="line"><span class="keyword">mov</span> [<span class="number">0</span>],<span class="built_in">ax</span>     # <span class="keyword">mov</span> 内存单元,寄存器</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>     # <span class="keyword">mov</span> 段寄存器,寄存器</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">ds</span>     # <span class="keyword">mov</span> 寄存器,段寄存器</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;add 和 sub 指令同 mov 一样，都有两个操作对象</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">8</span>     # <span class="keyword">add</span> 寄存器,数据</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>     # <span class="keyword">add</span> 寄存器,寄存器</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,[<span class="number">0</span>]     # <span class="keyword">add</span> 寄存器,内存单元</span><br><span class="line"><span class="keyword">add</span> [<span class="number">0</span>],<span class="built_in">ax</span>     # <span class="keyword">add</span> 内存单元,寄存器</span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="number">9</span>     # <span class="keyword">sub</span> 寄存器,数据</span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>     # <span class="keyword">sub</span> 寄存器,寄存器</span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">ax</span>,[<span class="number">0</span>]     # <span class="keyword">sub</span> 寄存器,内存单元</span><br><span class="line"><span class="keyword">sub</span> [<span class="number">0</span>],<span class="built_in">ax</span>     # <span class="keyword">sub</span> 内存单元,寄存器</span><br></pre></td></tr></table></figure>

<h2 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h2><p>&emsp;&emsp;将一段内存当作数据段，是我们在编程时的一种安排，我们可以在具体操作的时候，用 ds 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。<br>&emsp;&emsp;我们将 123B0H~123BAH 的内存单元定义为数据段，我们现在要累加这个数据段中的前 3 个单元中的数据，代码如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">123BH</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>     # 将 <span class="number">123BH</span> 送入 <span class="built_in">ds</span> 中，作为数据段的段地址。</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span>     # 用 <span class="built_in">al</span> 存放累加结果</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,[<span class="number">0</span>]     # 将数据段第一个单元（偏移地址为 <span class="number">0</span>）中的数值加到 <span class="built_in">al</span> 中</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,[<span class="number">1</span>]     # 将数据段第二个单元（偏移地址为 <span class="number">1</span>）中的数值加到 <span class="built_in">al</span> 中</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,[<span class="number">2</span>]     # 将数据段第三个单元（偏移地址为 <span class="number">2</span>）中的数值加到 <span class="built_in">al</span> 中</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;累加数据段中的前 3 个字型数据</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">123BH</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>     # 将 <span class="number">123BH</span> 送入 <span class="built_in">ds</span> 中，作为数据段的段地址。</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>     # 用 <span class="built_in">ax</span> 存放累加结果</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,[<span class="number">0</span>]     # 将数据段第一个字（偏移地址为<span class="number">0</span>）加到 <span class="built_in">ax</span> 中</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,[<span class="number">2</span>]     # 将数据段第二个字（偏移地址为<span class="number">2</span>）加到 <span class="built_in">ax</span> 中</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,[<span class="number">4</span>]     # 将数据段第三个字（偏移地址为<span class="number">4</span>）加到 <span class="built_in">ax</span> 中</span><br></pre></td></tr></table></figure>

<div class="note info"><p>一个字型数据占两个单元，所以偏移地址是 0、2、4。</p>
</div>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</li>
<li>用 mov 指令要访问内存单元，可以在 mov 指令中只给出单元的偏移地址，此时，段地址默认在 DS 寄存器中。</li>
<li>[address] 表示一个偏移地址为 address 的内存单元。</li>
<li>在内存和寄存器之间传送字型数据时，高地址单元和高 8 位寄存器、低地址单元和低 8 位寄存器相对应。</li>
<li>mov、add、sub 是具有两个操作对象的指令。jum 是具有一个操作对象的指令。</li>
<li>可以根据自己的推测，在 Debug 中实验指令的新格式。</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/5.html">《Assembly Language 3.6 ~ 3.10 / 汇编语言 3.6 ~ 3.10》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
        <tag>mov</tag>
        <tag>add</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 5.1 ~ 5.4 / 汇编语言 5.1 ~ 5.4</title>
    <url>/Assembly-Language/7.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》5.1 ~ 5.4、《零基础入门学习汇编语言》P23 ~ 26</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/6.html">《Assembly Language 4.1 ~ 4.9 / 汇编语言 4.1 ~ 4.9》</a></p>
</div>

<span id="more"></span>

<h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h2 id="5-1-bx"><a href="#5-1-bx" class="headerlink" title="5.1 [bx]"></a>5.1 [bx]</h2><p>&emsp;&emsp;mov ax,[bx]：bx 中存放的数据作为一个偏移地址 EA，段地址 SA 默认在 ds 中，将 SA:EA 处的数据送入 ax 中。即：(ax)=((ds)×16+(bx))；<br>&emsp;&emsp;反之 mov [bx],ax 即为将 ax 中的数据送入内存 SA:EA 处。即：((ds)×16+(bx))=(ax)</p>
<h2 id="问题-5-1"><a href="#问题-5-1" class="headerlink" title="问题 5.1"></a>问题 5.1</h2><table>
<thead>
<tr>
<th>汇编指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,2000H</td>
<td>(ax)=2000H（为确认数据段地址）</td>
</tr>
<tr>
<td>mov ds,ax</td>
<td>(ds)=2000H</td>
</tr>
<tr>
<td>mov bx,1000H</td>
<td>(bx)=1000H</td>
</tr>
<tr>
<td>mov ax,[bx]</td>
<td>(ax)=(2000:1000)</td>
</tr>
<tr>
<td>inc bx</td>
<td>(bx)=(bx)+1</td>
</tr>
<tr>
<td>inc bx</td>
<td>(bx)=(bx)+1</td>
</tr>
<tr>
<td>mov [bx],ax</td>
<td>(2000:1002)=(ax)</td>
</tr>
<tr>
<td>inc bx</td>
<td>(bx)=(bx)+1</td>
</tr>
<tr>
<td>inc bx</td>
<td>(bx)=(bx)+1</td>
</tr>
<tr>
<td>mov [bx],ax</td>
<td>(2000:1004)=(ax)</td>
</tr>
<tr>
<td>inc bx</td>
<td>(bx)=(bx)+1</td>
</tr>
<tr>
<td>mov [bx],al</td>
<td>(2000:1005)=(al)</td>
</tr>
<tr>
<td>inc bx</td>
<td>(bx)=(bx)+1</td>
</tr>
<tr>
<td>mov [bx],al</td>
<td>(2000:1006)=(al)</td>
</tr>
</tbody></table>
<h2 id="5-2-Loop-指令"><a href="#5-2-Loop-指令" class="headerlink" title="5.2 Loop 指令"></a>5.2 Loop 指令</h2><p>&emsp;&emsp;指令的格式是：loop 标号，CPU 执行 loop 指令的时候，要进行两步操作</p>
<ol>
<li>(cx)=(cx)-1</li>
<li>判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li>
</ol>
<p>&emsp;&emsp;标号决定了循环开始的位置<br>&emsp;&emsp;在 cx 中存放循环次数（bx 存放内存偏移地址）；<br>&emsp;&emsp;loop 指令中的标号所标识地址要在前面；<br>&emsp;&emsp;要循环执行的程序段，要写在标号和 loop 指令的中间。<br>&emsp;&emsp;用 cs 和 loop 指令相配合实现循环功能的程序框架如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mov</span> <span class="string">cx,循环次数</span></span><br><span class="line"><span class="attr">s</span>:<span class="string"></span></span><br><span class="line"><span class="attr">循环执行的程序段</span></span><br><span class="line"><span class="attr">loop</span> <span class="string">s</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-在-Debug-中跟踪用-loop-指令实现的循环程序"><a href="#5-3-在-Debug-中跟踪用-loop-指令实现的循环程序" class="headerlink" title="5.3 在 Debug 中跟踪用 loop 指令实现的循环程序"></a>5.3 在 Debug 中跟踪用 loop 指令实现的循环程序</h2><div class="note warning"><p>在汇编源程序中，数据不能<del>以字母开头</del>！需要在前面加 0</p>
</div>

<p>&emsp;&emsp;用 G 命令或 P 命令直接执行完循环。</p>
<h2 id="5-4-Debug-和汇编编译器-Masm-对指令的不同处理"><a href="#5-4-Debug-和汇编编译器-Masm-对指令的不同处理" class="headerlink" title="5.4 Debug 和汇编编译器 Masm 对指令的不同处理"></a>5.4 Debug 和汇编编译器 Masm 对指令的不同处理</h2><p>&emsp;&emsp;将 ds:0 处的数据送入 al 中</p>
<table>
<thead>
<tr>
<th>指令位置</th>
<th>指令</th>
<th>执行效果</th>
</tr>
</thead>
<tbody><tr>
<td>Debug</td>
<td>mov al,[0]</td>
<td>mov al,[0]</td>
</tr>
<tr>
<td>汇编源程序</td>
<td>mov al,[0]</td>
<td>mov al,<strong>0</strong></td>
</tr>
</tbody></table>
<p>&emsp;&emsp;由上表可知，在汇编源程序中，指令“mov ax,[0]”被编译器当作指令“mov ax,0”处理。如果要实现“mov ax,[0]”，需要通过 bx 来代替</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bx</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;或也可以加上段地址</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>汇编源程序指令</th>
<th>MASM编译结果</th>
</tr>
</thead>
<tbody><tr>
<td>mov al,[0]</td>
<td>(al)=0</td>
</tr>
<tr>
<td>mov al,ds:[0]</td>
<td>(al)=(ds:0)</td>
</tr>
<tr>
<td>mov al,[bx]</td>
<td>同上</td>
</tr>
<tr>
<td>mov al,ds:[bx]</td>
<td>同上</td>
</tr>
</tbody></table>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/8.html">《Assembly Language 6.1 ~ 6.3 / 汇编语言 6.1 ~ 6.3》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>loop</tag>
        <tag>cx</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 6.1 ~ 6.3 / 汇编语言 6.1 ~ 6.3</title>
    <url>/Assembly-Language/8.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》6.1 ~ 6.3、《零基础入门学习汇编语言》P29 ~ 31</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/7.html">《Assembly Language 5.1 ~ 5.4 / 汇编语言 5.1 ~ 5.4》</a></p>
</div>

<span id="more"></span>

<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><h2 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a>6.1 在代码段中使用数据</h2><p>&emsp;&emsp;dw 即 define word，用来定义字型数据，数据之间以逗号分隔<br>&emsp;&emsp;end 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</p>
<h2 id="实验-5-编写、调试具有多个段的程序"><a href="#实验-5-编写、调试具有多个段的程序" class="headerlink" title="实验 5 编写、调试具有多个段的程序"></a>实验 5 编写、调试具有多个段的程序</h2><p>&emsp;&emsp;看一个程序要从<strong>代码段</strong>开始看，数据段存放的数据没有意义，数据段中的数据是否被使用取决于代码段。<br>&emsp;&emsp;代码段从 end 后的标号开始，end 后的标号是哪里，哪里就是开始。</p>
<h3 id="（5）程序如下，编写-code-段中的代码，将-a-段和-b-段中的数据依次相加，将结果存到-c-段中。"><a href="#（5）程序如下，编写-code-段中的代码，将-a-段和-b-段中的数据依次相加，将结果存到-c-段中。" class="headerlink" title="（5）程序如下，编写 code 段中的代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。"></a>（5）程序如下，编写 code 段中的代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">	db <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">a ends</span><br><span class="line">b segment</span><br><span class="line">	db <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b ends</span><br><span class="line">c segment</span><br><span class="line">	db <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">c ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	?</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong>博主</strong>的思路是（不是权威，也不一定是最好，<strong>仅仅只是</strong>博主的思路，不足之处还请指出）</p>
<ol>
<li>db 定义了 8 个字节型数据，一个 8086 CPU 的通用寄存器是 16 位的，只能存放 2 个字节，所以想简单的利用 add dx,ax 此类操作直接运算肯定不行</li>
<li>所以此处必定需要循环来完成。循环的思路确定了，那么要循环几次呢？即 (cx)=？</li>
<li>循环的目的是将两段的 8 个字节依次相加，而一个通用寄存器的容量是 2 个字节，所以我们可以将 8 个字节的数据，分 4 次循环来相加。（也可以简单的就分 8 次循环相加，这里是考虑<strong>最高效原则</strong>）</li>
<li>(cx)=4 也确定了，那需要哪些元素（寄存器）来参与呢？我们需要先把 a segment 的数据放入一个段中，所以 ds 数据段寄存器肯定是要加入的</li>
<li>有段寄存器 ds，那也就少不了 bx 用来放偏移地址、ax 充当 ds 的媒介，用来告诉 ds 段寄存器的段地址</li>
<li>那么既然 ax 不能用了，bx 放偏移地址了，cx 用来告诉循环要几次了，要相加的数据放在哪里呢？</li>
<li>所以我们暂时借来 dx 用来存放及相加数据。<strong>注意</strong> dx 一定得初始化为 0，好让它干干净净的存放要相加的数据</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,a</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">dx</span>,[<span class="built_in">bx</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,b</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">dx</span>,[<span class="built_in">bx</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,c</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）程序如下，编写-code-段中的代码，用-push-指令将-a-段中的前-8-个字型数据，逆序存储到-b-段中。"><a href="#（6）程序如下，编写-code-段中的代码，用-push-指令将-a-段中的前-8-个字型数据，逆序存储到-b-段中。" class="headerlink" title="（6）程序如下，编写 code 段中的代码，用 push 指令将 a 段中的前 8 个字型数据，逆序存储到 b 段中。"></a>（6）程序如下，编写 code 段中的代码，用 push 指令将 a 段中的前 8 个字型数据，逆序存储到 b 段中。</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">	dw <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>ah,<span class="number">0</span>bh,<span class="number">0</span>ch,<span class="number">0</span>dh,<span class="number">0</span>eh,<span class="number">0f</span>h,<span class="number">0f</span>fh</span><br><span class="line">a ends</span><br><span class="line">b segment</span><br><span class="line">	dw <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">b ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	?</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong>博主</strong>的思路是（不是权威，也不一定是最好，<strong>仅仅只是</strong>博主的思路，不足之处还请指出）</p>
<ol>
<li>此题与上题的区别在于这一次定义的是 dw 字型数据，所以前 8 个字型数据相加，就不能省略为 4 次循环，还是老老实实需要 8 次循环，即 (cx)=8</li>
<li>题目要求用 push，所以必定需要引入栈段的思想，而前 8 位字型数据，占用 16 位的空间，故 ss 栈段指针需要指向第 17 位，即 (sp)=10h（栈段第一位从 0 开始）</li>
<li>把 a 段 push 进 b 段，所以 b segment 做栈段，a segment 做数据段</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,a</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,a</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,b</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">10h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line">	<span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure>

<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/9.html">《Assembly Language 7.1 ~ 7.10 / 汇编语言 7.1 ~ 7.10》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>Program</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly Language 7.1 ~ 7.10 / 汇编语言 7.1 ~ 7.10</title>
    <url>/Assembly-Language/9.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是基于王爽老师所著《汇编语言（第3版）》的小甲鱼的《零基础入门学习汇编语言》课程笔记。<br>&emsp;&emsp;笔记涵盖内容为《汇编语言（第3版）》7.1 ~ 7.10、《零基础入门学习汇编语言》P32 ~ 35</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Assembly-Language/8.html">《Assembly Language 6.1 ~ 6.3 / 汇编语言 6.1 ~ 6.3》</a></p>
</div>

<span id="more"></span>

<h1 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h1><h2 id="7-1-and-和-or-指令"><a href="#7-1-and-和-or-指令" class="headerlink" title="7.1 and 和 or 指令"></a>7.1 and 和 or 指令</h2><h3 id="7-1-1-and-指令"><a href="#7-1-1-and-指令" class="headerlink" title="7.1.1 and 指令"></a>7.1.1 and 指令</h3><p>&emsp;&emsp;逻辑与指令，按位进行<strong>与</strong>运算</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">-</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">01100011B</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00111011B</span></span><br><span class="line"><span class="built_in">al</span>=<span class="number">00100011B</span>     # 执行后</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;and 指令的使用技巧：通过该指令可将操作对象的相应位设为 0，其他位不变。<br>&emsp;&emsp;例如</p>
<ol>
<li>将 al 的第 6 位设为 0：and al,10111111B</li>
<li>将 al 的第 7 位设为 0：and al,01111111B</li>
<li>将 al 的第 0 位设为 0：and al,11111110B</li>
</ol>
<h3 id="7-1-2-or-指令"><a href="#7-1-2-or-指令" class="headerlink" title="7.1.2 or 指令"></a>7.1.2 or 指令</h3><p>&emsp;&emsp;逻辑或指令，按位进行或运算</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">-</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">01100011B</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">00111011B</span></span><br><span class="line"><span class="built_in">al</span>=<span class="number">01111011B</span>     # 执行后</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;or 指令的功能：通过该指令可将操作对象的相应位设为 1，其他位不变<br>例如：</p>
<ol>
<li>将 al 的第 6 位设为 1：or al,01000000B</li>
<li>将 al 的第 7 位设为 1：or al,10000000B</li>
<li>将 al 的第 0 位设为 1：or al,00000001B</li>
</ol>
<h2 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a>7.3 以字符形式给出的数据</h2><p>&emsp;&emsp;我们可以在汇编程序中，用’……’的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的 ASCII 码。</p>
<h2 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h2><p>&emsp;&emsp;在十进制 ASCII 码表上，小写字母比大写字母大 32（20H），例如小写 a 是 61H，大写 A 是 41H<br>&emsp;&emsp;一个字母，不管原来是大写还是小写</p>
<ol>
<li>我们将它的第 5 位置 0，它就必须将变为大写字母；</li>
<li>将它的第 5 位置 1，它就必须变为小写字母。</li>
</ol>
<h3 id="大小写字母转换"><a href="#大小写字母转换" class="headerlink" title="大小写字母转换"></a>大小写字母转换</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">&#x27;BaSiC&#x27;</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">&#x27;iNfOrMaTiOn&#x27;</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>     # 设置 <span class="built_in">ds</span> 指向 datasg 段</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>     # 设置 (<span class="built_in">bx</span>)=<span class="number">0</span>，<span class="built_in">ds</span>:<span class="built_in">bx</span> 指向“BaSiC”的第一个字母</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">5</span>     # 设置循环次数 <span class="number">5</span>，因为“BaSiC”有 <span class="number">5</span> 个字母</span><br><span class="line"><span class="symbol">	s:</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]     # 将 ASCII 码从 <span class="built_in">ds</span>:<span class="built_in">bx</span> 所指向的单元中取出</span><br><span class="line">		<span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span>     # 将 <span class="built_in">al</span> 中的 ASCII 码的第 <span class="number">5</span> 位置为 <span class="number">0</span>，变为大写字母</span><br><span class="line">		<span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">al</span>     # 将转变后的 ASCII 码写回原单元</span><br><span class="line">		<span class="keyword">inc</span> <span class="built_in">bx</span>     # (<span class="built_in">bx</span>)加 <span class="number">1</span>，<span class="built_in">ds</span>:<span class="built_in">bx</span> 指向下一个字母</span><br><span class="line">	<span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">5</span>     # 设置 (<span class="built_in">bx</span>)=<span class="number">5</span>，<span class="built_in">ds</span>:<span class="built_in">bx</span> 指向“iNfOrMaTiOn”的第一个字母</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">11</span>     # 设置循环次数 <span class="number">11</span>，因为“iNfOrMaTiOn”有 <span class="number">11</span> 个字母</span><br><span class="line"><span class="symbol">	s0:</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]</span><br><span class="line">		<span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">00100000b</span>     # 将 <span class="built_in">al</span> 中的 ASCII 码的第 <span class="number">5</span> 位置为 <span class="number">0</span>，变为小写字母</span><br><span class="line">		<span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">		<span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">loop</span> s0</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h2><p>&emsp;&emsp;[bx+idata] 表示一个内存单元，它的偏移地址为 (bx)+idata（bx 中的数值加上 idata）。<br>&emsp;&emsp;指令 mov ax,[bx+200] 可写成如下格式</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="number">200</span>+<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">200</span>[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bx</span>].<span class="number">200</span></span><br></pre></td></tr></table></figure>

<h2 id="7-7-SI-和-DI"><a href="#7-7-SI-和-DI" class="headerlink" title="7.7 SI 和 DI"></a>7.7 SI 和 DI</h2><p>&emsp;&emsp;SI 和 DI 是 8086 CPU 中和 bx 功能相近的寄存器，但是 SI 和 DI <strong>不能够</strong>分成两个 8 位寄存器来使用。<br>&emsp;&emsp;下面每两行的指令实现了相同的功能</p>
<table>
<thead>
<tr>
<th>指令一</th>
<th>指令二</th>
<th>指令三</th>
</tr>
</thead>
<tbody><tr>
<td>mov bx,0</td>
<td>mov si,0</td>
<td>mov di,0</td>
</tr>
<tr>
<td>mov ax,[bx]</td>
<td>mov ax,[si]</td>
<td>mov ax,[di]</td>
</tr>
<tr>
<td>————</td>
<td>————</td>
<td>————</td>
</tr>
<tr>
<td>mov bx,0</td>
<td>mov si,0</td>
<td>mov di,0</td>
</tr>
<tr>
<td>mov ax,[bx+123]</td>
<td>mov ax,[si+123]</td>
<td>mov ax,[di+123]</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;用 ds:si 指向要复制的原始字符串，用 ds:di 指向复制的目的空间，然后用一个循环来完成复制。<br>&emsp;&emsp;注意利用 [bx（si 或 di）+idata] 的方式，来使程序变得更简洁。例如将固定长度的一段字符串，复制到另一段空间，就可以用相对偏移地址的方式，少引用一个偏移地址寄存器。</p>
<h2 id="7-10-不同的寻址方式的灵活应用"><a href="#7-10-不同的寻址方式的灵活应用" class="headerlink" title="7.10 不同的寻址方式的灵活应用"></a>7.10 不同的寻址方式的灵活应用</h2><p>&emsp;&emsp;共有以下几种寻址方式</p>
<ol>
<li>[data] 用要给常量来表示地址，可用于直接定位一个内存单元；</li>
<li>[bx] 用一个变量来表示内存地址，可用于间接定位一个内存单元；</li>
<li>[bx+idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；</li>
<li>[bx+si] 用两个变量表示地址；</li>
<li>[bx+si+idata] 用两个变量和一个常量表示地址。</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Assembly-Language/10.html">《Assembly Language 8.1 / 汇编语言 8.1》</a></p>
</div>]]></content>
      <categories>
        <category>Assembly Language</category>
      </categories>
      <tags>
        <tag>寻址方式</tag>
        <tag>and</tag>
        <tag>or</tag>
      </tags>
  </entry>
  <entry>
    <title>BT &amp; Trojan（在宝塔上制作酸酸乳）</title>
    <url>/IT/4.html</url>
    <content><![CDATA[<p>&emsp;&emsp;是不是觉得花了好多美元买的境外服务器，只放一个 Trojan 太过浪费？想要将境外服务器利用起来？<br>&emsp;&emsp;那你就来对了，本文就介绍了如何在安装了宝塔的服务器上，再搭建一个 Trojan。<br>&emsp;&emsp;让你在能酣畅淋漓满世界转悠的时候，还能建个站玩玩，充分利用服务器资源。</p>
<span id="more"></span>

<p>&emsp;&emsp;博主有幸成功申请到了 Oracle 的两台永久免费的服务器，但苦于服务器位于日本，建站以后国内访问速度感人。想要建几个站学习，但又买不起境内的服务器，所以只能“出此下策”：将宝塔与 Trojan 相结合，达到既能利用服务器建站，又能充分利用服务器资源。</p>
<div class="note primary"><p>本文需要 Trojan 使用经验，若未曾搭建过 Trojan，请先学习：<a href="https://blog.hackme.cc/IT/3.html">《Build Trojan（制作“保质期长的”酸酸乳）》</a>。</p>
</div>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="一台服务器"><a href="#一台服务器" class="headerlink" title="一台服务器"></a>一台服务器</h2><p>&emsp;&emsp;建议选择与博主一样的系统版本进行搭建：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> <strong>Centos 7</strong> x86_64 bbr</p>
<div class="note warning"><p>友情提示：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> 可能需要先翻墙才可访问！</p>
</div>

<h2 id="一个域名"><a href="#一个域名" class="headerlink" title="一个域名"></a>一个域名</h2><p>&emsp;&emsp;任意纯英文域名皆可。域名类型与系统搭建无关，建议使用纯英文域名。博主多年使用感受，推荐在 <span class="exturl" data-url="aHR0cHM6Ly93YW53YW5nLmFsaXl1bi5jb20vZG9tYWluLz9zb3VyY2U9NTE3Ni4xMTUzMzQ1NyZ1c2VyQ29kZT1lenB3OXNpaCZ0eXBlPWNvcHk=">阿里云域名注册<i class="fa fa-external-link-alt"></i></span> 注册域名，并使用免费的 <span class="exturl" data-url="aHR0cHM6Ly93YW53YW5nLmFsaXl1bi5jb20vZG9tYWluL2Rucz9zb3VyY2U9NTE3Ni4xMTUzMzQ1NyZ1c2VyQ29kZT1lenB3OXNpaCZ0eXBlPWNvcHk=">阿里云解析<i class="fa fa-external-link-alt"></i></span> 对域名进行解析。另外有其它建站需求的朋友，可点击 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9taW5pc2l0ZS9nb29kcz91c2VyQ29kZT1lenB3OXNpaA==">阿里云·云小站<i class="fa fa-external-link-alt"></i></span> 领取优惠券。</p>
<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>&emsp;&emsp;将你的域名解析至你的服务器，即添加<strong>主域名</strong> A 记录指向服务器 IP（只需添加 @ 的主域名解析就行，无须添加 www 等的二级域名解析）</p>
<h1 id="服务器端操作"><a href="#服务器端操作" class="headerlink" title="服务器端操作"></a>服务器端操作</h1><h2 id="安装宝塔"><a href="#安装宝塔" class="headerlink" title="安装宝塔"></a>安装宝塔</h2><p>&emsp;&emsp;建议安装最新版宝塔，故请移步 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnQuY24vP2ludml0ZV9jb2RlPU1WOWhiWFJxYjIwPQ==">宝塔官网<i class="fa fa-external-link-alt"></i></span>，获取安装链接及使用教程。</p>
<h2 id="安装-Trojan"><a href="#安装-Trojan" class="headerlink" title="安装 Trojan"></a>安装 Trojan</h2><h3 id="搭建网站"><a href="#搭建网站" class="headerlink" title="搭建网站"></a>搭建网站</h3><p>&emsp;&emsp;登录宝塔，用刚刚解析至服务器的域名搭建一个网站。</p>
<h3 id="申请-SSL-证书"><a href="#申请-SSL-证书" class="headerlink" title="申请 SSL 证书"></a>申请 SSL 证书</h3><p>&emsp;&emsp;通过 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L2Nhcz9zb3VyY2U9NTE3Ni4xMTUzMzQ1NyZ1c2VyQ29kZT1lenB3OXNpaCZ0eXBlPWNvcHk=">阿里云云盾证书<i class="fa fa-external-link-alt"></i></span>，申请 SSL 证书，并绑定至宝塔的站点。</p>
<div class="note warning"><p>绑定了 SSL 证书后，要在宝塔面板关闭 SSL！否则可能导致 Trojan 无法正常使用！</p>
</div>

<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>&emsp;&emsp;在服务器运行如下脚本</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -fsSL https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/trojan-gfw/</span>trojan-quickstart<span class="regexp">/master/</span>trojan-quickstart.sh)</span><br></pre></td></tr></table></figure>

<h2 id="配置服务器端-Trojan"><a href="#配置服务器端-Trojan" class="headerlink" title="配置服务器端 Trojan"></a>配置服务器端 Trojan</h2><p>&emsp;&emsp;安装完 Trojan 后，进行配置</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>trojan/config.json</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;修改密码及域名信息如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;run_type&quot;</span>: <span class="string">&quot;server&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_addr&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">&quot;remote_addr&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;remote_port&quot;</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;**自定义密码**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;**自定义密码**&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;log_level&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;ssl&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cert&quot;</span>: <span class="string">&quot;/www/server/panel/vhost/ssl/**你的域名**/fullchain.pem&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;/www/server/panel/vhost/ssl/**你的域名**/privkey.pem&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;key_password&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cipher&quot;</span>: <span class="string">&quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cipher_tls13&quot;</span>: <span class="string">&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;prefer_server_cipher&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;alpn&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;http/1.1&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;alpn_port_override&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;h2&quot;</span>: <span class="number">81</span></span><br></pre></td></tr></table></figure>

<h2 id="Trojan-服务"><a href="#Trojan-服务" class="headerlink" title="Trojan 服务"></a>Trojan 服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart trojan     <span class="comment"># 重启 Trojan 服务</span></span><br><span class="line">systemctl status trojan     <span class="comment"># 查看 Trojan 服务状态</span></span><br><span class="line">systemctl <span class="built_in">enable</span> trojan     <span class="comment"># 设置开机自启</span></span><br></pre></td></tr></table></figure>

<h1 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h1><h2 id="修改本地-Trojan-配置"><a href="#修改本地-Trojan-配置" class="headerlink" title="修改本地 Trojan 配置"></a>修改本地 Trojan 配置</h2><p>&emsp;&emsp;搭建过 Trojan 的朋友应该不难发现（还没搭建过 Trojan 或者没有本地工具的请先学习：<a href="https://blog.hackme.cc/IT/3.html">《Build Trojan（制作“保质期长的”酸酸乳）》</a>），本地 Trojan 工具包里的 “config.json” 就是 Trojan 的配置文件，我们修改了服务器上的 Trojan 配置，当然还要同步修改本地的 Trojan 配置。打开“config.json”，按如下修改</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;run_type&quot;</span>: <span class="string">&quot;client&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_addr&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">&quot;remote_addr&quot;</span>: <span class="string">&quot;**你的域名**&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;remote_port&quot;</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;**自定义密码**&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;log_level&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;ssl&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;verify&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;verify_hostname&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;cert&quot;</span>: <span class="string">&quot;fullchain.cer&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cipher_tls13&quot;</span>:<span class="string">&quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;</span>,</span><br><span class="line"><span class="attr">&quot;sni&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alpn&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;h2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;http/1.1&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;reuse_session&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;session_ticket&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;curves&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tcp&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;no_delay&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;keep_alive&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;fast_open_qlen&quot;</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改-fullchain-cer"><a href="#修改-fullchain-cer" class="headerlink" title="修改 fullchain.cer"></a>修改 fullchain.cer</h2><p>&emsp;&emsp;还记得我们一开始在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L2Nhcz9zb3VyY2U9NTE3Ni4xMTUzMzQ1NyZ1c2VyQ29kZT1lenB3OXNpaCZ0eXBlPWNvcHk=">阿里云云盾证书<i class="fa fa-external-link-alt"></i></span> 申请的 SSL 证书吗？将“.pem”文件更名为“fullchain.cer”，并替换 Trojan 工具中的“fullchain.cer”。就大功告成啦！</p>
<div class="note success"><p>Success! Start enjoying BT &amp; Trojan！</p>
</div>

<div class="note warning"><p>经过博主多次实践，nginx 的 SSL 会和 Trojan 相冲突，所以如果要使用 Trojan，还想正常搭建网站，就不能开启 SSL 功能。所有的网站都不能加 SSL！</p>
</div>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>宝塔</tag>
        <tag>Trojan</tag>
      </tags>
  </entry>
  <entry>
    <title>Build SSR（制作酸酸乳）</title>
    <url>/IT/1.html</url>
    <content><![CDATA[<p>Hello everyone! We are Chinese! We may not be the pride of China. But we are proud that we are Chinese! 作为一个中国人，一个爱好信息安全的中国人，我们理应携起手来，一致对外。首先一点，我们需要一条可以“放眼看世界”的通道。所以本博文就以最简单的方式来教大家最便捷的“制作酸酸乳”的方法（“酸酸乳”一词对应“ShadowSocksR”的简称“SSR”的拼音）</p>
<span id="more"></span>

<div class="note danger"><p>用 SSR 现已频繁被封，建议采用更为高级加密防封的 Trojan，制作教程：<a href="https://blog.hackme.cc/IT/3.html">《Build Trojan（制作“保质期长的”酸酸乳）》</a></p>
</div>

<blockquote>
<p>&emsp;&emsp;Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言、Rust等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。<br>&emsp;&emsp;为了避免关键词过滤，网民会根据谐音将ShadowsocksR称为“酸酸乳”（SSR），将Shadowsocks称为“酸酸”（SS）。另外Shadowsocks的标志为纸飞机，而专门提供Shadowsocks或类似软件（如V2ray）服务器的网站也被称为“机场”。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——<em>摘自 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU2hhZG93c29ja3M=">《维基百科》Shadowsocks 词条<i class="fa fa-external-link-alt"></i></span></em></p>
</blockquote>
<p>&emsp;&emsp;本文主要记录搭建SSR时的代码，在此之前的准备工作，例如购买境外VPS等，百度有许多教程，本文不再赘述。博主在尝试了几家较为有名的美国服务器商后，最后决定使用 <span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> ，如有需要可点击 <span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">此链接<i class="fa fa-external-link-alt"></i></span> 进行注册并购买VPS。</p>
<div class="note warning"><p>友情提示：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> 可能需要先翻墙才可访问！</p>
</div>

<h1 id="确认服务器系统版本"><a href="#确认服务器系统版本" class="headerlink" title="确认服务器系统版本"></a>确认服务器系统版本</h1><div class="note primary"><p>本文适用系统版本为：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> <strong>Centos 7</strong> x86_64 bbr</p>
</div>

<p>&emsp;&emsp;建议选择与博主一样的系统版本进行搭建，因为此教程可能不兼容其他系统版本，选用其他版本可能会造成搭建失败。（“bbr”是用于给网络加速的）</p>
<h1 id="安装-Wget"><a href="#安装-Wget" class="headerlink" title="安装 Wget"></a>安装 Wget</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> wget</span><br></pre></td></tr></table></figure>

<h1 id="下载-SSR-Shell-安装脚本并执行"><a href="#下载-SSR-Shell-安装脚本并执行" class="headerlink" title="下载 SSR Shell 安装脚本并执行"></a>下载 SSR Shell 安装脚本并执行</h1><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/ToyoDAdoubi/</span>doubi<span class="regexp">/master/</span>ssr.sh &amp;&amp; chmod <span class="number">755</span> .<span class="regexp">/ssr.sh &amp;&amp; ./</span>ssr.sh</span><br></pre></td></tr></table></figure>

<div class="note info"><p>根据提示进行安装并配置，设置端口、密码、加密协议等等，此处不做详解。</p>
</div>

<h1 id="SSR-配置及日常维护"><a href="#SSR-配置及日常维护" class="headerlink" title="SSR 配置及日常维护"></a>SSR 配置及日常维护</h1><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./ssr.sh</span></span><br></pre></td></tr></table></figure>

<div class="note success"><p>Success! Start enjoying SSR!</p>
</div>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>SSR</tag>
        <tag>ShadowSocksR</tag>
        <tag>酸酸乳</tag>
      </tags>
  </entry>
  <entry>
    <title>Build Taobao Coupon Website / 搭建淘宝领券网</title>
    <url>/IT/2.html</url>
    <content><![CDATA[<p>&emsp;&emsp;蜗居在贫民窟里的孩子，生活日用品就是最大的开销了。有时一些价格较为昂贵的“家用电器”突然损坏，就会让这个本就不富裕的家庭，雪上加霜……所以博主一般会在各个平台搜索“淘宝优惠券”，以此来减轻一个男人背上的重担。于是就衍生出了为何不自己搭建一个“淘宝领券网”的念头，一来可以更便捷的搜索淘宝优惠券，二来又能在已经享有优惠的基础上，再获得一些商家的返利，给这个本就不富裕的家庭，带来一缕阳光……</p>
<span id="more"></span>

<p>&emsp;&emsp;本文只记录服务器搭建淘宝领券网的相关代码步骤，其余的例如购买VPS、阿里妈妈淘宝联盟申请PID、<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF0YW9rZS5jb20v">大淘客<i class="fa fa-external-link-alt"></i></span>（本文使用的 CMS 系统）注册配置等，请自行 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==">百度<i class="fa fa-external-link-alt"></i></span>。本文默认已完成所有准备工作，已从 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF0YW9rZS5jb20vcG1jLW5ldy8jL2Ntcy93emJz">大淘客网站部署<i class="fa fa-external-link-alt"></i></span> 下载了“普通部署的程序文件” —— index.php</p>
<h1 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h1><h2 id="确认-CMS-系统"><a href="#确认-CMS-系统" class="headerlink" title="确认 CMS 系统"></a>确认 CMS 系统</h2><div class="note primary"><p>本文适配的淘宝领券网系统是：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF0YW9rZS5jb20vcG1jLW5ldy8jL2Ntcy93emJz">大淘客 CMS<i class="fa fa-external-link-alt"></i></span></p>
</div>

<h2 id="确认服务器系统版本"><a href="#确认服务器系统版本" class="headerlink" title="确认服务器系统版本"></a>确认服务器系统版本</h2><div class="note primary"><p>本文适用系统版本为：<strong>Ubuntu 18.04 server 64bit</strong></p>
</div>

<h1 id="更新服务器"><a href="#更新服务器" class="headerlink" title="更新服务器"></a>更新服务器</h1><h2 id="获取最新软件包"><a href="#获取最新软件包" class="headerlink" title="获取最新软件包"></a>获取最新软件包</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt update</span></span><br></pre></td></tr></table></figure>

<h2 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt full-upgrade</span></span><br></pre></td></tr></table></figure>

<h1 id="安装-Apache-服务器"><a href="#安装-Apache-服务器" class="headerlink" title="安装 Apache 服务器"></a>安装 Apache 服务器</h1><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt</span> install apache<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="安装-PHP"><a href="#安装-PHP" class="headerlink" title="安装 PHP"></a>安装 PHP</h1><h2 id="获取安装软件包文件清单"><a href="#获取安装软件包文件清单" class="headerlink" title="获取安装软件包文件清单"></a>获取安装软件包文件清单</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">apt</span> install software-properties-<span class="meta">common</span></span><br></pre></td></tr></table></figure>

<h2 id="获取安装-PHP-包文件清单"><a href="#获取安装-PHP-包文件清单" class="headerlink" title="获取安装 PHP 包文件清单"></a>获取安装 PHP 包文件清单</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add</span>-apt-repository <span class="keyword">pp</span><span class="variable">a:ondrej</span>/php</span><br></pre></td></tr></table></figure>

<h2 id="获取更新"><a href="#获取更新" class="headerlink" title="获取更新"></a>获取更新</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt update</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-PHP-Apache-2-扩展"><a href="#安装-PHP-Apache-2-扩展" class="headerlink" title="安装 PHP Apache 2 扩展"></a>安装 PHP Apache 2 扩展</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt</span> install libapache<span class="number">2</span>-mod-php<span class="number">7</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-PHP-APCu-扩展"><a href="#安装-PHP-APCu-扩展" class="headerlink" title="安装 PHP APCu 扩展"></a>安装 PHP APCu 扩展</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">apt -y <span class="keyword">install</span> php-apcu</span><br></pre></td></tr></table></figure>

<h1 id="PHP-网站搭建完成"><a href="#PHP-网站搭建完成" class="headerlink" title="PHP 网站搭建完成"></a>PHP 网站搭建完成</h1><p>&emsp;&emsp;至此，一个全新的 PHP 网站就搭建完成了。此时需要将大淘客CMS的安装文件“index.php”放入服务器的网站根目录，即 /var/www/html/index.php，且删除同目录下原有的“index.html”（否则访问网站时，会优先展示“index.html”），然后访问服务器公网IP。</p>
<h1 id="报错问题解决"><a href="#报错问题解决" class="headerlink" title="报错问题解决"></a>报错问题解决</h1><h2 id="curl-未开启-请先开启curl扩展，否则无法运行-请联系您的空间或者服务器提供商"><a href="#curl-未开启-请先开启curl扩展，否则无法运行-请联系您的空间或者服务器提供商" class="headerlink" title="curl 未开启,请先开启curl扩展，否则无法运行,请联系您的空间或者服务器提供商"></a>curl 未开启,请先开启curl扩展，否则无法运行,请联系您的空间或者服务器提供商</h2><h3 id="安装-PHP-插件-cURL"><a href="#安装-PHP-插件-cURL" class="headerlink" title="安装 PHP 插件 cURL"></a>安装 PHP 插件 cURL</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt</span> install php<span class="number">7</span>.<span class="number">4</span>-curl</span><br></pre></td></tr></table></figure>

<h2 id="mbstring-未开启-请先开启mbstring扩展，否则无法运行"><a href="#mbstring-未开启-请先开启mbstring扩展，否则无法运行" class="headerlink" title="mbstring 未开启,请先开启mbstring扩展，否则无法运行"></a>mbstring 未开启,请先开启mbstring扩展，否则无法运行</h2><h3 id="安装-PHP-插件-mbstring"><a href="#安装-PHP-插件-mbstring" class="headerlink" title="安装 PHP 插件 mbstring"></a>安装 PHP 插件 mbstring</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt</span> install php<span class="number">7</span>.<span class="number">4</span>-mbstring</span><br></pre></td></tr></table></figure>

<h2 id="重启-Apache-2-服务"><a href="#重启-Apache-2-服务" class="headerlink" title="重启 Apache 2 服务"></a>重启 Apache 2 服务</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/etc/i</span>nit.d/apache2 restart</span><br></pre></td></tr></table></figure>

<h2 id="cache-无效-请先设置目录读写权限-请联系您的空间或者服务器提供商"><a href="#cache-无效-请先设置目录读写权限-请联系您的空间或者服务器提供商" class="headerlink" title="cache 无效,请先设置目录读写权限,请联系您的空间或者服务器提供商"></a>cache 无效,请先设置目录读写权限,请联系您的空间或者服务器提供商</h2><h3 id="修改-Apache-2-权限"><a href="#修改-Apache-2-权限" class="headerlink" title="修改 Apache 2 权限"></a>修改 Apache 2 权限</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">chown</span> -<span class="type">R</span> www-<span class="class"><span class="keyword">data</span>:www-<span class="keyword">data</span> /var/www</span></span><br></pre></td></tr></table></figure>

<h1 id="刷新网页"><a href="#刷新网页" class="headerlink" title="刷新网页"></a>刷新网页</h1><div class="note success"><p>Success! Start enjoying your Taobao coupon website!</p>
</div>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Taobao</tag>
        <tag>淘宝</tag>
        <tag>领券网</tag>
      </tags>
  </entry>
  <entry>
    <title>Build Vulstudy / 搭建 vulstudy</title>
    <url>/IT/7.html</url>
    <content><![CDATA[<p>vulstudy 利用 Docker 集成了多个当下流行的漏洞练习平台，作者是：<span class="exturl" data-url="aHR0cDovL2d2Ny5tZS8=">c0ny1<i class="fa fa-external-link-alt"></i></span>。因为作者的 Readme 只写了重要部分，网上又没有详细的教程，博主在搭建的时候踩了很多坑，反复搭建了十几次，所以写下此篇教程，希望你们能一次搭建成功😂</p>
<div class="note primary"><p>GitHub 项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzkyMTEzMTQvdnVsc3R1ZHk=">9211314/vulstudy<i class="fa fa-external-link-alt"></i></span></p>
</div>

<span id="more"></span>

<h1 id="确认服务器系统版本"><a href="#确认服务器系统版本" class="headerlink" title="确认服务器系统版本"></a>确认服务器系统版本</h1><p>&emsp;&emsp;建议选择与博主一样的系统版本进行搭建：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> <strong>Centos 7</strong> x86_64 bbr</p>
<div class="note warning"><p>友情提示：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> 可能需要先 <a href="https://blog.hackme.cc/IT/3.html">翻墙</a> 才可访问！</p>
</div>

<h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><p>&emsp;&emsp;以下命令如果有不一样，包括但不限于版本不同（例如 pip 改为 pip3，或者 pip 不更新），都有可能造成搭建失败（博主试了十几次的血的教训😭），所以还是跟着博主老老实实的一行一行敲命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> docker -y     <span class="comment"># 安装 Docker</span></span><br><span class="line">sudo yum <span class="keyword">install</span> python-pip -y     <span class="comment"># 安装 pip</span></span><br><span class="line">pip <span class="keyword">install</span> <span class="comment">--upgrade pip     # 升级 pip</span></span><br><span class="line">pip <span class="keyword">install</span> docker-compose <span class="comment">--ignore-installed requests     # 安装 docker-compose</span></span><br><span class="line">sudo yum <span class="keyword">install</span> git -y     <span class="comment"># 安装 git</span></span><br><span class="line">git <span class="keyword">clone</span> https://github.com/<span class="number">9211314</span>/vulstudy.git     <span class="comment"># 下载 vulstudy</span></span><br><span class="line">service docker <span class="keyword">start</span>     <span class="comment"># 启动 Docker</span></span><br></pre></td></tr></table></figure>

<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h2 id="单独运行一个漏洞平台"><a href="#单独运行一个漏洞平台" class="headerlink" title="单独运行一个漏洞平台"></a>单独运行一个漏洞平台</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> vulstudy/DVWA     <span class="comment"># 如要运行 DVWA，就进入项目的 DVWA 目录</span></span><br><span class="line">docker-compose up -d     <span class="comment"># 启动容器</span></span><br><span class="line">docker-compose stop     <span class="comment"># 停止容器</span></span><br></pre></td></tr></table></figure>

<h2 id="同时运行所有漏洞平台"><a href="#同时运行所有漏洞平台" class="headerlink" title="同时运行所有漏洞平台"></a>同时运行所有漏洞平台</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> vulstudy     <span class="comment"># 进入项目根目录</span></span><br><span class="line">docker-compose up -d     <span class="comment"># 启动容器（如有平台未启动，请再次运行此命令）</span></span><br><span class="line">docker-compose stop     <span class="comment"># 停止容器</span></span><br></pre></td></tr></table></figure>

<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="第一次启动-bWAPP-容器访问其主页会报错如下"><a href="#第一次启动-bWAPP-容器访问其主页会报错如下" class="headerlink" title="第一次启动 bWAPP 容器访问其主页会报错如下"></a>第一次启动 bWAPP 容器访问其主页会报错如下</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Connection</span> failed: <span class="type">Unknown</span> <span class="keyword">database</span> <span class="string">&#x27;bWAPP&#x27;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因为第一次运行需要先访问 install.php 创建数据库。</p>
<h2 id="第一次启动-Hackademic-容器会提示安装"><a href="#第一次启动-Hackademic-容器会提示安装" class="headerlink" title="第一次启动 Hackademic 容器会提示安装"></a>第一次启动 Hackademic 容器会提示安装</h2><p>&emsp;&emsp;根据提示输入相关信息，数据库用户名<strong>必须</strong>为 root，密码<strong>留空</strong>，其余信息自定义。</p>
<h2 id="第一次搭建-DVWA，IOS-系统的-safari-浏览器无法初始化数据库，并提示如下"><a href="#第一次搭建-DVWA，IOS-系统的-safari-浏览器无法初始化数据库，并提示如下" class="headerlink" title="第一次搭建 DVWA，IOS 系统的 safari 浏览器无法初始化数据库，并提示如下"></a>第一次搭建 DVWA，IOS 系统的 safari 浏览器无法初始化数据库，并提示如下</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">CSRF token <span class="keyword">is</span> incorrect</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用其他浏览器即可，如 Chrome</p>
<h1 id="删除重建"><a href="#删除重建" class="headerlink" title="删除重建"></a>删除重建</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> <span class="variable">$</span>(docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">-q</span>) <span class="operator">-f</span>     <span class="comment"># 强制删除所有容器</span></span><br><span class="line">docker rmi <span class="operator">-f</span> <span class="variable">$</span>(docker images <span class="literal">-qa</span>)     <span class="comment"># 删除所有镜像</span></span><br><span class="line"><span class="built_in">cd</span> vulstudy     <span class="comment"># 进入项目根目录</span></span><br><span class="line">docker<span class="literal">-compose</span> up <span class="literal">-d</span>     <span class="comment"># 重建</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>vulstudy</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Build Trojan（制作“保质期长的”酸酸乳）</title>
    <url>/IT/3.html</url>
    <content><![CDATA[<p>Hello，又见面了！之前博主分享过一篇 <a href="https://blog.hackme.cc/IT/1.html">《Build SSR（制作酸酸乳）》</a> 的教程，但是不知是因为<em>蝙蝠</em> 还是因为<em>年兽</em>，最近 SSR 频繁被封。不管怎么换 IP 换端口各种换，每次用不上五分钟就被封，让博主很是头疼。终于“游历天下，博采众长”，get 到了一种船新的翻墙方式，采用 SSL 进行加密，所以几乎无法被监测，也就几乎无法被封。所以在此将制作方法分享给大家，觉得好用的记得 Donate 哈~</p>
<span id="more"></span>

<blockquote>
<p>An unidentifiable mechanism that helps you bypass GFW.<br>Trojan features multiple protocols over to avoid both active/passive detections and ISP limitations.<br>Trojan is not a fixed program or protocol. It’s an idea, an idea that imitating the most common service, to an extent that it behaves identically, could help you get across the Great FireWall permanently, without being identified ever. We are the GreatER Fire; we ship Trojan Horses.<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——<em>摘自 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Ryb2phbi1nZncvdHJvamFu">GitHub trojan-gfw/trojan<i class="fa fa-external-link-alt"></i></span></em></p>
</blockquote>
<h1 id="需要准备工具"><a href="#需要准备工具" class="headerlink" title="需要准备工具"></a>需要准备工具</h1><h2 id="一台服务器"><a href="#一台服务器" class="headerlink" title="一台服务器"></a>一台服务器</h2><div class="note primary"><p>服务器系统要求：centos 7+ / debian 9+ / ubuntu 16.04+</p>
</div>

<p>&emsp;&emsp;建议选择与博主一样的系统版本进行搭建：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> <strong>Centos 7</strong> x86_64 bbr</p>
<div class="note warning"><p>友情提示：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> 可能需要先翻墙才可访问！</p>
</div>

<h2 id="一个域名"><a href="#一个域名" class="headerlink" title="一个域名"></a>一个域名</h2><p>&emsp;&emsp;任意纯英文域名皆可。域名类型与系统搭建无关，建议使用纯英文域名。博主多年使用感受，推荐在 <span class="exturl" data-url="aHR0cHM6Ly93YW53YW5nLmFsaXl1bi5jb20vZG9tYWluLz9zb3VyY2U9NTE3Ni4xMTUzMzQ1NyZ1c2VyQ29kZT1lenB3OXNpaCZ0eXBlPWNvcHk=">阿里云域名注册<i class="fa fa-external-link-alt"></i></span> 注册域名，并使用免费的 <span class="exturl" data-url="aHR0cHM6Ly93YW53YW5nLmFsaXl1bi5jb20vZG9tYWluL2Rucz9zb3VyY2U9NTE3Ni4xMTUzMzQ1NyZ1c2VyQ29kZT1lenB3OXNpaCZ0eXBlPWNvcHk=">阿里云解析<i class="fa fa-external-link-alt"></i></span> 对域名进行解析。另外有其它建站需求的朋友，可点击 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9taW5pc2l0ZS9nb29kcz91c2VyQ29kZT1lenB3OXNpaA==">阿里云·云小站<i class="fa fa-external-link-alt"></i></span> 领取优惠券。</p>
<h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>&emsp;&emsp;将你的域名解析至你的服务器，即添加<strong>主域名</strong> A 记录指向服务器 IP（只需添加 @ 的主域名解析就行，无须添加 www 等的二级域名解析）</p>
<h1 id="服务器安装-Trojan"><a href="#服务器安装-Trojan" class="headerlink" title="服务器安装 Trojan"></a>服务器安装 Trojan</h1><h2 id="安装-cURL"><a href="#安装-cURL" class="headerlink" title="安装 cURL"></a>安装 cURL</h2><h3 id="CentOS-系统"><a href="#CentOS-系统" class="headerlink" title="CentOS 系统"></a>CentOS 系统</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">yum update -<span class="symbol">y</span> &amp;&amp; yum install curl -<span class="symbol">y</span></span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-Debian-系统"><a href="#Ubuntu-Debian-系统" class="headerlink" title="Ubuntu / Debian 系统"></a>Ubuntu / Debian 系统</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">apt update -<span class="symbol">y</span> &amp;&amp; apt install curl -<span class="symbol">y</span></span><br></pre></td></tr></table></figure>

<h2 id="Trojan-一键脚本"><a href="#Trojan-一键脚本" class="headerlink" title="Trojan 一键脚本"></a>Trojan 一键脚本</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -O https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/V2RaySSR/</span>Trojan<span class="regexp">/master/</span>Trojan.sh &amp;&amp; chmod x trojan.sh &amp;&amp; ./trojan.sh</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一键安装成功后，会显示 Trojan 客户端的下载地址，通过该地址下载 Trojan 客户端压缩包并解压</p>
<h1 id="使用-Trojan"><a href="#使用-Trojan" class="headerlink" title="使用 Trojan"></a>使用 Trojan</h1><h2 id="运行-Trojan-客户端"><a href="#运行-Trojan-客户端" class="headerlink" title="运行 Trojan 客户端"></a>运行 Trojan 客户端</h2><p>&emsp;&emsp;双击运行 start.bat 即可，然后配置浏览器</p>
<h2 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h2><h3 id="Chromium-Edge-Chrome-浏览器"><a href="#Chromium-Edge-Chrome-浏览器" class="headerlink" title="Chromium Edge / Chrome 浏览器"></a>Chromium Edge / Chrome 浏览器</h3><h4 id="安装-Proxy-SwitchyOmega-扩展"><a href="#安装-Proxy-SwitchyOmega-扩展" class="headerlink" title="安装 Proxy SwitchyOmega 扩展"></a>安装 Proxy SwitchyOmega 扩展</h4><p>&emsp;&emsp;通过 Chrome 网上应用商店，安装 Proxy SwitchyOmega 扩展</p>
<h4 id="配置-Proxy-SwitchyOmega"><a href="#配置-Proxy-SwitchyOmega" class="headerlink" title="配置 Proxy SwitchyOmega"></a>配置 Proxy SwitchyOmega</h4><ol>
<li>情景模式 → proxy</li>
<li>代理协议：SOCKS5</li>
<li>代理服务器：127.0.0.1</li>
<li>代理端口：1080</li>
<li>设置完成，左侧 <strong>应用选项</strong></li>
</ol>
<h4 id="使用时点击-SwitchyOmega-插件选择-proxy，即可翻墙"><a href="#使用时点击-SwitchyOmega-插件选择-proxy，即可翻墙" class="headerlink" title="使用时点击 SwitchyOmega 插件选择 proxy，即可翻墙"></a>使用时点击 SwitchyOmega 插件选择 proxy，即可翻墙</h4><h3 id="Firefox-浏览器"><a href="#Firefox-浏览器" class="headerlink" title="Firefox 浏览器"></a>Firefox 浏览器</h3><ol>
<li>选项 → 高级 → 网络 → 设置 → 手动配置代理</li>
<li>取消勾选“为所有协议使用相同代理”</li>
<li>清除 HTTP 代理、SSL 代理、FTP 代理及所有端口</li>
<li>SOCKS 主机：127.0.0.1</li>
<li>端口：1080</li>
<li>确定</li>
</ol>
<h2 id="关闭-Trojan"><a href="#关闭-Trojan" class="headerlink" title="关闭 Trojan"></a>关闭 Trojan</h2><p>&emsp;&emsp;双击运行 stop.bat 即可</p>
<div class="note success"><p>Success! Start enjoying Trojan!</p>
</div>

<div class="note info"><p>如需在安装了宝塔的服务器上安装 Trojan，请参阅：<a href="https://blog.hackme.cc/IT/4.html">《BT &amp; Trojan（在宝塔上制作酸酸乳）》</a></p>
</div>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Trojan</tag>
        <tag>一键脚本</tag>
        <tag>SwitchyOmega</tag>
      </tags>
  </entry>
  <entry>
    <title>CCIA China&#39;s Top 50 Cyber Security Competitive Power List of 2020 / 2020 年 CCIA 中国网络安全竞争力 50 强榜单</title>
    <url>/IT/10.html</url>
    <content><![CDATA[<blockquote>
<p>&emsp;&emsp;“2020年CCIA中国网络安全竞争力50强”（以下简称“CCIA 50强”）由中国网络安全产业联盟（CCIA）发布，由数说安全提供研究支持。<br>&emsp;&emsp;从2020年3月起，CCIA联合数说安全面向我国网络安全企业发起公开调研，最终收集到近200家网络安全企业提交的有效数据，基本覆盖了国内主要网络安全企业。“CCIA 50强”评价指标采用多维度综合评价法，坚持公平公正、客观中立，充分注重评价结果与市场的贴合度，对我国网络安全行业领军企业的发展状况进行了综合严谨的研究。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——<em>摘自 <span class="exturl" data-url="aHR0cDovL3d3dy5jaGluYS1jaWEub3JnLmNuL2hvbWUvV29ya0RldGFpbD9pZD01ZWQ5ZWZlZWE3ZjRhNDFjNjRkZTMwNzM=">2020年CCIA中国网络安全竞争力50强榜单揭晓<i class="fa fa-external-link-alt"></i></span></em></p>
</blockquote>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">排名</th>
<th align="center">公司名称</th>
<th align="center">公司简称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NO.1</td>
<td align="center">深信服科技股份有限公司</td>
<td align="center">深信服</td>
</tr>
<tr>
<td align="center">NO.2</td>
<td align="center">启明星辰信息技术集团股份有限公司</td>
<td align="center">启明星辰</td>
</tr>
<tr>
<td align="center">NO.3</td>
<td align="center">华为技术有限公司</td>
<td align="center">华为</td>
</tr>
<tr>
<td align="center">NO.4</td>
<td align="center">奇安信科技集团股份有限公司</td>
<td align="center">奇安信</td>
</tr>
<tr>
<td align="center">NO.5</td>
<td align="center">北京天融信科技有限公司</td>
<td align="center">天融信</td>
</tr>
<tr>
<td align="center">NO.6</td>
<td align="center">新华三集团有限公司</td>
<td align="center">新华三</td>
</tr>
<tr>
<td align="center">NO.7</td>
<td align="center">绿盟科技集团股份有限公司</td>
<td align="center">绿盟科技</td>
</tr>
<tr>
<td align="center">NO.8</td>
<td align="center">阿里云计算有限公司</td>
<td align="center">阿里云</td>
</tr>
<tr>
<td align="center">NO.9</td>
<td align="center">杭州安恒信息技术股份有限公司</td>
<td align="center">安恒信息</td>
</tr>
<tr>
<td align="center">NO.10</td>
<td align="center">腾讯科技（深圳）有限公司</td>
<td align="center">腾讯</td>
</tr>
<tr>
<td align="center">NO.11</td>
<td align="center">亚信科技（成都）有限公司</td>
<td align="center">亚信安全</td>
</tr>
<tr>
<td align="center">NO.12</td>
<td align="center">山石网科通信技术股份有限公司</td>
<td align="center">山石网科</td>
</tr>
<tr>
<td align="center">NO.13</td>
<td align="center">三六零安全科技股份有限公司</td>
<td align="center">三六零</td>
</tr>
<tr>
<td align="center">NO.14</td>
<td align="center">杭州迪普科技股份有限公司</td>
<td align="center">迪普科技</td>
</tr>
<tr>
<td align="center">NO.15</td>
<td align="center">成都卫士通信息产业股份有限公司</td>
<td align="center">卫士通</td>
</tr>
<tr>
<td align="center">NO.16</td>
<td align="center">厦门市美亚柏科信息股份有限公司</td>
<td align="center">美亚柏科</td>
</tr>
<tr>
<td align="center">NO.17</td>
<td align="center">北京数字认证股份有限公司</td>
<td align="center">数字认证</td>
</tr>
<tr>
<td align="center">NO.18</td>
<td align="center">中孚信息股份有限公司</td>
<td align="center">中孚信息</td>
</tr>
<tr>
<td align="center">NO.19</td>
<td align="center">北京北信源软件股份有限公司</td>
<td align="center">北信源</td>
</tr>
<tr>
<td align="center">NO.20</td>
<td align="center">上海观安信息技术股份有限公司</td>
<td align="center">观安信息</td>
</tr>
<tr>
<td align="center">NO.21</td>
<td align="center">蓝盾信息安全技术股份有限公司</td>
<td align="center">蓝盾股份</td>
</tr>
<tr>
<td align="center">NO.22</td>
<td align="center">北京优炫软件股份有限公司</td>
<td align="center">优炫软件</td>
</tr>
<tr>
<td align="center">NO.23</td>
<td align="center">任了行网络技术股份有限公司</td>
<td align="center">任子行</td>
</tr>
<tr>
<td align="center">NO.24</td>
<td align="center">恒安嘉新（北京）科技股份公司</td>
<td align="center">恒安嘉新</td>
</tr>
<tr>
<td align="center">NO.25</td>
<td align="center">沈阳东软系统集成工程有限公司</td>
<td align="center">东软</td>
</tr>
<tr>
<td align="center">NO.26</td>
<td align="center">格尔软件股份有限公司</td>
<td align="center">格尔软件</td>
</tr>
<tr>
<td align="center">NO.27</td>
<td align="center">北京安博通科技股份有限公司</td>
<td align="center">安博通</td>
</tr>
<tr>
<td align="center">NO.28</td>
<td align="center">北京梆梆安全科技有限公司</td>
<td align="center">梆梆安全</td>
</tr>
<tr>
<td align="center">NO.29</td>
<td align="center">安天科技集团股份有限公司</td>
<td align="center">安天</td>
</tr>
<tr>
<td align="center">NO.30</td>
<td align="center">北京立思辰信息安全科技集团</td>
<td align="center">立思辰</td>
</tr>
<tr>
<td align="center">NO.31</td>
<td align="center">成都科来软件有限公司</td>
<td align="center">科来</td>
</tr>
<tr>
<td align="center">NO.32</td>
<td align="center">北京圣博润高新技术股份有限公司</td>
<td align="center">圣博润</td>
</tr>
<tr>
<td align="center">NO.33</td>
<td align="center">山东华软金盾软件股份有限公司</td>
<td align="center">金盾软件</td>
</tr>
<tr>
<td align="center">NO.34</td>
<td align="center">北京永信至诚科技股份有限公司</td>
<td align="center">永信至诚</td>
</tr>
<tr>
<td align="center">NO.35</td>
<td align="center">北京知道创宇信息技术殷份有限公司</td>
<td align="center">知道创宇</td>
</tr>
<tr>
<td align="center">NO.36</td>
<td align="center">深圳市联软科技股份有限公司</td>
<td align="center">联软科技</td>
</tr>
<tr>
<td align="center">NO.37</td>
<td align="center">南京南瑞信息通信科技有限公司</td>
<td align="center">南瑞信通</td>
</tr>
<tr>
<td align="center">NO.38</td>
<td align="center">拓尔思信息技术股份有限公司</td>
<td align="center">拓尔思</td>
</tr>
<tr>
<td align="center">NO.39</td>
<td align="center">中新网络信息安全股份有限公司</td>
<td align="center">中新网安</td>
</tr>
<tr>
<td align="center">NO.40</td>
<td align="center">网宿科技股份有限公司</td>
<td align="center">网宿科技</td>
</tr>
<tr>
<td align="center">NO.41</td>
<td align="center">飞天诚信科技股份有限公司</td>
<td align="center">飞天诚信</td>
</tr>
<tr>
<td align="center">NO.42</td>
<td align="center">北京明朝万达科技股份有限公司</td>
<td align="center">明朝万达</td>
</tr>
<tr>
<td align="center">NO.43</td>
<td align="center">杭州美创科技有限公司</td>
<td align="center">美创科技</td>
</tr>
<tr>
<td align="center">NO.44</td>
<td align="center">北京智游网安科技有限公司</td>
<td align="center">爱加密</td>
</tr>
<tr>
<td align="center">NO.45</td>
<td align="center">北京威努特技术有限公司</td>
<td align="center">威努特</td>
</tr>
<tr>
<td align="center">NO.46</td>
<td align="center">远江盛邦（北京）网络安全科技股份有限公司</td>
<td align="center">盛邦安全</td>
</tr>
<tr>
<td align="center">NO.47</td>
<td align="center">上海派拉软件股份有限公司</td>
<td align="center">派拉软件</td>
</tr>
<tr>
<td align="center">NO.48</td>
<td align="center">北京指掌易科技有限公司</td>
<td align="center">指掌易</td>
</tr>
<tr>
<td align="center">NO.49</td>
<td align="center">北京芯盾时代科技有限公司</td>
<td align="center">芯盾时代</td>
</tr>
<tr>
<td align="center">NO.50</td>
<td align="center">齐治科技股份有限公司</td>
<td align="center">齐治科技</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>CCIA</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN Nodes / CDN 节点 IP</title>
    <url>/IT/9.html</url>
    <content><![CDATA[<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93YW5nemhhbi5xaWFueGluLmNvbS9ub3RpY2UvZGV0YWlsLzEwMDU3">奇安信网站卫士<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdS5iYWlkdS5jb20vaGVscC9pbmRleC5odG1sIy8xMF9jaGFuZ2ppYW53ZW50aS8wX0hJREVfRkFRLzIwX2JhaWR1eXVuamlhc3VqaWVkaWFuSVBkaXpoaWR1YW4ubWQ=">百度云加速<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vaXBzLw==">Cloudflare<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>节点</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS Security Hardening FAQ / CentOS 安全加固问题总汇</title>
    <url>/IT/13.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文收集了博主在 CentOS 安全加固中遇到的问题，会根据日常工作反馈及时更新。宗旨是希望所有的信息系统都能加固到位，并节约大家百度的时间，可以收藏备用。<br>&emsp;&emsp;本文只是针对 CentOS 的加固问题汇总。《CentOS 安全加固规范》已由部门技术总监制订，正在测试完善中，等出了稳定版，博主会再结合工作实操进行整理（在此先致敬总监的辛苦付出，虽然他也不会看我的博客😄）。</p>
<span id="more"></span>

<h1 id="PuTTY-host-SSH-key"><a href="#PuTTY-host-SSH-key" class="headerlink" title="PuTTY host SSH key"></a>PuTTY host SSH key</h1><p>PuTTY 的 host SSH key（主机 SSH 密钥）不是保存在某个路径下的！而是在注册表……不懂为什么要存在注册表里……</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">计算机<span class="symbol">\H</span>KEY_CURRENT_USER<span class="symbol">\S</span>OFTWARE<span class="symbol">\S</span>imonTatham<span class="symbol">\P</span>uTTY<span class="symbol">\S</span>shHostKeys     # 这个大小写看着也很别扭</span><br></pre></td></tr></table></figure>

<h1 id="SFTP-上传文件"><a href="#SFTP-上传文件" class="headerlink" title="SFTP 上传文件"></a>SFTP 上传文件</h1><p>&emsp;&emsp;通过 SFTP 上传本地文件很简单，一个命令搞定</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">put</span> 本地文件 目标路径</span><br></pre></td></tr></table></figure>

<h1 id="useradd-cannot-open-etc-passwd"><a href="#useradd-cannot-open-etc-passwd" class="headerlink" title="useradd: cannot open /etc/passwd"></a>useradd: cannot open /etc/passwd</h1><p>&emsp;&emsp;用 root 账户 <code>useradd</code> 创建用户的时候提示： <code>useradd: cannot open /etc/passwd</code> 当时百度了说是“i 权限问题”，就很迷，root 账户第一次碰到权限问题。<br>&emsp;&emsp;那要创建用户怎么办呢？博主提供了这个思路</p>
<ol>
<li>查看文件是否涉及“i 权限”问题</li>
<li>去除 i 权限限制</li>
<li>创建用户</li>
<li>加回 i 权限限制</li>
</ol>
<p>&emsp;&emsp;对应的代码如下</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">lsattr /etc/passwd     # 查看文件权限</span><br><span class="line">chattr -i /etc/passwd     # 去除 /etc/passwd i 权限</span><br><span class="line">chattr -i /etc<span class="built_in">/group </span>    # 去除 /etc<span class="built_in">/group </span>i 权限</span><br><span class="line">chattr -i /etc/shadow     # 去除 /etc/shadow i 权限</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;进行如上操作以后便可以自由地创建用户了，当然创建完用户别忘了用以下命令把 i 权限加回去，恢复原样</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">chattr +i /etc/passwd     # 给 /etc/passwd 加回 i 权限</span><br><span class="line">chattr +i /etc<span class="built_in">/group </span>    # 给 /etc<span class="built_in">/group </span>加回 i 权限</span><br><span class="line">chattr +i /etc/shadow     # 给 /etc/shadow 加回 i 权限</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>安全加固</tag>
        <tag>FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Clerware Admin / 科力锐 超级管理员</title>
    <url>/Clerware/2.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是针对科力锐灾备一体机（clerware 智动全景灾备系统）<strong>超级管理员</strong> admin 主要操作及功能的介绍，为博主的<strong>个人笔记</strong>，未必是正确操作，<strong>勿将其作为</strong><del>科力锐官方技术文档</del>，仅供参考！</p>
<div class="note warning"><p>本文针对的是 <strong>超级管理员</strong>，如需 <strong>系统管理员</strong> 相关操作，请参考 <a href="https://blog.hackme.cc/Clerware/3.html">《科力锐 系统管理员》</a></p>
</div>

<span id="more"></span>

<h1 id="超级管理员-admin-操作"><a href="#超级管理员-admin-操作" class="headerlink" title="超级管理员 admin 操作"></a>超级管理员 admin 操作</h1><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>&emsp;&emsp;网络管理 → 网络设置 → 配置IP → 试用</p>
<div class="note warning"><p>配置完设备的 IP 后，点击的是“试用”，会有<strong>10分钟的试用期</strong>。通过设置的新 IP 进行登陆后，如果确认可以使用，需要到刚才配置设备 IP 的界面，点击“确认”从而生成<strong>永久配置</strong>。如果超过10分钟未点击“确认”，设备 IP 会回滚到原来的配置。</p>
</div>

<h2 id="设置系统管理员"><a href="#设置系统管理员" class="headerlink" title="设置系统管理员"></a>设置<strong>系统管理员</strong></h2><p>&emsp;&emsp;用户管理 → 用户管理 → 新建 → 设置用户信息及功能授权 → 确定</p>
<div class="note primary"><p>新建用户初始密码是：123456</p>
</div>

<h2 id="分配系统管理员存储配额"><a href="#分配系统管理员存储配额" class="headerlink" title="分配系统管理员存储配额"></a>分配<strong>系统管理员</strong>存储配额</h2><p>&emsp;&emsp;存储管理 → 存储配额管理 → 内部存储单元 → 添加用户配额 → 选择用户进行相应配置 → 确定</p>
<h1 id="超级管理员其余功能项"><a href="#超级管理员其余功能项" class="headerlink" title="超级管理员其余功能项"></a>超级管理员其余功能项</h1><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><h4 id="PXE-设置（不常用）"><a href="#PXE-设置（不常用）" class="headerlink" title="PXE 设置（不常用）"></a>PXE 设置（不常用）</h4><p>&emsp;&emsp;目标机如果是裸机的情况下，另一种引导方式，以网卡的形式启动起来，就是将ISO用网络的方式推送到目标机，然后让它启动，一般用不到</p>
<h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><p>&emsp;&emsp;给灾备系统添加路由，使其可以访问另一网络</p>
<h4 id="路由检测（常用）"><a href="#路由检测（常用）" class="headerlink" title="路由检测（常用）"></a>路由检测（常用）</h4><p>&emsp;&emsp;用于测试灾备系统与目标主机能否通信</p>
<h3 id="消息与通知设置"><a href="#消息与通知设置" class="headerlink" title="消息与通知设置"></a>消息与通知设置</h3><p>&emsp;&emsp;用于设置灾备情况告警</p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>&emsp;&emsp;用于配置、解锁<strong>系统管理员</strong>。<strong>系统管理员</strong>输错密码达一定次数被锁定，在此解锁</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><div class="note primary"><p>系统升级前需要关闭所有备份计划，确认无正在进行任务</p>
</div>

<h3 id="客户端管理"><a href="#客户端管理" class="headerlink" title="客户端管理"></a>客户端管理</h3><p>&emsp;&emsp;所有<strong>系统管理员</strong>的客户端在此都能查看</p>
<h3 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h3><p>&emsp;&emsp;查询灾备一体机的<strong>序列号</strong>及<strong>型号</strong>，以及查看或上传灾备授权</p>
<h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p>&emsp;&emsp;将密钥发送给科力锐技术支持，登陆后台 root 的密码就是：admin 密码+密钥解密后的明文</p>
<h4 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h4><p>&emsp;&emsp;设置是否开启灾备一体机的 SSH 服务</p>
<h4 id="密码策略（等保相关）"><a href="#密码策略（等保相关）" class="headerlink" title="密码策略（等保相关）"></a>密码策略（等保相关）</h4><h4 id="登陆设置（等保相关）"><a href="#登陆设置（等保相关）" class="headerlink" title="登陆设置（等保相关）"></a>登陆设置（等保相关）</h4><h4 id="时间设置"><a href="#时间设置" class="headerlink" title="时间设置"></a>时间设置</h4><p>&emsp;&emsp;配置 NTP</p>
<h4 id="VT（虚拟化平台相关）"><a href="#VT（虚拟化平台相关）" class="headerlink" title="VT（虚拟化平台相关）"></a>VT（虚拟化平台相关）</h4><p>&emsp;&emsp;如虚拟化平台底层不支持，则不使用 VT</p>
<h4 id="网络设置（虚拟化平台相关）"><a href="#网络设置（虚拟化平台相关）" class="headerlink" title="网络设置（虚拟化平台相关）"></a>网络设置（虚拟化平台相关）</h4><p>&emsp;&emsp;如 MTU 值不是1500，可在此修改，以及设置 KVM 主机是否可通过 VNC 登陆</p>
<div class="note info"><p>完成此文操作后，可进入下一步操作，即 <a href="https://blog.hackme.cc/Clerware/3.html">《科力锐 系统管理员》</a></p>
</div>]]></content>
      <categories>
        <category>Clerware</category>
      </categories>
      <tags>
        <tag>超级管理员</tag>
        <tag>灾备</tag>
        <tag>智动全景灾备系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Clerware Deployment Process / 科力锐灾备（一体机）部署/上架流程</title>
    <url>/Clerware/4.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是科力锐灾备一体机（clerware 智动全景灾备系统）部署/上架流程的操作文档，为博主的<strong>个人笔记</strong>，未必是正确操作，<strong>勿将其作为</strong><del>科力锐官方技术文档</del>，仅供参考！</p>
<div class="note info"><p>部署/上架时如产生错误，请参照 <a href="https://blog.hackme.cc/Clerware/5.html">《科力锐灾备 常见问题》</a> 进行问题排查</p>
</div>

<span id="more"></span>

<h1 id="部署流程的目的"><a href="#部署流程的目的" class="headerlink" title="部署流程的目的"></a>部署流程的目的</h1><p>&emsp;&emsp;确保用户在后期灾备系统任务执行、信息告警、灾难演练和应急恢复等行之有效</p>
<h1 id="部署前准备工作（与用户交流）"><a href="#部署前准备工作（与用户交流）" class="headerlink" title="部署前准备工作（与用户交流）"></a>部署前准备工作（与用户交流）</h1><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><h3 id="无接管-热备需求"><a href="#无接管-热备需求" class="headerlink" title="无接管 / 热备需求"></a>无接管 / 热备需求</h3><p>&emsp;&emsp;确定用户提供给灾备一体机的 IP 地址可用，可与所需部署灾备的系统相互通信，且不会产生 IP 地址冲突。</p>
<h3 id="有接管（测试）需求"><a href="#有接管（测试）需求" class="headerlink" title="有接管（测试）需求"></a>有接管（测试）需求</h3><p>&emsp;&emsp;确定客户的网络是否划分 VLAN，若有划分，需<strong>记录</strong>需接管源机所在网络的 VLAN 号，然后将灾备一体机的网卡解除聚合，将交换机连接灾备一体机的端口设置为 trunk 模式</p>
<h3 id="有热备需求"><a href="#有热备需求" class="headerlink" title="有热备需求"></a>有热备需求</h3><p>&emsp;&emsp;确定灾备一体机的 IP 可与热备的源机及目标机相互通信，且不会有 IP 冲突</p>
<div class="note info"><p>热备时，备机直接使用源机 IP，源机所以需要一个新 IP，用户需提前准备一个不用的 IP</p>
</div>

<h2 id="灾备端口"><a href="#灾备端口" class="headerlink" title="灾备端口"></a>灾备端口</h2><h3 id="非公有云（主动连接）"><a href="#非公有云（主动连接）" class="headerlink" title="非公有云（主动连接）"></a>非公有云（主动连接）</h3><p>&emsp;&emsp;确认源机的 20000 ~ 20003 端口可与灾备一体机进行通信</p>
<h3 id="公有云（被动连接）"><a href="#公有云（被动连接）" class="headerlink" title="公有云（被动连接）"></a>公有云（被动连接）</h3><p>&emsp;&emsp;确认灾备一体机的 IP 可以访问源机的 3345 端口</p>
<h2 id="设备摆放位置"><a href="#设备摆放位置" class="headerlink" title="设备摆放位置"></a>设备摆放位置</h2><p>&emsp;&emsp;提前确定设备为几 U，然后与用户确认设备的部署位置：几排几号机柜多少 U</p>
<h2 id="系统管理员及权限的划分"><a href="#系统管理员及权限的划分" class="headerlink" title="系统管理员及权限的划分"></a>系统管理员及权限的划分</h2><p>&emsp;&emsp;确定用户需要分配的系统管理员账号和对应的权限</p>
<h2 id="告警设置信息"><a href="#告警设置信息" class="headerlink" title="告警设置信息"></a>告警设置信息</h2><p>&emsp;&emsp;确定灾备的告警设置信息：邮箱 / 企业微信</p>
<h2 id="确认网线规格"><a href="#确认网线规格" class="headerlink" title="确认网线规格"></a>确认网线规格</h2><p>&emsp;&emsp;确定用户网速，如为千兆网<strong>至少</strong>需提供超五类网线</p>
<h1 id="部署前检查"><a href="#部署前检查" class="headerlink" title="部署前检查"></a>部署前检查</h1><h2 id="正式设备"><a href="#正式设备" class="headerlink" title="正式设备"></a>正式设备</h2><h3 id="查看成交设备所属项目和用户名称"><a href="#查看成交设备所属项目和用户名称" class="headerlink" title="查看成交设备所属项目和用户名称"></a>查看成交设备所属项目和用户名称</h3><h3 id="查看设备外包装"><a href="#查看设备外包装" class="headerlink" title="查看设备外包装"></a>查看设备外包装</h3><h3 id="开箱查看配件是否齐全：2×网线、2×电源线、服务器导轨、用户手册"><a href="#开箱查看配件是否齐全：2×网线、2×电源线、服务器导轨、用户手册" class="headerlink" title="开箱查看配件是否齐全：2×网线、2×电源线、服务器导轨、用户手册"></a>开箱查看配件是否齐全：2×网线、2×电源线、服务器导轨、用户手册</h3><div class="note warning"><p>正式设备的开箱需要用户在场</p>
</div>

<h2 id="测试设备："><a href="#测试设备：" class="headerlink" title="测试设备："></a>测试设备：</h2><h3 id="开机检查，查看磁盘灯是否闪黄灯，查看-BIOS-是否报错，确定设备硬件是否正常"><a href="#开机检查，查看磁盘灯是否闪黄灯，查看-BIOS-是否报错，确定设备硬件是否正常" class="headerlink" title="开机检查，查看磁盘灯是否闪黄灯，查看 BIOS 是否报错，确定设备硬件是否正常"></a>开机检查，查看磁盘灯是否闪黄灯，查看 BIOS 是否报错，确定设备硬件是否正常</h3><h3 id="连接显示器和键盘，确定设备系统是否正常"><a href="#连接显示器和键盘，确定设备系统是否正常" class="headerlink" title="连接显示器和键盘，确定设备系统是否正常"></a>连接显示器和键盘，确定设备系统是否正常</h3><h3 id="确认测试设备的授权信息，是否可用（重要）"><a href="#确认测试设备的授权信息，是否可用（重要）" class="headerlink" title="确认测试设备的授权信息，是否可用（重要）"></a>确认测试设备的授权信息，是否可用（重要）</h3><h3 id="确认设备的系统版本、ISO-启动介质版本、驱动版本，及时更新为最新版"><a href="#确认设备的系统版本、ISO-启动介质版本、驱动版本，及时更新为最新版" class="headerlink" title="确认设备的系统版本、ISO 启动介质版本、驱动版本，及时更新为最新版"></a>确认设备的系统版本、ISO 启动介质版本、驱动版本，及时更新为最新版</h3><h3 id="查看-IP-地址，并修改成用户所提供的-IP-地址"><a href="#查看-IP-地址，并修改成用户所提供的-IP-地址" class="headerlink" title="查看 IP 地址，并修改成用户所提供的 IP 地址"></a>查看 IP 地址，并修改成用户所提供的 IP 地址</h3><div class="note info"><p>完成此文操作后，可进入下一步操作，即 <a href="https://blog.hackme.cc/Clerware/2.html">《科力锐 超级管理员》</a></p>
</div>]]></content>
      <categories>
        <category>Clerware</category>
      </categories>
      <tags>
        <tag>灾备</tag>
        <tag>智动全景灾备系统</tag>
        <tag>灾备一体机</tag>
      </tags>
  </entry>
  <entry>
    <title>Clerware Oracle RAC / 科力锐 Oracle RAC</title>
    <url>/Clerware/1.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是对科力锐灾备培训中，针对 Oracle RAC 系统<strong>备份</strong>、<strong>接管</strong>、<strong>恢复</strong>的操作记录。为博主培训学习的<strong>个人笔记</strong>，未必是正确操作，<strong>勿将其作为</strong><del>科力锐官方技术文档</del>，仅供参考！</p>
<span id="more"></span>

<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>备份需要使用灾备系统的集群备份</li>
<li>因为 RAC 的两个节点中的集群数据都是一样的，所以 RAC 的 CDP 备份，只保留 RAC 主节点的一份集群数据</li>
<li>因此需明确哪一台服务器作为主节点，后续接管验证或只恢复单节点验证业务，需选择主节点</li>
<li>科力锐灾备中的 RAC 主节点，为灾备时设置的主节点，不一定非要对应 RAC 本身已经设定好的主节点</li>
</ol>
<h2 id="备份前准备"><a href="#备份前准备" class="headerlink" title="备份前准备"></a>备份前准备</h2><ol>
<li>需提前七个工作日将环境收集表及运行脚本生成的 .log 日志发送给科力锐技术支持</li>
<li>确认 RAC 的服务运行正常<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/u01/</span>app<span class="regexp">/11.2.0/g</span>rid<span class="regexp">/bin/</span></span><br><span class="line">./crs_stat -t     <span class="comment"># 查看是否都是 ONLINE</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="开始备份"><a href="#开始备份" class="headerlink" title="开始备份"></a>开始备份</h2><ol>
<li>安装灾备客户端</li>
<li>在灾备一体机中，查看客户端管理，确认两个 RAC 节点是否都在线</li>
<li>点击“集群备份计划”，选择新建备份，选择 RAC 的两个节点</li>
<li>选择备份的主节点</li>
<li>选择备份的策略<br> &emsp;&emsp;由于 RAC 的 CDP 备份是单独授权，若没有此项授权，RAC 只能进行定时备份；由于 RAC 对磁盘读写比较敏感，当备份间隔频率过短，磁盘长时间处于繁忙状态时会影响 RAC 运行，所以定时备份的频率不得低于以小时为单位；如若对 RAC 业务数据的精确度比较高时，则可选用 CDP 备份，RAC CDP 的 RPO 趋近于 0，对RAC 性能影响小于 1%，当 CDP 保护期间被保护的 RAC 检测到 I/O 繁忙时，将自动暂停 CDP 保护；当数据 I/O 正常后自动恢复为 CDP 保护）</li>
<li>集群磁盘设置，灾备系统会自动关联共享磁盘</li>
<li>设置备份相关参数</li>
<li>立即进行 RAC 的备份</li>
</ol>
<h2 id="确认备份状态"><a href="#确认备份状态" class="headerlink" title="确认备份状态"></a>确认备份状态</h2><h1 id="接管"><a href="#接管" class="headerlink" title="接管"></a>接管</h1><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>接管不支持同时接管两个节点，需同时恢复两个节点时，目标机需准备共享存储，磁盘与源机的磁盘对应（包括集群盘）</li>
<li>因为 RAC 需要扫描 IP 、网卡名、设备名等，所以接管时配置较为复杂</li>
</ol>
<h2 id="接管前准备"><a href="#接管前准备" class="headerlink" title="接管前准备"></a>接管前准备</h2><ol>
<li>查看并记录网卡数量及对应IP，后续接管时要进行相关配置<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifconfig</span></span><br></pre></td></tr></table></figure></li>
<li>查看并记录网关及 DNS，后续接管时要进行相关配置</li>
</ol>
<h2 id="开始接管"><a href="#开始接管" class="headerlink" title="开始接管"></a>开始接管</h2><p>&emsp;&emsp;恢复 → 接管主机 → 新建 → 选择主节点 → 选择备份点 → 接管主机 → 选择具体备份点 → 根据源机情况进行相应配置</p>
<h2 id="确认-RAC-服务启动情况"><a href="#确认-RAC-服务启动情况" class="headerlink" title="确认 RAC 服务启动情况"></a>确认 RAC 服务启动情况</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/u01/</span>app<span class="regexp">/11.2.0/g</span>rid<span class="regexp">/bin/</span></span><br><span class="line">./crsctl stat res -t -init     <span class="comment"># 显示 STARTING 就是启动中，如正在启动，过段时间进行以下操作</span></span><br><span class="line">./crs_stat -t     <span class="comment"># 看是否都是 ONLINE，如有非核心业务 OFFLINE，确认是否与源机状态相同</span></span><br></pre></td></tr></table></figure>

<h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><h2 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h2><p>&emsp;&emsp;恢复单节点和普通恢复相同，只要选择 RAC 主节点的数据进行恢复即可。如需恢复双节点，则需提供共享存储</p>
<h2 id="恢复前准备"><a href="#恢复前准备" class="headerlink" title="恢复前准备"></a>恢复前准备</h2><ol>
<li>查看并记录磁盘数量及容量<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lsblk</span>     <span class="comment"># 对应有系统盘和集群盘</span></span><br></pre></td></tr></table></figure></li>
<li>网卡相应配置与上面接管相同</li>
</ol>
<h2 id="开始恢复"><a href="#开始恢复" class="headerlink" title="开始恢复"></a>开始恢复</h2><p>&emsp;&emsp;步骤与普通服务器恢复步骤相同，涉及到的例如网卡等配置问题参考接管相应配置</p>
<h2 id="确认-RAC-服务启动状态（与接管确认服务启动状态相同）"><a href="#确认-RAC-服务启动状态（与接管确认服务启动状态相同）" class="headerlink" title="确认 RAC 服务启动状态（与接管确认服务启动状态相同）"></a>确认 RAC 服务启动状态（与接管确认服务启动状态相同）</h2>]]></content>
      <categories>
        <category>Clerware</category>
      </categories>
      <tags>
        <tag>灾备</tag>
        <tag>Oracle RAC</tag>
      </tags>
  </entry>
  <entry>
    <title>Cyber Security Abbreviations / 网络安全缩写</title>
    <url>/Penetration-Test/3.html</url>
    <content><![CDATA[<p>&emsp;&emsp;博主正在整理网络安全缩写。中文释义皆参照了维基百科和百度百科。若有扩充指正，请联系博主，一经采纳，必有重谢！（博主继承了祖辈之学术严谨）</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>简称</th>
<th>全称</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvM0RFUw==">3DES/TDEA<i class="fa fa-external-link-alt"></i></span></td>
<td>Triple Data Encryption Algorithm</td>
<td>三重数据加密算法</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9BQUEvMTUwMzE1">AAA<i class="fa fa-external-link-alt"></i></span></td>
<td>Authentication, Authorization, Accounting</td>
<td>认证、授权、计费</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFEJTk4JUU1JThGJTk2JUU2JThFJUE3JUU1JTg4JUI2JUU0JUI4JUIyJUU1JTg4JTk3">ACL<i class="fa fa-external-link-alt"></i></span></td>
<td>Access Control List</td>
<td>访问控制表</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUFCJTk4JUU3JUJBJUE3JUU1JThBJUEwJUU1JUFGJTg2JUU2JUEwJTg3JUU1JTg3JTg2">AES<i class="fa fa-external-link-alt"></i></span></td>
<td>Advanced Encryption Standard</td>
<td>高级加密标准</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQVNDSUk=">ASCII<i class="fa fa-external-link-alt"></i></span></td>
<td>American Standard Code for Information Interchange</td>
<td>美国信息交换标准代码</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFGJTgxJUU0JUI5JUE2JUU5JUEyJTgxJUU1JThGJTkxJUU2JTlDJUJBJUU2JTlFJTg0">CA<i class="fa fa-external-link-alt"></i></span></td>
<td>Certificate Authority</td>
<td>证书颁发机构</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9DQ01Q">CCMP<i class="fa fa-external-link-alt"></i></span></td>
<td>Counter CBC-MAC Protocol</td>
<td>计数器模式密码块链消息完整码协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFGJUEyJUU5JTk3JUFFJUU2JThGJUExJUU2JTg5JThCJUU4JUFFJUE0JUU4JUFGJTgxJUU1JThEJThGJUU4JUFFJUFF">CHAP<i class="fa fa-external-link-alt"></i></span></td>
<td>Challenge-Handshake Authentication Protocol</td>
<td>询问握手认证协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFGJTgxJUU0JUI5JUE2JUU1JTkwJThBJUU5JTk0JTgwJUU1JTg4JTk3JUU4JUExJUE4">CRL<i class="fa fa-external-link-alt"></i></span></td>
<td>Certificate revocation list</td>
<td>证书吊销列表</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFGJTgxJUU0JUI5JUE2JUU3JUFEJUJFJUU3JUJEJUIyJUU4JUFGJUI3JUU2JUIxJTgy">CSR<i class="fa fa-external-link-alt"></i></span></td>
<td>Certificate Signing Request</td>
<td>证书签署请求</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUE4JUU3JUFCJTk5JUU4JUFGJUI3JUU2JUIxJTgyJUU0JUJDJUFBJUU5JTgwJUEw">CSRF/XSRF<i class="fa fa-external-link-alt"></i></span></td>
<td>Cross-site Request Forgery</td>
<td>跨站请求伪造</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTg3JUFBJUU0JUI4JUJCJUU4JUFFJUJGJUU5JTk3JUFFJUU2JThFJUE3JUU1JTg4JUI2">DAC<i class="fa fa-external-link-alt"></i></span></td>
<td>Discretionary Access Control</td>
<td>自主访问控制</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTk4JUJCJUU2JTk2JUI3JUU2JTlDJThEJUU1JThCJTk5JUU2JTk0JUJCJUU2JTkzJThB">DDoS<i class="fa fa-external-link-alt"></i></span></td>
<td>Distributed Denial-of-service Dttack</td>
<td>分布式拒绝服务攻击</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUIzJTg3JUU2JTk2JTk5JUU1JThBJUEwJUU1JUFGJTg2JUU2JUE4JTk5JUU2JUJBJTk2">DES<i class="fa fa-external-link-alt"></i></span></td>
<td>Data Encryption Standard</td>
<td>数据加密标准</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvRE1a">DMZ<i class="fa fa-external-link-alt"></i></span></td>
<td>Demilitarized Zone</td>
<td>非军事区/对外网络</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlGJTlGJUU1JTkwJThEJUU3JUIzJUJCJUU3JUJCJTlG">DNS<i class="fa fa-external-link-alt"></i></span></td>
<td>Domain Name System</td>
<td>域名系统</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlGJTlGJUU1JTkwJThEJUU3JUIzJUJCJUU3JUJCJTlGJUU1JUFFJTg5JUU1JTg1JUE4JUU2JTg5JUE5JUU1JUIxJTk1">DNSSEC<i class="fa fa-external-link-alt"></i></span></td>
<td>Domain Name System Security Extensions</td>
<td>域名系统安全扩展</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTk4JUJCJUU2JTk2JUI3JUU2JTlDJThEJUU1JThCJTk5JUU2JTk0JUJCJUU2JTkzJThB">DoS<i class="fa fa-external-link-alt"></i></span></td>
<td>Denial-of-service Attack</td>
<td>拒绝服务攻击</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTg5JUE5JUU1JUIxJTk1JUU4JUFFJUE0JUU4JUFGJTgxJUU1JThEJThGJUU4JUFFJUFF">EAP<i class="fa fa-external-link-alt"></i></span></td>
<td>Extensible Authentication Protocol</td>
<td>扩展认证协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJDJTgxJUU0JUI4JTlBJUU4JUI1JTg0JUU2JUJBJTkwJUU4JUFFJUExJUU1JTg4JTky">ERP<i class="fa fa-external-link-alt"></i></span></td>
<td>Enterprise Resource Planning</td>
<td>企业资源计划</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk2JTg3JUU0JUJCJUI2JUU0JUJDJUEwJUU4JUJFJTkzJUU1JThEJThGJUU4JUFFJUFF">FTP<i class="fa fa-external-link-alt"></i></span></td>
<td>File Transfer Protocol</td>
<td>文件传输协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgwJTlBJUU3JTk0JUE4JUU4JUI3JUFGJUU3JTk0JUIxJUU1JUIwJTgxJUU4JUEzJTg1">GRE<i class="fa fa-external-link-alt"></i></span></td>
<td>Generic Routing Encapsulation</td>
<td>通用路由封装</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUFCJTk4JUU1JThGJUFGJUU3JTk0JUE4JUU2JTgwJUE3">HA<i class="fa fa-external-link-alt"></i></span></td>
<td>High Availability</td>
<td>高可用性</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQkIlRTYlOUMlQkElRTUlODUlQTUlRTQlQkUlQjUlRTklOTglQjIlRTUlQkUlQTElRTclQjMlQkIlRTclQkIlOUY=">HIPS<i class="fa fa-external-link-alt"></i></span></td>
<td>Hostbased Intrusion Prevention System</td>
<td>主机入侵防御系统</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI2JTg1JUU2JTk2JTg3JUU2JTlDJUFDJUU0JUJDJUEwJUU4JUJFJTkzJUU1JThEJThGJUU4JUFFJUFF">HTTP<i class="fa fa-external-link-alt"></i></span></td>
<td>Hyper Text Transfer Protocol</td>
<td>超文本传输协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI2JTg1JUU2JTk2JTg3JUU2JTlDJUFDJUU0JUJDJUEwJUU4JUJFJTkzJUU1JUFFJTg5JUU1JTg1JUE4JUU1JThEJThGJUU4JUFFJUFF">HTTPS<i class="fa fa-external-link-alt"></i></span></td>
<td>Hyper Text Transfer Protocol Secure</td>
<td>超文本传输安全协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlBJTk2JUU5JTgwJTlBJUU3JUE5JUJBJUU4JUFBJUJG">HVAC<i class="fa fa-external-link-alt"></i></span></td>
<td>Heating, Ventilation and Air Conditioning</td>
<td>暖通空调、供热通风与空气调节</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJTkyJUU4JTgxJTk0JUU3JUJEJTkxJUU2JThFJUE3JUU1JTg4JUI2JUU2JUI2JTg4JUU2JTgxJUFGJUU1JThEJThGJUU4JUFFJUFF">ICMP<i class="fa fa-external-link-alt"></i></span></td>
<td>Internet Control Message Protocol</td>
<td>互联网控制消息协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUI3JUE1JUU2JUE1JUFEJUU2JThFJUE3JUU1JTg4JUI2JUU3JUIzJUJCJUU3JUI1JUIx">ICS<i class="fa fa-external-link-alt"></i></span></td>
<td>Industrial Control System</td>
<td>工业控制系统</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUE1JUU0JUJFJUI1JUU2JUEzJTgwJUU2JUI1JThCJUU3JUIzJUJCJUU3JUJCJTlG">IDS<i class="fa fa-external-link-alt"></i></span></td>
<td>Intrusion-detection System</td>
<td>入侵检测系统</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlCJUEwJUU3JTg5JUI5JUU3JUJEJTkxJUU0JUJGJUExJUU2JTgxJUFGJUU4JUFFJUJGJUU5JTk3JUFFJUU1JThEJThGJUU4JUFFJUFF">IMAP<i class="fa fa-external-link-alt"></i></span></td>
<td>Internet Message Access Protocol</td>
<td>因特网消息访问协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTg5JUE5JUU4JTgxJTk0JUU3JUJEJTkx">IoT<i class="fa fa-external-link-alt"></i></span></td>
<td>Internet of Things</td>
<td>物联网</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUE1JUU0JUJFJUI1JUU5JUEyJTg0JUU5JTk4JUIyJUU3JUIzJUJCJUU3JUJCJTlG">IPS<i class="fa fa-external-link-alt"></i></span></td>
<td>Intrusion Prevention System</td>
<td>入侵防御系统</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSVBzZWM=">IPsec<i class="fa fa-external-link-alt"></i></span></td>
<td>Internet Protocol Security</td>
<td>互联网安全协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFDJUFDJUU0JUJBJThDJUU1JUIxJTgyJUU5JTlBJUE3JUU5JTgxJTkzJUU1JThEJThGJUU4JUFFJUFF">L2TP<i class="fa fa-external-link-alt"></i></span></td>
<td>Layer Two Tunneling Protocol</td>
<td>第二层隧道协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJEJUJCJUU1JTlFJThCJUU3JTlCJUFFJUU1JUJEJTk1JUU4JUFFJUJGJUU5JTk3JUFFJUU1JThEJThGJUU4JUFFJUFF">LDAP<i class="fa fa-external-link-alt"></i></span></td>
<td>Lightweight Directory Access Protocol</td>
<td>轻型目录访问协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlDJUFDJUU1JTlDJUIwJUU1JUFFJTg5JUU1JTg1JUE4JUU4JUFBJThEJUU4JUFEJTg5JUU1JUFEJTkwJUU3JUIzJUJCJUU3JUI1JUIxJUU2JTlDJThEJUU1JThCJTk5">LSASS<i class="fa fa-external-link-alt"></i></span></td>
<td>Local Security Authority Subsystem Service</td>
<td>本地安全认证子系统服务</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTUFDJUU1JTlDJUIwJUU1JTlEJTgw">MAC<i class="fa fa-external-link-alt"></i></span></td>
<td>Media Access Control Address</td>
<td>媒体访问控制地址/物理地址</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTUQ1">MD5<i class="fa fa-external-link-alt"></i></span></td>
<td>MD5 Message-Digest Algorithm</td>
<td>MD5消息摘要算法</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJEJTkxJUU3JThBJUI2JUU3JUJEJTkxJUU3JUJCJTlD">Mesh<i class="fa fa-external-link-alt"></i></span></td>
<td>Mesh Network</td>
<td>网状网络</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU3JTk0JUE4JUU5JTgwJTk0JUU0JUJBJTkyJUU4JTgxJUFGJUU3JUI2JUIyJUU5JTgzJUI1JUU0JUJCJUI2JUU2JTkzJUI0JUU1JUIxJTk1">MIME<i class="fa fa-external-link-alt"></i></span></td>
<td>Multipurpose Internet Mail Extensions</td>
<td>多用途互联网邮件扩展</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU5JTk3JUI0JUU0JUJBJUJBJUU2JTk0JUJCJUU1JTg3JUJC">MITM<i class="fa fa-external-link-alt"></i></span></td>
<td>Man-in-the-middle Attack</td>
<td>中间人攻击</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFCJTkyJUU4JUE3JUEzJUU1JTgyJTk5JUU1JUJGJTk4JUU5JThDJTg0">MOU<i class="fa fa-external-link-alt"></i></span></td>
<td>Memorandum of Understanding</td>
<td>谅解备忘录</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUI5JUIzJUU1JTlEJTg3JUU2JTk1JTg1JUU5JTlBJTlDJUU5JTk2JTkzJUU5JTlBJTk0">MTBF<i class="fa fa-external-link-alt"></i></span></td>
<td>Mean Time Between Failures</td>
<td>平均故障间隔</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUI5JUIzJUU1JTlEJTg3JUU0JUJGJUFFJUU1JUJFJUE5JUU2JTk5JTgyJUU5JTk2JTkz">MTTR<i class="fa fa-external-link-alt"></i></span></td>
<td>Mean Time to Recovery</td>
<td>平均修复时间</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJEJTkxJUU3JUJCJTlDJUU1JTlDJUIwJUU1JTlEJTgwJUU4JUJEJUFDJUU2JThEJUEy">NAT<i class="fa fa-external-link-alt"></i></span></td>
<td>Network Address Translation</td>
<td>网络地址转换</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJGJTlEJUU1JUFGJTg2JUU1JThEJThGJUU4JUFFJUFF">NDA<i class="fa fa-external-link-alt"></i></span></td>
<td>Non-disclosure Agreement</td>
<td>保密协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFDJUExJUU0JUI4JTk2JUU0JUJCJUEzJUU5JTk4JUIyJUU3JTgxJUFCJUU3JTg5JTg2">NGFW<i class="fa fa-external-link-alt"></i></span></td>
<td>Next-generation Firewall</td>
<td>下一代防火墙</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9OVExN">NTLM<i class="fa fa-external-link-alt"></i></span></td>
<td>NT LAN Manager</td>
<td>NT局域网管理器</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJDJTgwJUU2JTk0JUJFJUU2JThFJTg4JUU2JTlEJTgz">OAuth<i class="fa fa-external-link-alt"></i></span></td>
<td>OAuth</td>
<td>开放授权</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlDJUE4JUU3JUJBJUJGJUU4JUFGJTgxJUU0JUI5JUE2JUU3JThBJUI2JUU2JTgwJTgxJUU1JThEJThGJUU4JUFFJUFF">OCSP<i class="fa fa-external-link-alt"></i></span></td>
<td>Online Certificate Status Protocol</td>
<td>在线证书状态协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUYlQjklRTglQjElQTElRTYlQTAlODclRTglQUYlODYlRTclQUMlQTY=">OID<i class="fa fa-external-link-alt"></i></span></td>
<td>Object Identifier</td>
<td>对象标识符</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFGJTg2JUU3JUEwJTgxJUU4JUFFJUE0JUU4JUFGJTgxJUU1JThEJThGJUU4JUFFJUFF">PAP<i class="fa fa-external-link-alt"></i></span></td>
<td>Password Authentication Protocol</td>
<td>密码认证协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9wYXQvMzcyNjgwMw==">PAT<i class="fa fa-external-link-alt"></i></span></td>
<td>Port Address Translation</td>
<td>端口地址转换</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUENM">PCL<i class="fa fa-external-link-alt"></i></span></td>
<td>Printer Command Language</td>
<td>打印机命令语言</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9QRUFQ">PEAP<i class="fa fa-external-link-alt"></i></span></td>
<td>Protected Extensible Authentication Protocol</td>
<td>受保护的扩展认证协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTgwJThCJUU0JUJBJUJBJUU4JUFEJTk4JUU1JTg4JUE1JUU3JUEyJUJD">PIN<i class="fa fa-external-link-alt"></i></span></td>
<td>Personal Identification Number</td>
<td>个人身份识别码</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUGluZw==">ping<i class="fa fa-external-link-alt"></i></span></td>
<td>Packet Internet Groper</td>
<td>网络诊断工具</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFDJUU5JTk2JThCJUU5JTg3JTkxJUU5JTkxJUIwJUU1JTlGJUJBJUU3JUE0JThFJUU1JUJCJUJBJUU4JUE4JUFE">PKI<i class="fa fa-external-link-alt"></i></span></td>
<td>Public Key Infrastructure</td>
<td>公开密钥基础建设</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTgyJUI5JUU1JUFGJUI5JUU3JTgyJUI5JUU1JThEJThGJUU4JUFFJUFF">PPP<i class="fa fa-external-link-alt"></i></span></td>
<td>Point-to-Point Protocol</td>
<td>点对点协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUJCJTlFJUU1JUIwJThEJUU5JUJCJTlFJUU5JTlBJUE3JUU5JTgxJTkzJUU1JThEJTk0JUU4JUFEJUIw">PPTP<i class="fa fa-external-link-alt"></i></span></td>
<td>Point to Point Tunneling Protocol</td>
<td>点对点隧道协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9QU0svMTM4ODg2NzY=">PSK<i class="fa fa-external-link-alt"></i></span></td>
<td>Pre-shared Key</td>
<td>预共享密钥</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlDJThEJUU1JThBJUExJUU4JUI0JUE4JUU5JTg3JThG">QoS<i class="fa fa-external-link-alt"></i></span></td>
<td>Quality of Service</td>
<td>服务质量</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJGJTlDJUU3JUFCJUFGJUU3JTk0JUE4JUU2JTg4JUI3JUU2JThCJUE4JUU1JTg1JUE1JUU5JUFBJThDJUU4JUFGJTgxJUU2JTlDJThEJUU1JThBJUEx">RADIUS<i class="fa fa-external-link-alt"></i></span></td>
<td>Remote Authentication Dial In User Service</td>
<td>远端用户拨入验证服务</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlBJThGJUU2JTlDJUJBJUU1JUFEJTk4JUU1JThGJTk2JUU1JUFEJTk4JUU1JTgyJUE4JUU1JTk5JUE4">RAM<i class="fa fa-external-link-alt"></i></span></td>
<td>Random Access Memory</td>
<td>随机存取存储器</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJCJUE1JUU4JUE3JTkyJUU4JTg5JUIyJUU3JTgyJUJBJUU1JTlGJUJBJUU3JUE0JThFJUU3JTlBJTg0JUU1JUFEJTk4JUU1JThGJTk2JUU2JThFJUE3JUU1JTg4JUI2">RBAC<i class="fa fa-external-link-alt"></i></span></td>
<td>Role-based Access Control</td>
<td>基于角色的访问控制</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTk0JUFGJUU4JUFFJTgwJUU4JUE4JTk4JUU2JTg2JUI2JUU5JUFCJTk0">ROM<i class="fa fa-external-link-alt"></i></span></td>
<td>Read-only Memory</td>
<td>只读存储器</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9SUE8=">RPO<i class="fa fa-external-link-alt"></i></span></td>
<td>Recovery Point Object</td>
<td>恢复点目标</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9SVE8=">RTO<i class="fa fa-external-link-alt"></i></span></td>
<td>Recovery Time Object</td>
<td>恢复时间目标</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFFJTg5JUU1JTg1JUE4JUU2JTk2JUFEJUU4JUE4JTgwJUU2JUEwJTg3JUU4JUFFJUIwJUU4JUFGJUFEJUU4JUE4JTgw">SAML<i class="fa fa-external-link-alt"></i></span></td>
<td>Security Assertion Markup Language</td>
<td>安全断言标记语言</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUIzJUJCJUU3JUJCJTlGJUU1JThGJTkxJUU1JUIxJTk1JUU3JTk0JTlGJUU1JTkxJUJEJUU1JTkxJUE4JUU2JTlDJTlG">SDLC<i class="fa fa-external-link-alt"></i></span></td>
<td>System Development Life Cycle</td>
<td>系统发展生命周期</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU1NIJUU2JTk2JTg3JUU0JUJCJUI2JUU0JUJDJUEwJUU4JUJFJTkzJUU1JThEJThGJUU4JUFFJUFF">SFTP<i class="fa fa-external-link-alt"></i></span></td>
<td>SSH File Transfer Protocol/Secret File Transfer Protocol</td>
<td>安全文件传送协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zaWVt">SIEM<i class="fa fa-external-link-alt"></i></span></td>
<td>Security Information and Event Management</td>
<td>安全信息和事件管理</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlDJThEJUU1JThBJUExJUU3JUJBJUE3JUU1JTg4JUFCJUU1JThEJThGJUU4JUFFJUFF">SLA<i class="fa fa-external-link-alt"></i></span></td>
<td>Service-level Agreement</td>
<td>服务级别协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUy9NSU1F">S/MIME<i class="fa fa-external-link-alt"></i></span></td>
<td>Secure Multipurpose Internet Mail Extensions</td>
<td>安全的多用途互联网邮件扩展</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFFJTgwJUU1JThEJTk1JUU3JUJEJTkxJUU3JUJCJTlDJUU3JUFFJUExJUU3JTkwJTg2JUU1JThEJThGJUU4JUFFJUFF">SNMP<i class="fa fa-external-link-alt"></i></span></td>
<td>Simple Network Management Protocol</td>
<td>简单网络管理协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThEJTk1JUU3JTg5JTg3JUU3JUIzJUJCJUU3JUJCJTlG">SoC<i class="fa fa-external-link-alt"></i></span></td>
<td>System on a Chip</td>
<td>单片系统/片上系统</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUFFJTg5JUU1JTg1JUE4JUU1JUFFJTlFJUU2JTk3JUI2JUU0JUJDJUEwJUU4JUJFJTkzJUU1JThEJThGJUU4JUFFJUFF">SRTP<i class="fa fa-external-link-alt"></i></span></td>
<td>Secure Real-time Transport Protocol</td>
<td>安全实时传输协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU2VjdXJlX1NoZWxs">SSH<i class="fa fa-external-link-alt"></i></span></td>
<td>Secure Shell</td>
<td>安全外壳协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zc2w=">SSL<i class="fa fa-external-link-alt"></i></span></td>
<td>Secure Sockets Layer</td>
<td>安全套接层</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTk2JUFFJUU0JUI4JTgwJUU3JTk5JUJCJUU1JTg1JUE1">SSO<i class="fa fa-external-link-alt"></i></span></td>
<td>Single Sign-on</td>
<td>单点登录</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlDJThEJUU1JThBJUExJUU1JTk5JUE4JUU3JUFCJUFGJUU4JUFGJUI3JUU2JUIxJTgyJUU0JUJDJUFBJUU5JTgwJUEw">SSRF<i class="fa fa-external-link-alt"></i></span></td>
<td>Server-side Request Forgery</td>
<td>服务端请求伪造</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVEFDQUNT">TACACS<i class="fa fa-external-link-alt"></i></span></td>
<td>Terminal Access Controller Access-Control System</td>
<td>终端访问控制器访问控制系统</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVEFDQUNTJTJC">TACACS+<i class="fa fa-external-link-alt"></i></span></td>
<td>Terminal Access Controller Access-Control System Plus</td>
<td>（全新）终端访问控制器访问控制系统</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJDJUEwJUU4JUJFJTkzJUU2JThFJUE3JUU1JTg4JUI2JUU1JThEJThGJUU4JUFFJUFF">TCP<i class="fa fa-external-link-alt"></i></span></td>
<td>Transmission Control Protocol</td>
<td>传输控制协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFFJTgwJUU1JThEJTk1JUU2JTk2JTg3JUU0JUJCJUI2JUU0JUJDJUEwJUU4JUJFJTkzJUU1JThEJThGJUU4JUFFJUFF">TFTP<i class="fa fa-external-link-alt"></i></span></td>
<td>Trivial File Transfer Protocol</td>
<td>简单文件传输协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUI0JUU2JTk3JUI2JUU1JUFGJTg2JUU5JTkyJUE1JUU1JUFFJThDJUU2JTk1JUI0JUU2JTgwJUE3JUU1JThEJThGJUU4JUFFJUFF">TKIP<i class="fa fa-external-link-alt"></i></span></td>
<td>Temporal Key Integrity Protocol</td>
<td>临时密钥完整性协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTgyJUIzJUU4JUJDJUI4JUU1JUIxJUE0JUU1JUFFJTg5JUU1JTg1JUE4JUU2JTgwJUE3JUU1JThEJTk0JUU1JUFFJTlB">TLS<i class="fa fa-external-link-alt"></i></span></td>
<td>Transport Layer Security</td>
<td>传输层安全协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJUFGJUU0JUJGJUExJUU1JUI5JUIzJUU1JThGJUIwJUU2JUE4JUExJUU1JTlEJTk3">TPM<i class="fa fa-external-link-alt"></i></span></td>
<td>Trusted Platform Module</td>
<td>可信平台模块</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJCJTlGJUU0JUI4JTgwJUU4JUI1JTg0JUU2JUJBJTkwJUU1JUFFJTlBJUU0JUJEJThEJUU3JUFDJUE2">URL<i class="fa fa-external-link-alt"></i></span></td>
<td>Uniform Resource Locator</td>
<td>统一资源定位符</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVm9JUA==">VoIP<i class="fa fa-external-link-alt"></i></span></td>
<td>Voice over Internet Protocol</td>
<td>基于IP的语音传输</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTk5JTlCJUU2JTkzJUFDJUU3JUE3JTgxJUU0JUJBJUJBJUU3JUI2JUIyJUU4JUI3JUFG">VPN<i class="fa fa-external-link-alt"></i></span></td>
<td>Virtual Private Network</td>
<td>虚拟专用网</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9XQUY=">WAF<i class="fa fa-external-link-alt"></i></span></td>
<td>Web Application Firewall</td>
<td>网络应用程序防火墙</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUEwJUU3JUJBJUJGJUU1JUJBJTk0JUU3JTk0JUE4JUU1JThEJThGJUU4JUFFJUFF">WAP<i class="fa fa-external-link-alt"></i></span></td>
<td>Wireless Application Protocol</td>
<td>无线应用协议</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlDJTg5JUU3JUI3JTlBJUU3JUFEJTg5JUU2JTk1JTg4JUU1JThBJUEwJUU1JUFGJTg2">WEP<i class="fa fa-external-link-alt"></i></span></td>
<td>Wired Equivalent Privacy</td>
<td>有线等效加密</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvV1BB">WPA<i class="fa fa-external-link-alt"></i></span></td>
<td>Wi-Fi Protected Access</td>
<td>Wi-Fi访问保护</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvV2ktRmklRTQlQkYlOUQlRTYlOEElQTQlRTglQUUlQkUlRTclQkQlQUU=">WPS<i class="fa fa-external-link-alt"></i></span></td>
<td>Wi-Fi Protected Setup</td>
<td>Wi-Fi保护设置</td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI3JUE4JUU3JUI2JUIyJUU3JUFCJTk5JUU2JThDJTg3JUU0JUJCJUE0JUU3JUEyJUJD">XSS<i class="fa fa-external-link-alt"></i></span></td>
<td>Cross-site Scripting</td>
<td>跨站脚本</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Clerware FAQ / 科力锐灾备 常见问题</title>
    <url>/Clerware/5.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文总结了科力锐灾备（clerware 智动全景灾备系统）的常见问题，为博主的<strong>个人笔记</strong>，未必是正确操作，<strong>勿将其作为</strong><del>科力锐官方技术文档</del>，仅供参考！</p>
<span id="more"></span>

<h1 id="Agent-安装报错"><a href="#Agent-安装报错" class="headerlink" title="Agent 安装报错"></a>Agent 安装报错</h1><h2 id="Windows-安装被杀毒软件拦截"><a href="#Windows-安装被杀毒软件拦截" class="headerlink" title="Windows 安装被杀毒软件拦截"></a>Windows 安装被杀毒软件拦截</h2><ol>
<li>排除源机是否存在第三方杀毒软件，若有，将杀毒软件的防护功能关闭，然后到客户端安装目录，查看灾备驱动状态<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">showsbd</span><span class="selector-class">.exe</span> <span class="selector-tag">-status</span></span><br></pre></td></tr></table></figure></li>
<li>若报错，没有获取到正确的磁盘数量<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install_disksbd.exe </span>unin_disksbd     <span class="comment"># 手动卸载驱动</span></span><br><span class="line"><span class="keyword">install_disksbd.exe </span>in_disksbd     <span class="comment"># 手动安装驱动</span></span><br></pre></td></tr></table></figure></li>
<li>以上步骤还是无法安装，若源机是 360，最好是卸载 360，然后重启源机再安装</li>
</ol>
<h2 id="Windows-安装报错"><a href="#Windows-安装报错" class="headerlink" title="Windows 安装报错"></a>Windows 安装报错</h2><p>&emsp;&emsp;发现这个文件客户端安装目录根本没有，可能就是源机磁盘有问题，需要chkdsk磁盘，如果发现错误，需要/f修复重启系统，然后再安装</p>
<h2 id="Linux-安装报告ICE连接异常"><a href="#Linux-安装报告ICE连接异常" class="headerlink" title="Linux 安装报告ICE连接异常"></a>Linux 安装报告ICE连接异常</h2><ol>
<li>确认客户端安装模式，主动模式是客户端去连接灾备系统，首先在客户端 ping 灾备系统，看能否 ping 通；隧道模式是客户端无法访问到灾备系统，灾备系统去连接客户端，多用于备份公有云主机，查看“连接管理”，是否填写正确客户端的公网 IP</li>
<li>主动模式，查看连接的灾备系统 IP 是否有误，查看 AgentService.config 是否是需要连接的灾备系统 IP</li>
<li>如果修改了 AgentService.config 里的 IP，需要重启客户端服务<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">service</span> ClwDRClient restart     <span class="comment"># 重启客户端服务</span></span><br></pre></td></tr></table></figure></li>
<li>若客户端为主动模式，telnet 灾备系统的 20000 端口，如果不通，就是端口未开放的问题；若客户端为被动模式，灾备系统 telnet 客户端的 3345 端口</li>
</ol>
<h2 id="Linux-安装直接报告脚本的-MD5-值不一致"><a href="#Linux-安装直接报告脚本的-MD5-值不一致" class="headerlink" title="Linux 安装直接报告脚本的 MD5 值不一致"></a>Linux 安装直接报告脚本的 MD5 值不一致</h2><p>&emsp;&emsp;以上原因出现是由于下载的脚本不完整导致，删除之前那个脚本，重新生成一个链接进行下载，下载后的文件与生成链接下方的 MD5 值进行对比，比对一样，代表下载的文件与一体机的文件一致</p>
<h2 id="Linux-安装报告文件不存在"><a href="#Linux-安装报告文件不存在" class="headerlink" title="Linux 安装报告文件不存在"></a>Linux 安装报告文件不存在</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">uname</span> -a     # 查看源机具体内核版本，是 x<span class="number">86</span> 还是 x<span class="number">64</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查看下载的 Linux 客户端是 32 位的还是 64 位的，以上现象的出现是由于安装的版本与源机的内核版本位数不匹配的原因</p>
<h2 id="Linux安装报错，安装驱动失败"><a href="#Linux安装报错，安装驱动失败" class="headerlink" title="Linux安装报错，安装驱动失败"></a>Linux安装报错，安装驱动失败</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">dmesg     <span class="comment"># 查看是否有分配内存失败的关键字</span></span><br><span class="line">free -m     <span class="comment"># 查看源机的内存使用情况，若看到 free 的内存很少，大多数内存都在缓存中</span></span><br><span class="line">echo <span class="number">3</span> &gt;&gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches     <span class="comment"># 在源机执行 3 次，刷缓存</span></span><br></pre></td></tr></table></figure>

<h2 id="Linux-安装失败，报告回写-initrd-失败"><a href="#Linux-安装失败，报告回写-initrd-失败" class="headerlink" title="Linux 安装失败，报告回写 initrd 失败"></a>Linux 安装失败，报告回写 initrd 失败</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">df</span> -h     <span class="comment"># 查看源机空间使用情况，是否出现了 boot 目录满的情况</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;联系客户管理员是否可以清理下 boot 目录，同时将我们的文件修改存放路径</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">df -aT     <span class="comment"># 查看非 btrfs 文件系统并且空间剩余多的路径，与用户确认将灾备客户端安装至哪一目录</span></span><br><span class="line">cat <span class="regexp">/opt/</span>ClwDRClient_2.<span class="number">0</span>.(版本号)<span class="regexp">/bin/</span>AgentService.config.demo     <span class="comment"># 复制最后两行</span></span><br><span class="line">vi <span class="regexp">/opt/</span>ClwDRClient_2.<span class="number">0</span>.(版本号)<span class="regexp">/bin/</span>AgentService.config     <span class="comment"># 黏贴刚才复制的两行，修改为要安装至的目录</span></span><br><span class="line">service ClwDRClient restart     <span class="comment"># 重启客户端服务</span></span><br></pre></td></tr></table></figure>

<h1 id="数据备份报错"><a href="#数据备份报错" class="headerlink" title="数据备份报错"></a>数据备份报错</h1><h2 id="查看客户端日志，显示备份失败-GetComputerAllInfo"><a href="#查看客户端日志，显示备份失败-GetComputerAllInfo" class="headerlink" title="查看客户端日志，显示备份失败 GetComputerAllInfo"></a>查看客户端日志，显示备份失败 GetComputerAllInfo</h2><ol>
<li>若源机为 Linux，通过 df -h 命令查看源机的根目录是否满了，若存在该问题，需协调用户清理源机空间</li>
<li>若源机为 Windows，查看系统C盘是否空间满，若存在该问题，需协调用户清理空间</li>
</ol>
<h2 id="客户端备份报错，创建位图失败"><a href="#客户端备份报错，创建位图失败" class="headerlink" title="客户端备份报错，创建位图失败"></a>客户端备份报错，创建位图失败</h2><ol>
<li>Windows 查看是否系统盘满了，Linux 查看 boot 目录满了，如果满了导致位图文件写不进去，同时是否对 boot 目录有写的权限；Windows 的话需要把系统盘空间释放一些出来，Linux 可以把 bmf 文件更换位置，然后覆盖安装</li>
<li>查看 Windows 系统盘是否被加密，Linux 的话查看是否 boot 目录没有写权限；Windows 现在还不支持磁盘被加密的情况</li>
</ol>
<h2 id="Windows-客户端备份失败，初始化磁盘位图信息失败（一般为杀毒软件导致）"><a href="#Windows-客户端备份失败，初始化磁盘位图信息失败（一般为杀毒软件导致）" class="headerlink" title="Windows 客户端备份失败，初始化磁盘位图信息失败（一般为杀毒软件导致）"></a>Windows 客户端备份失败，初始化磁盘位图信息失败（一般为杀毒软件导致）</h2><ol>
<li>在源机查看是否驱动未加载，进入源机 drivers 目录，查看 disksbd 以及 sbdfun 驱动是否存在，进入产品目录，输入运行<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">showsbd</span><span class="selector-class">.exe</span> <span class="selector-tag">-status</span></span><br></pre></td></tr></table></figure></li>
<li>若报错，没有获取到正确的磁盘数量<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install_disksbd.exe </span>unin_disksbd     <span class="comment"># 手动卸载驱动</span></span><br><span class="line"><span class="keyword">install_disksbd.exe </span>in_disksbd     <span class="comment"># 手动安装驱动</span></span><br><span class="line"><span class="keyword">showsbd.exe </span>-status     <span class="comment"># 查看是否报错</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="客户端备份失败，获取-agent-状态失败"><a href="#客户端备份失败，获取-agent-状态失败" class="headerlink" title="客户端备份失败，获取 agent 状态失败"></a>客户端备份失败，获取 agent 状态失败</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">lsmod | <span class="keyword">grep</span> disk     <span class="comment">#查看驱动是否存在，若驱动不存在，则需要重新安装客户端，即可解决该问题（一般是由于源机内核升级导致）</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;若源客户端为 Windows，在产品目录使用</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">showsbd.exe </span>-status     <span class="comment"># 查看驱动是否正常，若获取报错</span></span><br><span class="line"><span class="keyword">install_disksbd.exe </span>unin_disksbd     <span class="comment"># 手动卸载驱动</span></span><br><span class="line"><span class="keyword">install_disksbd.exe </span>in_disksbd     <span class="comment"># 手动安装驱动</span></span><br></pre></td></tr></table></figure>

<h1 id="业务重建还原报错"><a href="#业务重建还原报错" class="headerlink" title="业务重建还原报错"></a>业务重建还原报错</h1><h2 id="还原失败，报告目标机离线"><a href="#还原失败，报告目标机离线" class="headerlink" title="还原失败，报告目标机离线"></a>还原失败，报告目标机离线</h2><ol>
<li>检查网络是否有问题，是否真的离线</li>
<li>检查 PE_Project 进程是否工作正常，查看 PE_project.log 的日志是否报告异常（将日志发送给科力锐技术支持）</li>
<li>如果目标机是 Windows，查看是都是所有分区都是 fat32 或者目标机空间不够的已知问题</li>
</ol>
<h2 id="Windows-还原，目标机一直处于滚动条或者黑屏"><a href="#Windows-还原，目标机一直处于滚动条或者黑屏" class="headerlink" title="Windows 还原，目标机一直处于滚动条或者黑屏"></a>Windows 还原，目标机一直处于滚动条或者黑屏</h2><ol>
<li>检查网络是否正常，能否 Ping 通</li>
<li>尝试全量还原，查看网卡驱动是否安装</li>
</ol>
<h2 id="Linux-还原，目标机卡死，没有成功进入系统"><a href="#Linux-还原，目标机卡死，没有成功进入系统" class="headerlink" title="Linux 还原，目标机卡死，没有成功进入系统"></a>Linux 还原，目标机卡死，没有成功进入系统</h2><ol>
<li>尝试全量还原，如果全量还原成功，查看 IP 是否配置上<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">lsmod|<span class="keyword">grep</span> disk     <span class="comment">#查看全量还原的目标机是否有我们的驱动，如果没有，查看源机是否当前使用的内核和下次默认启动的内核不一致</span></span><br></pre></td></tr></table></figure></li>
<li>如果是以上原因，将目标机客户端卸载，然后初始化 initrd，再重新安装客户端</li>
</ol>
<h2 id="Linux-还原，目标机重启进救援模式"><a href="#Linux-还原，目标机重启进救援模式" class="headerlink" title="Linux 还原，目标机重启进救援模式"></a>Linux 还原，目标机重启进救援模式</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ll <span class="regexp">/sys/</span>block     <span class="comment">#查看是否有磁盘</span></span><br><span class="line">cat <span class="regexp">/etc/</span>fstab     <span class="comment">#查看是否由于源机使用设备名挂载，导致还原目标机找不到相应的设备导致，如果是，需要修改 fstab 为 UUID，重启系统</span></span><br><span class="line">blkid     <span class="comment">#查看 UUID，在上述文件中修改 fstab 为 UUID</span></span><br></pre></td></tr></table></figure>

<h1 id="业务接管或验证主机报错"><a href="#业务接管或验证主机报错" class="headerlink" title="业务接管或验证主机报错"></a>业务接管或验证主机报错</h1><h2 id="接管或者快速验证无法正常进行系统"><a href="#接管或者快速验证无法正常进行系统" class="headerlink" title="接管或者快速验证无法正常进行系统"></a>接管或者快速验证无法正常进行系统</h2><p>&emsp;&emsp;重新建接管主机，在高级设置中，更换显卡</p>
<h2 id="接管或者快速验证报告-KVM-未启动"><a href="#接管或者快速验证报告-KVM-未启动" class="headerlink" title="接管或者快速验证报告 KVM 未启动"></a>接管或者快速验证报告 KVM 未启动</h2><ol>
<li>查看灾备系统是否有开启 VT</li>
<li>admin 账号登陆，查看系统状态是否有报告不支持 VT</li>
<li>如显示不支持 VT，若灾备系统为物理机，需要进 BIOS 里面开启“virtual technology”功能，如灾备系统部署在虚拟化平台，平台底层不支持 VT，需配置一体机不使用 VT</li>
</ol>
<h1 id="文件验证报错"><a href="#文件验证报错" class="headerlink" title="文件验证报错"></a>文件验证报错</h1><h2 id="文件浏览用-smb-共享的方式无法访问"><a href="#文件浏览用-smb-共享的方式无法访问" class="headerlink" title="文件浏览用 smb 共享的方式无法访问"></a>文件浏览用 smb 共享的方式无法访问</h2><ol>
<li>查看能否在线访问</li>
<li>确认能否 telnet 灾备系统的 445 端口；如果不能，请检查防火墙</li>
<li>尝试其他的 windows 能否访问</li>
</ol>
<h2 id="XP-2003-系统浏览备份输入用户名和密码登录不了，提示输入用户名密码错误"><a href="#XP-2003-系统浏览备份输入用户名和密码登录不了，提示输入用户名密码错误" class="headerlink" title="XP/2003 系统浏览备份输入用户名和密码登录不了，提示输入用户名密码错误"></a>XP/2003 系统浏览备份输入用户名和密码登录不了，提示输入用户名密码错误</h2><ol>
<li>查看 XP/2003 的网络安全设置是否仅发 NTLM 响应</li>
<li>把 NTLM 改为 NTML2</li>
</ol>
<h1 id="如使用科力锐的同僚们还有遇到其它问题，欢迎联系博主进行追加，在此表示感谢！"><a href="#如使用科力锐的同僚们还有遇到其它问题，欢迎联系博主进行追加，在此表示感谢！" class="headerlink" title="如使用科力锐的同僚们还有遇到其它问题，欢迎联系博主进行追加，在此表示感谢！"></a>如使用科力锐的同僚们还有遇到其它问题，欢迎联系博主进行追加，在此表示感谢！</h1>]]></content>
      <categories>
        <category>Clerware</category>
      </categories>
      <tags>
        <tag>灾备</tag>
        <tag>智动全景灾备系统</tag>
        <tag>排错</tag>
      </tags>
  </entry>
  <entry>
    <title>Clerware System Administrator / 科力锐 系统管理员</title>
    <url>/Clerware/3.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是针对科力锐灾备一体机（clerware 智动全景灾备系统）<strong>系统管理员</strong>，也是平时灾备常用账号的操作文档，介绍了普通<strong>备份</strong>、<strong>验证</strong>、<strong>接管</strong>及<strong>恢复</strong>操作的流程，为博主的<strong>个人笔记</strong>，未必是正确操作，<strong>勿将其作为</strong><del>科力锐官方技术文档</del>，仅供参考！</p>
<div class="note warning"><p>本文针对的是 <strong>系统管理员</strong>，如需 <strong>超级管理员</strong> 相关操作，请参考 <a href="https://blog.hackme.cc/Clerware/2.html">《科力锐 超级管理员》</a></p>
</div>

<span id="more"></span>

<h1 id="确认源机位数"><a href="#确认源机位数" class="headerlink" title="确认源机位数"></a>确认源机位数</h1><p>&emsp;&emsp;针对 Linux，确认源机系统位数</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">arch</span></span><br></pre></td></tr></table></figure>

<h1 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a>下载客户端</h1><p>&emsp;&emsp;界面右上角“客户端下载”，选择相应位数，复制下载链接，回源机 wget 下载安装包</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">wget</span> （客户端下载链接）</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>若源机在公有云，选择被动连接，并在 设置 → 连接管理处 填入源机 IP</p>
</div>

<h1 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h1><p>&emsp;&emsp;待下载完成后，sh 命令安装</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh </span>（安装包）</span><br></pre></td></tr></table></figure>

<h1 id="查看源机是否在线"><a href="#查看源机是否在线" class="headerlink" title="查看源机是否在线"></a>查看源机是否在线</h1><p>&emsp;&emsp;安装完成后去灾备一体机，设置 → 客户端管理，查看源机是否在线</p>
<h1 id="开始备份"><a href="#开始备份" class="headerlink" title="开始备份"></a>开始备份</h1><p>&emsp;&emsp;备份 → 新建备份计划 → 开始配置</p>
<h2 id="备份数据空间自动回收设置"><a href="#备份数据空间自动回收设置" class="headerlink" title="备份数据空间自动回收设置"></a>备份数据空间自动回收设置</h2><p>&emsp;&emsp;有三个参数：备份数据保留期、存储空间配额下限、保留几个备份点，其中优先级最高的是<strong>保留几个备份点</strong>，如这一项未满足，则不会自动回收空间</p>
<h2 id="连续保护（CDP）工作模式"><a href="#连续保护（CDP）工作模式" class="headerlink" title="连续保护（CDP）工作模式"></a>连续保护（CDP）工作模式</h2><p>&emsp;&emsp;有两种模式：业务优先模式及数据优先模式，默认业务优先模式，对源机系统影响小于1%。但如果用户对数据的要求比较高，可选择数据优先模式，对源机业务系统的影响大于业务优先模式</p>
<h2 id="备份时资源占用设置"><a href="#备份时资源占用设置" class="headerlink" title="备份时资源占用设置"></a>备份时资源占用设置</h2><p>&emsp;&emsp;默认备份占用带宽 300M、占用源机 30% 的I/O性能、源存储读取队列深度为 4，可根据需要调整。</p>
<h2 id="备份区域设置"><a href="#备份区域设置" class="headerlink" title="备份区域设置"></a>备份区域设置</h2><p>&emsp;&emsp;可排除某一分区进行备份</p>
<h1 id="查看备份状态"><a href="#查看备份状态" class="headerlink" title="查看备份状态"></a>查看备份状态</h1><p>&emsp;&emsp;系统状态 → 选择源机的“更多”→ 详细，查看备份状态</p>
<h1 id="首次备份后验证"><a href="#首次备份后验证" class="headerlink" title="首次备份后验证"></a>首次备份后验证</h1><div class="note warning"><p>验证使用的是 20004 端口，注意是否开放</p>
</div>

<p>&emsp;&emsp;恢复 → 验证 → 选择刚才备份的源机 → 选择需要验证的备份点 → 选择验证类型</p>
<h2 id="文件验证"><a href="#文件验证" class="headerlink" title="文件验证"></a>文件验证</h2><p>&emsp;&emsp;以文件的方式进行验证，选择后会生成两种访问方式，一种是在线访问，另一种是通过资源管理器的地址栏进行访问，通过这种方式，可直接将备份点中的文件复制出来，进行验证。文件验证完成后，关闭访问链接，释放资源</p>
<div class="note primary"><p>当出现勒索病毒，无法确定何时感染时，可通过此文件验证方式来确定</p>
</div>

<h2 id="快速验证（直观验证）"><a href="#快速验证（直观验证）" class="headerlink" title="快速验证（直观验证）"></a>快速验证（直观验证）</h2><p>&emsp;&emsp;在灾备系统中拉起一个虚拟机，以模拟源机系统的形式来验证备份点</p>
<div class="note warning"><p>此种验证方式与接管不同，只作验证使用</p>
</div>

<h2 id="主机验证（一般不用）"><a href="#主机验证（一般不用）" class="headerlink" title="主机验证（一般不用）"></a>主机验证（一般不用）</h2><p>&emsp;&emsp;需准备一个目标机，以将将备份点恢复到目标机来进行全真模拟验证</p>
<div class="note warning"><p>此种验证方式与恢复不同，只作验证使用，验证主机不会与灾备系统建立连接</p>
</div>

<h1 id="验证成功后可进行恢复"><a href="#验证成功后可进行恢复" class="headerlink" title="验证成功后可进行恢复"></a>验证成功后可进行恢复</h1><p>&emsp;&emsp;准备一台硬件支持的目标机，安装 Agent 后，界面显示“正在等待管理员输入”，即可开始恢复操作</p>
<h1 id="接管功能"><a href="#接管功能" class="headerlink" title="接管功能"></a>接管功能</h1><p>&emsp;&emsp;接管 → 接管主机 → 新建 → 确定 → 选择源机 → 选择备份点 → 选择时间点 → 配置<br>&emsp;&emsp;设置CPU 及内存（至少不低于源机的30%），如只是做接管验证（同快速验证）则选择私有网络，如需接管业务系统，则配置网卡相应信息</p>
<div class="note info"><p>如接管已经非测试阶段，而是已经在接管用户业务系统，则需要新建备份计划，此备份会基于源机进行增量备份</p>
</div>]]></content>
      <categories>
        <category>Clerware</category>
      </categories>
      <tags>
        <tag>灾备</tag>
        <tag>智动全景灾备系统</tag>
        <tag>系统管理员</tag>
      </tags>
  </entry>
  <entry>
    <title>Comparison of iFLYTEK Mouse Parameters / 科大讯飞鼠标参数对比</title>
    <url>/Misc/4.html</url>
    <content><![CDATA[<p>&emsp;&emsp;贱内之鼠标卒，又听闻科大讯飞乃语音识别之翘楚，故欲购其语音识别鼠标。然百度参数对比，结果寥寥。后与客服求得一鼠标参数对比图，即速速转为此表，以供诸位参考。若有出入，还请以官方为准。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">型号</th>
<th align="center">M110</th>
<th align="center">M210</th>
<th align="center">Lite</th>
<th align="center">Lite-M320</th>
<th align="center">标准版</th>
<th align="center">Pro</th>
</tr>
</thead>
<tbody><tr>
<td align="center">官方售价（￥）</td>
<td align="center">129</td>
<td align="center">179</td>
<td align="center">299</td>
<td align="center">299</td>
<td align="center">399</td>
<td align="center">499</td>
</tr>
<tr>
<td align="center">净尺寸（mm）</td>
<td align="center">110×62×35</td>
<td align="center">123×67×41</td>
<td align="center">110×58×23</td>
<td align="center">110×58×23</td>
<td align="center">110×62×35</td>
<td align="center">125×70×43</td>
</tr>
<tr>
<td align="center">净重（g）</td>
<td align="center">86</td>
<td align="center">102</td>
<td align="center">60</td>
<td align="center">61</td>
<td align="center">85</td>
<td align="center">114</td>
</tr>
<tr>
<td align="center">双麦克风</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
</tr>
<tr>
<td align="center">离线语音输入</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
</tr>
<tr>
<td align="center">双设备切换</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">按键静音</td>
<td align="center">⭕</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">玻璃面上可用</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
</tr>
<tr>
<td align="center">语音录入支持方言</td>
<td align="center">23 种</td>
<td align="center">23 种</td>
<td align="center">24 种</td>
<td align="center">24 种</td>
<td align="center">24 种</td>
<td align="center">24 种</td>
</tr>
<tr>
<td align="center">语音录入支持外语</td>
<td align="center">仅英语</td>
<td align="center">仅英语</td>
<td align="center">66 种</td>
<td align="center">66 种</td>
<td align="center">66 种</td>
<td align="center">66 种</td>
</tr>
<tr>
<td align="center">翻译功能语种</td>
<td align="center">28 种</td>
<td align="center">28 种</td>
<td align="center">73 种</td>
<td align="center">73 种</td>
<td align="center">73 种</td>
<td align="center">73 种</td>
</tr>
<tr>
<td align="center">OCR 识别</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
</tr>
<tr>
<td align="center">划词翻译</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
</tr>
<tr>
<td align="center">音频转写</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
</tr>
<tr>
<td align="center">语音朗读</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
</tr>
<tr>
<td align="center">分辨率（挡）</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">滚轮材质</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">金属</td>
<td align="center">金属</td>
<td align="center">铝合金</td>
<td align="center">金属</td>
</tr>
<tr>
<td align="center">充电方式</td>
<td align="center">干电池</td>
<td align="center">USB Type C</td>
<td align="center">Micro USB</td>
<td align="center">USB Type C</td>
<td align="center">USB Type C</td>
<td align="center">USB Type C</td>
</tr>
<tr>
<td align="center">连续使用续航</td>
<td align="center">67 天</td>
<td align="center">39 天</td>
<td align="center">42 天</td>
<td align="center">46 天</td>
<td align="center">82 天</td>
<td align="center">64 天</td>
</tr>
<tr>
<td align="center">不使用语音续航</td>
<td align="center">183 天</td>
<td align="center">106 天</td>
<td align="center">115 天</td>
<td align="center">134 天</td>
<td align="center">229 天</td>
<td align="center">163 天</td>
</tr>
<tr>
<td align="center">待机续航</td>
<td align="center">341 天</td>
<td align="center">99 天</td>
<td align="center">234 天</td>
<td align="center">211 天</td>
<td align="center">333 天</td>
<td align="center">253 天</td>
</tr>
<tr>
<td align="center">支持 macOS</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">⭕</td>
<td align="center">❌</td>
<td align="center">⭕</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>iFLYTEK</tag>
        <tag>科大讯飞</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全等级保护 2.0 安全计算环境安全要求和安全管理制度体系</title>
    <url>/IT/11.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文选取了《网络安全等级测评师培训教材（初级）2019 版》中关于“安全计算环境”的部分安全要求及“安全管理制度体系”，结合公安部第三研究所对于初级测评师的培训课程，整理了如下知识点。只是博主的学习笔记，仅供学习交流，<strong>切勿作为</strong><del>官方标准</del>。</p>
<span id="more"></span>

<h1 id="安全计算环境-安全要求"><a href="#安全计算环境-安全要求" class="headerlink" title="安全计算环境 安全要求"></a>安全计算环境 安全要求</h1><h2 id="⁢身份鉴别"><a href="#⁢身份鉴别" class="headerlink" title="⁢身份鉴别"></a>⁢身份鉴别</h2><ol>
<li>应对登录的用户进行身份标识和鉴别，身份标识具有唯一性，身份鉴别信息具有复杂度要求并定期更换</li>
<li>应具有登录失败处理功能，应配置并启用结束会话、限制非法登录次数和当登录连接超时时自动退出等相关措施</li>
<li>当进行远程管理时，应采取必要措施，防止鉴别信息在网络传输过程中被窃听</li>
<li>应采用口令、密码技术、生物技术等两种或两种以上组合的鉴别技术对用户进行身份鉴别，且其中一种鉴别技术至少应使用密码技术来实现</li>
</ol>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ol>
<li>应对登录的用户分配账户和权限</li>
<li>应重命名或删除默认账户，修改默认账户的默认口令</li>
<li>应及时删除或停用多余的、过期的账户，避免共享账户的存在</li>
<li>应授予管理用户所需的最小权限，实现管理用户的权限分离</li>
<li>应由授权主体配置访问控制策略，访问控制策略规定主体对客体的访问规则</li>
<li>访问控制的粒度应达到主体为用户级或进程级，客体为文件、数据库表级</li>
<li>应对重要主体和客体设置安全标记，并控制主体对有安全标记信息资源的访问</li>
</ol>
<h2 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a>安全审计</h2><ol>
<li>应启用安全审计功能，审计覆盖到每个用户，对重要的用户行为和重要安全事件进行审计</li>
<li>日志审计内容需要记录时间、类型、用户、事件类型、事件是否成功及其他与审计相关的信息</li>
<li>应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等</li>
<li>应对审计进程进行保护，防止未经授权的中断</li>
</ol>
<h2 id="入侵防范"><a href="#入侵防范" class="headerlink" title="入侵防范"></a>入侵防范</h2><ol>
<li>应遵循最小安装的原则，仅安装需要的组件和应用程序</li>
<li>应关闭不需要的系统服务、默认共享和高危端口</li>
<li>应通过设定终端接入方式或网络地址范围对通过网络进行管理的管理终端进行限制</li>
<li>应提供数据有效性检验功能，保证通过人机接口输入或通过通信接口输入的内容符合系统设定要求</li>
<li>应能发现可能存在的已知漏洞，并在经过充分测试评估后，及时修补漏洞</li>
<li>应能够检测到对重要节点进行入侵的行为，并在发生严重入侵事件时提供报警</li>
</ol>
<h2 id="恶意代码防范"><a href="#恶意代码防范" class="headerlink" title="恶意代码防范"></a>恶意代码防范</h2><p>&emsp;&emsp;应采用免受恶意代码攻击的技术措施或主动免疫可信验证机制及时识别入侵和病毒行为，并将其有效阻断</p>
<h2 id="可信验证"><a href="#可信验证" class="headerlink" title="可信验证"></a>可信验证</h2><p>&emsp;&emsp;可基于可信根对计算设备的系统引导程序、系统程序、重要配置参数和应用程序等进行可信验证，并在应用程序的关键执行环节进行动态可信验证，在检测到其可信性受到破坏后进行报警，并将验证结果形成审计记录送至安全管理中心</p>
<h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><ol>
<li>应采用校验技术或密码技术保证重要数据在传输过程中的完整性，包括但不限于鉴别数据、重要业务数据、重要审计数据、重要配置数据、重要视频数据和重要个人信息等</li>
<li>应采用校验技术或密码技术保证重要数据在存储过程中的完整性，包括但不限于鉴别技术、重要业务数据、重要审计数据、重要配置数据、重要视频数据和重要个人信息等</li>
</ol>
<h2 id="数据备份恢复"><a href="#数据备份恢复" class="headerlink" title="数据备份恢复"></a>数据备份恢复</h2><ol>
<li>应提供重要数据的本地数据备份与恢复功能</li>
<li>应提供异地实时备份功能，利用通信网络将重要数据实时备份至备份场地</li>
<li>应提供重要数据处理系统的热冗余，保证系统的高可用性</li>
</ol>
<h1 id="安全管理制度体系"><a href="#安全管理制度体系" class="headerlink" title="安全管理制度体系"></a>安全管理制度体系</h1><ol>
<li>安全策略：阐明使命和意愿，明确安全总体目标、范围、原则和安全框架等，建立工作运行模式等</li>
<li>管理制度：对信息系统的建设、开发、运维升级和改造各个阶段和环节所应遵循的行为加以规范</li>
<li>操作规程：是各项具体活动的步骤和方法，可以是一个手册，一个流程表单或一个实施方法</li>
<li>记录表单：日常运维记录、审批记录、会议纪要等纪录类文档</li>
</ol>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>等保 2.0</tag>
        <tag>安全计算环境</tag>
        <tag>安全管理制度体系</tag>
      </tags>
  </entry>
  <entry>
    <title>EternalBlue / 永恒之蓝</title>
    <url>/Virus/1.html</url>
    <content><![CDATA[<p>&emsp;&emsp;博主在某医院发现了大量永恒之蓝病毒，所以记录下了一些“可视化”情况，用于简单鉴别计算机是否感染永恒之蓝并予以清除。</p>
<span id="more"></span>

<blockquote>
<p>永恒之蓝（英语：EternalBlue）是美国国家安全局开发的漏洞利用程序，于2017年4月14日被黑客组织影子掮客泄漏。该工具利用445/TCP端口的文件分享协议的漏洞进行散播。<br>尽管微软于2017年3月14日已经发布过Microsoft Windows补丁修补了这个漏洞，然而在5月12日WannaCry勒索软件利用这个漏洞传播时，很多用户仍然因为没有安装补丁而受害。<br>由于WannaCry的严重性，微软于2017年5月13日为已超过支持周期的Microsoft Windows XP、Microsoft Windows 8和Windows Server 2003发布了紧急安全更新，以阻止其散布造成更大的危害。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——<em>摘自 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUIwJUI4JUU2JTgxJTkyJUU0JUI5JThCJUU4JTkzJTlE">《维基百科》永恒之蓝 词条<i class="fa fa-external-link-alt"></i></span></em></p>
</blockquote>
<div class="note danger"><p>永恒之蓝手工很难清除，如有中毒迹象，请立即用<strong>杀毒软件</strong>进行查杀，并安装系统补丁！</p>
</div>

<h1 id="释放并运行永恒之蓝工具包"><a href="#释放并运行永恒之蓝工具包" class="headerlink" title="释放并运行永恒之蓝工具包"></a>释放并运行永恒之蓝工具包</h1><p>&emsp;&emsp;病毒首先会释放一个工具包，路径为</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">C:<span class="symbol">\W</span>indows<span class="symbol">\N</span>etworkDistribution</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此工具包会加载一个和系统默认进程一模一样的进程</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">svchost.exe     <span class="meta"># 通过查看进程文件路径就可发现非系统默认进程</span></span><br></pre></td></tr></table></figure>

<h1 id="不断生成并运行病毒文件"><a href="#不断生成并运行病毒文件" class="headerlink" title="不断生成并运行病毒文件"></a>不断生成并运行病毒文件</h1><p>&emsp;&emsp;此工具包会不断生成四个病毒文件并创建对应的进程，即使清除了，过段时间又会生成（所以需要杀毒软件进行彻底的查杀）</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">C:<span class="symbol">\W</span>indows<span class="symbol">\m</span>ssecsvc.exe</span><br><span class="line">C:<span class="symbol">\W</span>indows<span class="symbol">\m</span>ssecsvr.exe</span><br><span class="line">C:<span class="symbol">\W</span>indows<span class="symbol">\t</span>asksche.exe</span><br><span class="line">C:<span class="symbol">\W</span>indows<span class="symbol">\q</span>eriuwjhrf</span><br></pre></td></tr></table></figure>

<h1 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h1><h2 id="安装系统补丁"><a href="#安装系统补丁" class="headerlink" title="安装系统补丁"></a>安装系统补丁</h2><p>&emsp;&emsp;XP 系统对应微软补丁号：KB4012598<br>&emsp;&emsp;其余系统版本安装：KB4012215 或 KB4012212（二者安装上其一即可）</p>
<h2 id="安装杀毒软件"><a href="#安装杀毒软件" class="headerlink" title="安装杀毒软件"></a>安装杀毒软件</h2><p>&emsp;&emsp;除 Win10 有自带杀毒软件外，其余系统版本为了安全请安装杀毒软件，牺牲性能，保障安全！杀毒软件注意<strong>实时更新</strong>，并<strong>时常杀毒</strong>。</p>
<h2 id="关闭-139-及-445-端口"><a href="#关闭-139-及-445-端口" class="headerlink" title="关闭 139 及 445 端口"></a>关闭 139 及 445 端口</h2><p>&emsp;&emsp;除此之外如有条件，建议关闭 139 及 445 等这些高危端口。</p>
]]></content>
      <categories>
        <category>Virus</category>
      </categories>
      <tags>
        <tag>EternalBlue</tag>
        <tag>永恒之蓝</tag>
        <tag>蠕虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Everyone</title>
    <url>/Welfare/1.html</url>
    <content><![CDATA[<p>Hello everyone! Welcome come to <a href="https://blog.hackme.cc/">信安 - HACK ME</a>! This is my very post. Thank you for coming, reading, studying, or just passing by. I look forward to communicating with you to learn and progress together. You can leave your contact information in the comments section.</p>
<div class="note success"><p>最新福利政策：本文中的“小福利”，已追加至 <strong>3000元</strong>！详情请见文章内描述。</p>
</div>

<span id="more"></span>

<p>You can check <span class="exturl" data-url="aHR0cHM6Ly93d3cuaGFja21lLmNjLw==">HACK ME - 来打我呀<i class="fa fa-external-link-alt"></i></span> for more infomation. If you get any problems or questions when reading my posts, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==">Baidu<i class="fa fa-external-link-alt"></i></span> or you can contact me by clicking upper right corner. Of course, you can also click <span class="exturl" data-url="aHR0cDovL3dwYS5xcS5jb20vbXNncmQ/dj0zJnVpbj0zMTk5NzMxOTk3">here<i class="fa fa-external-link-alt"></i></span> to contact me via QQ. Or just click <span class="exturl" data-url="bWFpbHRvOjMxOTk3MzE5OTdAcXEuY29t">here<i class="fa fa-external-link-alt"></i></span> to contact me by email. If you happen to need to save time and want to improve your search efficiency, then you can use <span class="exturl" data-url="aHR0cHM6Ly9kYW8uaGFja21lLmNjLw==">this<i class="fa fa-external-link-alt"></i></span>. By the way, I may update everything very slowly, please forgive me. I need to work hard to feed myself first.</p>
<p>&emsp;&emsp;一切都要从一只蝙蝠说起……好了言归正传，“<a href="https://blog.hackme.cc/">信安 - HACK ME</a>”是一个IT类的个人博客，主要内容为<strong>信息安全</strong>的经验分享与技术交流。因为博主至爱信息安全，从成年起就立下了“<em>为我国信息安全事业奋斗终生</em>”的目标，力求在信息安全技术上不断提高，为我国信息安全建设添砖加瓦。创建这个博客就是想抛砖引玉，将自己在信息安全道路上的学习心得分享给初学者，同时向信息安全的前辈们取经，希望能早日到达西天，啊呸，到达信息安全的终极圣殿。</p>
<p>&emsp;&emsp;博主比较喜欢渗透测试，所以在此给各路大神提供一个<strong>小福利</strong>。只要能“攻入”<a href="https://blog.hackme.cc/">信安 - HACK ME</a> 的网站服务器，并且告知博主渗透过程，或者提供相应的《渗透测试报告》，<del>博主会给予<strong>100元</strong>的小奖金作为回报（求求大神们别看不起100元，这可是博主一星期的伙食费……😟）<strong>现已升级为 1000元</strong></del><strong>现已升级为 3000元</strong>。话不多说，开始“干”我吧！</p>
<p>&emsp;&emsp;最后还是希望所有信息安全的爱好者、学习者、从业者……都能光临寒舍，并且给予博主一些技术上的指导与支持，信息安全是我们共同的好友。祝所有来到或者路过本博客的朋友们，开心！😄</p>
<blockquote>
<p>呐，做人嘛，最重要的就是开心咯！</p>
</blockquote>
<div class="note primary"><p>为减少置顶文章，博主将名言警句板块与本文合并。以下所有内容除注明外皆取自于网络，不再进行来源的标注，如有侵权请联系删除！</p>
</div>

<ul>
<li>为爱而生，生而有趣 —— 博主人生信条</li>
<li>呐，做人嘛，最重要的就是开心咯 —— 博主座右铭</li>
<li>为中华而渗透！—— 博主墓志铭</li>
<li>我必须对信息安全负责 —— 博主工作态度</li>
<li>善攻者，敌不知其所守；善守者，敌不知其所攻 —— 博主工作目标</li>
<li>懒是万恶之源 —— My grandfather</li>
<li>能用钱解决的问题就不要想其它办法去解决 —— My father</li>
<li>所有的离开都是因为不够爱</li>
<li>谁都不知道明天和意外哪个先来</li>
<li>专业成就价值，价值决定价格 —— 平安祖训 + 供求关系</li>
<li>时间不语，却解答了所有问题</li>
<li>过得很好的表现之一，就是不用再向别人证明过得很好</li>
<li>Make learning a habit / 让学习成为一种习惯</li>
<li>我羡他人阳关道，他人羡我自逍遥 —— 博主 2020/06/30</li>
</ul>
]]></content>
      <categories>
        <category>Welfare</category>
      </categories>
      <tags>
        <tag>Misc</tag>
        <tag>信息安全</tag>
        <tag>小福利</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/Misc/0.html</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
  </entry>
  <entry>
    <title>Vulnerability Submission Instructions / 漏洞提交说明</title>
    <url>/Penetration-Test/1.html</url>
    <content><![CDATA[<p>&emsp;&emsp;为规范漏洞提交标准，提升效率，用此文对博客置顶文章 <a href="https://blog.hackme.cc/Welfare/1.html">《Hello Everyone》</a> <strong>邀请各路大神对本站进行渗透</strong>作漏洞提交的补充说明。</p>
<span id="more"></span>

<h1 id="一、重要提醒"><a href="#一、重要提醒" class="headerlink" title="一、重要提醒"></a>一、重要提醒</h1><h2 id="请特别注意漏洞的提交规范，否则会影响漏洞是否忽略、最终定级等判断。"><a href="#请特别注意漏洞的提交规范，否则会影响漏洞是否忽略、最终定级等判断。" class="headerlink" title="请特别注意漏洞的提交规范，否则会影响漏洞是否忽略、最终定级等判断。"></a>请特别注意漏洞的提交规范，否则会影响漏洞是否忽略、最终定级等判断。</h2><h2 id="漏洞评审规则"><a href="#漏洞评审规则" class="headerlink" title="漏洞评审规则"></a>漏洞评审规则</h2><p>&emsp;&emsp;初审（漏洞复现）→ 复审（漏洞定级，CVSS3.0）→ 漏洞报告质量审核</p>
<h2 id="漏洞接收原则"><a href="#漏洞接收原则" class="headerlink" title="漏洞接收原则"></a>漏洞接收原则</h2><ol>
<li>鼓励漏洞组合利用（特指低危、中危漏洞进行组合利用后，放大危害，提升至高危）；</li>
<li>鼓励多截图多证明漏洞危害性；</li>
<li>鼓励手动测试，深入研究漏洞利用；</li>
</ol>
<h2 id="敏感数据定义"><a href="#敏感数据定义" class="headerlink" title="敏感数据定义"></a>敏感数据定义</h2><p>&emsp;&emsp;敏感信息定义如下：行踪轨迹信息、通信内容、征信信息、财产信息、住宿信息、通信记录、健康生理信息、交易信息及其它用户信息泄露（姓名/身份证、银行卡信息、手机号/邮箱、密码、地址）</p>
<h1 id="二、漏洞提交填写说明"><a href="#二、漏洞提交填写说明" class="headerlink" title="二、漏洞提交填写说明"></a>二、漏洞提交填写说明</h1><h2 id="漏洞标题"><a href="#漏洞标题" class="headerlink" title="漏洞标题"></a>漏洞标题</h2><p>&emsp;&emsp;对于漏洞标题，需要注意区分此次<strong>提交漏洞数目</strong><br>&emsp;&emsp;统一提交格式: 【单一/组合】漏洞_【系统名字】【漏洞名称】</p>
<h3 id="单一漏洞提交"><a href="#单一漏洞提交" class="headerlink" title="单一漏洞提交"></a>单一漏洞提交</h3><p>&emsp;&emsp;如弱口令漏洞，可命名为：单一漏洞某系统弱口令漏洞<br>&emsp;&emsp;如 SQL 注入漏洞，可命名为：单一漏洞_网站前台 SQL 注入漏洞</p>
<h3 id="组合漏洞提交（必须证明漏洞关联性）"><a href="#组合漏洞提交（必须证明漏洞关联性）" class="headerlink" title="组合漏洞提交（必须证明漏洞关联性）"></a>组合漏洞提交（必须证明漏洞关联性）</h3><p>&emsp;&emsp;如后台 getshell，可命名为：组合漏洞某系统后台文件上传 getshell<br>&emsp;&emsp;如后台 SQL 注入，可命名为：组合漏洞某系统弱口令登入后台 SQL 注入<br>&emsp;&emsp;<strong>不接受无关联漏洞堆砌，如发现一律按提交漏洞中最低等级定级！</strong><br>&emsp;&emsp;<strong>组合漏洞不建议：多个高危漏洞组合提交，否则最终会仅按照一个高危评分。</strong></p>
<h2 id="漏洞资产（重要，必填）"><a href="#漏洞资产（重要，必填）" class="headerlink" title="漏洞资产（重要，必填）"></a>漏洞资产（重要，必填）</h2><p>&emsp;&emsp;选择系统中本次给出的目标资产。<br>&emsp;&emsp;注意：下方填写的【漏洞 url 位置】或【漏洞 IP】如果与此处<strong>不一致</strong>，务必在【复现步骤】中证明两者关联关系，<strong>必须保证系统为同一主体（同一单位），否则不接收</strong><br>&emsp;&emsp;例如：网站的前台和后台关系，可以接收，但是在目标资产上存在跳出页面，跳出页面主体为另一家单位，该漏洞不接收。<br>&emsp;&emsp;（此处纳入漏洞接收标准，<strong>初审</strong>有权对未在资产范围的漏洞，给予忽略处理）<br>&emsp;&emsp;忽略理由：该漏洞未在符合的资产范围内，不予以接收</p>
<h2 id="漏洞-url-位置（选填）"><a href="#漏洞-url-位置（选填）" class="headerlink" title="漏洞 url 位置（选填）"></a>漏洞 url 位置（选填）</h2><p>&emsp;&emsp;如果是 web 漏洞（对应 Web 资产），此处需填写具体的漏洞 url 地址，必填<br>&emsp;&emsp;此处填写的地址必须和漏洞复现中存在的漏洞地址保持一致<br>&emsp;&emsp;（此处纳入漏洞接收标准，<strong>初审</strong>有权对前后填写不一致的漏洞，给予忽略处理）<br>&emsp;&emsp;忽略理由：漏洞 url 填写地址与复现步骤涉及漏洞地址不一致，请确认后重新提交。</p>
<h2 id="漏洞-IP（选填）"><a href="#漏洞-IP（选填）" class="headerlink" title="漏洞 IP（选填）"></a>漏洞 IP（选填）</h2><p>&emsp;&emsp;如果是主机漏洞（对应 IP 资产），此处需要填写实际存在漏洞的ip地址，必填<br>此处填写的地址必须和漏洞复现中存在的漏洞地址保持一致<br>（此处纳入漏洞接收标准，<strong>初审</strong>有权对前后填写不一致的漏洞，给予忽略处理）<br>忽略理由：漏洞 ip 填写地址与复现步骤涉及漏洞地址不一致，请确认后重新提交。</p>
<h2 id="漏洞描述（重要，必填）"><a href="#漏洞描述（重要，必填）" class="headerlink" title="漏洞描述（重要，必填）"></a>漏洞描述（重要，必填）</h2><p>&emsp;&emsp;简要描述当前挖掘的漏洞类型，<strong>如实说明当前漏<br>洞危害性</strong>。（此处纳入报告质量考核，CVSS 漏洞危害评价，<strong>初审</strong>有权对未如实描述的漏洞危害，给予忽略处理）<br>&emsp;&emsp;例如：当前 xxx 后台管理系统存在弱口令漏洞，用户名: admin，密码: 123，攻击者利用该漏洞，可以造成5千多条系统内部用户数据泄露。<br>&emsp;&emsp;忽略理由：报告质量不佳，请补充 xxx 数据包后（根据实际情况填写欠缺点），重新提交。</p>
<h2 id="影响参数（选填）"><a href="#影响参数（选填）" class="headerlink" title="影响参数（选填）"></a>影响参数（选填）</h2><p>&emsp;&emsp;主要填写 url 参数，或者填写漏洞参数点<br>&emsp;&emsp;例如：SQL 注入下，填写注入点</p>
<h2 id="漏洞-POC-请求包（重要，必填）"><a href="#漏洞-POC-请求包（重要，必填）" class="headerlink" title="漏洞 POC 请求包（重要，必填）"></a>漏洞 POC 请求包（重要，必填）</h2><p>&emsp;&emsp;给出漏洞利用的数据包，要求为，凡是【复现步骤】里给出的 Burpsuite 或其他抓包工具抓到的数据包，必须填入此处，多个注意分割。（此处影响 CVSS 漏洞利用性评价， 初审有权对 SQL 注入未提交数据包的，直接给予忽略处理，其他情形需要裁判组进行定夺。）<br>&emsp;&emsp;例如: SQL 注入，填写整个数据包，**对于 sqlmap 自动化利用的可以在参数点打 *，同时绘出 sqlmap 命令。**其他漏洞可根据实际情况，进行填写<br>&emsp;&emsp;<strong>如用一些常用工具（github 能下载到）造成的漏洞利用</strong>，无法给出具体数据包，可不填写<br>&emsp;&emsp;忽略理由：SQL 注入未给出数据包，请重新提交漏洞。</p>
<h2 id="补充说明（选填）"><a href="#补充说明（选填）" class="headerlink" title="补充说明（选填）"></a>补充说明（选填）</h2><p>&emsp;&emsp;对于一些不是属于漏洞构成的内容可以填写<br>&emsp;&emsp;例如：这是对 xxxxx 编号漏洞的补充说明；这是对 xxxxx 编号弱口令漏洞的深入利用</p>
<h2 id="复现步骤（重要，必填）"><a href="#复现步骤（重要，必填）" class="headerlink" title="复现步骤（重要，必填）"></a>复现步骤（重要，必填）</h2><p>&emsp;&emsp;对于漏洞利用的详细步骤，此处注意，不要只给出图片，同时需要给出图片上的 url 地址。<br>&emsp;&emsp;Burpsuite 或其它抓包工具，抓到的数据包需在【漏洞 POC 请求包】中给出。（此处纳入报告质量考核，CVSS 漏洞危害评价）<br>&emsp;&emsp;<strong>注册用户使用的注册信息（用户名及密码）也需注意写入</strong></p>
<h2 id="修复方案（重要，必填）"><a href="#修复方案（重要，必填）" class="headerlink" title="修复方案（重要，必填）"></a>修复方案（重要，必填）</h2><p>&emsp;&emsp;对于漏洞的实际修复方案，注意格式规范（此处纳入报告质量考核）<br>&emsp;&emsp;例如：针对弱口令漏洞，建议系统管理员或系统维护人员对密码口令进行修改，口令强度进行硬性要求（建议长度 8 位，为大小写字母、数字和特殊字符的组合）。如果因系统硬件或软件版本问题造成密码无法修改，可通过 ACL 策略限制登陆服务器的 IP 地址和端口，以减小安全隐患爆发的概率。</p>
]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Vulnerability</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>I Must Be Responsible to Infomation Security / 我必须对信息安全负责</title>
    <url>/Misc/3.html</url>
    <content><![CDATA[<p>&emsp;&emsp;公司给我一个机会，让我有幸参加了一次苏州市委网络安全和信息化领导小组办公室陈雪嵘主任的宣讲活动。整个宣讲持续了很久，而且也很深入，涉及了包括“网络安全意识形态”等的重点问题。其中有一个“点”让我记忆深刻，概括起来就是——“我们每一个人都是战士，可能保卫的就是国家网络安全。”</p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>Information Security</tag>
        <tag>responsible</tag>
      </tags>
  </entry>
  <entry>
    <title>IOU Template / 借条模板</title>
    <url>/Welfare/4.html</url>
    <content><![CDATA[<p>&emsp;&emsp;这是博主向律师同学要到的最新借条模板。博主问别人借钱一定会写借条，日后如有好友向博主借钱，也请规范使用本借条模板（可向博主索要 word 版）。<br>&emsp;&emsp;写借条<strong>完全不能说明关系不够好</strong>，肯借钱就是关系好了。借钱写借条是理所应当的事，好友不要博主的借条，博主也会强制写，这是原则问题。</p>
<span id="more"></span>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><center>借条</center>

<p>&emsp;&emsp;为<u>【借款缘由】</u>，今收到<u>【出借人】</u>（身份证号：<u>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</u>）以<u>【出借方式】</u>出借的<u>人民币【x万x仟x佰x拾x元x角x分整】</u>（<u>￥【小写金额】元整）</u>，借期<u>【大写月份】</u>个月，月利率<u>【大写利率】</u>（<u>【小写利率】</u>），<u>【大写日期】</u>到期时本息一并还清。如到期未还清，愿按月利率<u>【大写利率】</u>（<u>【小写利率】</u>）计付逾期利息。立此为据。<br>&emsp;&emsp;如任何一方（借款人/债务人）违约，守约方（出借人/债权人）为维护权益向违约方追偿的一切费用（包括但不限于律师费、诉讼费、保全费、交通费、差旅费、鉴定费等）均由违约方承担。<br>&emsp;&emsp;身份证载明的双方（各方）通讯地址可作为送达催款函、对账单、法院诉讼文书的地址，因载明的地址有误或未及时告知变更后的地址，导致相关文书及诉讼文书未能实际被接收、邮寄送达的，相关文书及诉讼文书退回之日即视为送达之日。<br>&emsp;&emsp;借款人的<u>【手机/QQ/微信号等】</u>为：<u>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</u><br>&emsp;&emsp;借款人：<u>&emsp;&emsp;&emsp;&emsp;</u> 身份证号：<u>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</u></p>
<p align="right"><u>【大写】</u>年<u>【大写】</u>月<u>【大写】</u>日</p>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><center>借条</center>

<p>&emsp;&emsp;为<u>购置房产</u>，今收到<u>张三</u>（身份证号：<u>110000200001010000</u>）以<u>中国银行手机银行转账方式</u>出借的<u>人民币贰万叁仟肆佰陆拾柒元捌角玖分整</u>（<u>￥23467.89元整）</u>，借期<u>拾</u>个月，月利率<u>佰分之壹点伍</u>（<u>1.5%</u>），<u>贰零贰壹年叁月肆日</u>到期时本息一并还清。如到期未还清，愿按月利率<u>佰分之贰</u>（<u>2%</u>）计付逾期利息。立此为据。<br>&emsp;&emsp;如任何一方（借款人/债务人）违约，守约方（出借人/债权人）为维护权益向违约方追偿的一切费用（包括但不限于律师费、诉讼费、保全费、交通费、差旅费、鉴定费等）均由违约方承担。<br>&emsp;&emsp;身份证载明的双方（各方）通讯地址可作为送达催款函、对账单、法院诉讼文书的地址，因载明的地址有误或未及时告知变更后的地址，导致相关文书及诉讼文书未能实际被接收、邮寄送达的，相关文书及诉讼文书退回之日即视为送达之日。<br>&emsp;&emsp;借款人的<u>QQ号</u>为：<u>10001</u><br>&emsp;&emsp;借款人：<u>李四</u> 身份证号：<u>110000200001010019</u></p>
<p align="right"><u>贰零贰零</u>年<u>伍</u>月<u>肆</u>日</p>]]></content>
      <categories>
        <category>Welfare</category>
      </categories>
      <tags>
        <tag>IOU</tag>
        <tag>借条</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>IP Blocklist &amp; Allowlist Settings for Websites on Linux / Linux 网站 IP 允许/拒绝名单设置</title>
    <url>/IT/5.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文适用场景：网站使用 CDN，只允许 CDN 节点（即白名单）IP 地址/地址段，访问 http 网站，拒绝其它所有 IP 连接。</p>
<span id="more"></span>

<ol>
<li>安装 iptables 防火墙<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> iptables-services</span><br></pre></td></tr></table></figure></li>
<li>添加 CDN 节点 IP 白名单<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -s **IP 地址** -p TCP --dport <span class="number">80</span> -j ACCEPT     # 如需添加 C 段，用 “/<span class="number">24</span>” 表示子网掩码</span><br></pre></td></tr></table></figure></li>
<li>拒绝其它所有 IP 连接 80 端口<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">iptables -I <span class="keyword">INPUT</span> -p TCP <span class="comment">--dport 80 -j DROP</span></span><br></pre></td></tr></table></figure></li>
<li>保存 iptables 设置<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">service iptables save</span></span><br></pre></td></tr></table></figure></li>
<li>重启 iptables 服务<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl restart iptables</span></span><br></pre></td></tr></table></figure></li>
<li>设置开机自启<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> iptables</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Blocklist</tag>
        <tag>Allowlist</tag>
      </tags>
  </entry>
  <entry>
    <title>ofo Deposit Defund Policy / ofo 退押金策略</title>
    <url>/Misc/2.html</url>
    <content><![CDATA[<p>&emsp;&emsp;ofo 推出退押金排队系统，已经超 700 万人排队……<br>&emsp;&emsp;我给 ofo 出个主意，在这个排队页面做以下几个措施：</p>
<span id="more"></span>

<ol>
<li>在这个页面增加互动广告系统，用户每天可以点击五个广告，每点击一个排名提高 10 位排名；</li>
<li>增加 app 推荐位，推荐安装第三方 app，用户每下载一个 app 增加 100 位排名；</li>
<li>转发这个页面到朋友圈、微博等平台分别提高 10 位排名；</li>
<li>邀请好友一起来退押金，提升排名，邀请越多提高越快；</li>
<li>再开发个小游戏平台，用户玩小游戏可以提高 100 位排名，小游戏里面植入更多广告！</li>
</ol>
<p>&emsp;&emsp;根据我的推算，半年后，广告收入能抵消押金的退款速度，这样 ofo 立马转身为全国最大的互动广告平台，并且一举扭亏为盈！<br>&emsp;&emsp;而且后期可以加入赚钱系统，退完押金的用户还可以点击广告来赚钱，点击广告 0.1元/次，下载 app 5元/次，转发拉好友也可以赚钱！<br>&emsp;&emsp;如果你选择不退押金或者还不是 ofo 用户，充值 199，那么，你可以成为我们的会员，所有收益翻倍！</p>
<p>&emsp;&emsp;这是我在网上看到别人针对新浪新闻说 ofo 退押金要充值一万块的评论，这个创意真的是十分的秀，最后一句更甚。<br>&emsp;&emsp;最关键的是：<strong>如果所有人的排名都提前了，那就等于没提前</strong>，ofo 可以空手套白狼。</p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>ofo</tag>
        <tag>退押金</tag>
      </tags>
  </entry>
  <entry>
    <title>Penetration Testing Code of Conduct / 渗透测试行为准则</title>
    <url>/Penetration-Test/2.html</url>
    <content><![CDATA[<p>&emsp;&emsp;对本站进行渗透测试时，需遵守如下渗透测试行为准则</p>
<span id="more"></span>

<h1 id="信息系统机密性无害化验证指导场景"><a href="#信息系统机密性无害化验证指导场景" class="headerlink" title="信息系统机密性无害化验证指导场景"></a>信息系统机密性无害化验证指导场景</h1><ol>
<li>可实现非授权访问或越权访问，在进行非授权访问漏洞、越权漏洞验证时，不应访问超过 3 条敏感信息数据；</li>
<li>可执行数据库查询条件，在获得数据库实例、库表名称等信息证明时，不应查询超过 3 条敏感信息数据，严禁拖取数据库、表；</li>
<li>可获得系统主机、设备高权限，在获得当前用户系统环境权限证明后，不应再获取其他用户数据和业务数据信息；</li>
<li>在未申报通过的情况下禁止利用已获权限的主机或设备作为跳板机，对测试范围以外的目标进行渗透。</li>
</ol>
<h1 id="信息系统可用性无害化验证指导场景"><a href="#信息系统可用性无害化验证指导场景" class="headerlink" title="信息系统可用性无害化验证指导场景"></a>信息系统可用性无害化验证指导场景</h1><ol>
<li>执行操作前应充分估计目标网络、系统的性能冗余，不进行有可能导致目标网络、主机、设备瘫痪的大流量、高并发扫描，若因扫描导致系统拒绝服务，视为违规；</li>
<li>禁止执行可导致拒绝服务危害的漏洞验证用例；</li>
<li>禁止执行有可能导致业务紊乱、造成用户损失的漏洞验证用例。</li>
</ol>
<h1 id="信息系统完整性无害化验证指导场景"><a href="#信息系统完整性无害化验证指导场景" class="headerlink" title="信息系统完整性无害化验证指导场景"></a>信息系统完整性无害化验证指导场景</h1><ol>
<li>可获得信息系统后台功能操作权限，在完成角色、功能、权限等可控性证明后，不应再利用系统功能进行与测试无关的操作；</li>
<li>可获得系统主机、设备、数据库高权限，在获得相应的权限证明后，不应再对目标系统执行与测试无关的操作；</li>
<li>可在信息系统上传可解析、可执行内容，在完成漏洞证明后，不应遗留上传的内容，因故确实无法删除的，需在报告中明确描述，否则视为违规。</li>
</ol>
<h1 id="测试时需遵从国家、地方法律法规、行业惯例和社会公共道德，禁止利用平台提供的服务进行存储、发布、传播如下信息和内容"><a href="#测试时需遵从国家、地方法律法规、行业惯例和社会公共道德，禁止利用平台提供的服务进行存储、发布、传播如下信息和内容" class="headerlink" title="测试时需遵从国家、地方法律法规、行业惯例和社会公共道德，禁止利用平台提供的服务进行存储、发布、传播如下信息和内容"></a>测试时需遵从国家、地方法律法规、行业惯例和社会公共道德，禁止利用平台提供的服务进行存储、发布、传播如下信息和内容</h1><ol>
<li>违反国家法律法规政策的任何内容（信息）；</li>
<li>违反国家规定的政治宣传和/或新闻信息；</li>
<li>涉及国家秘密和/或安全的信息；</li>
<li>封建迷信和/或淫秽、色情、下流的信息或教唆犯罪的信息；</li>
<li>博彩有奖、赌博游戏；</li>
<li>违反国家民族和宗教政策的信息；</li>
<li>妨碍互联网运行安全的信息；</li>
<li>侵害他人合法权益的信息和/或其他有损于社会秩序、社会治安、公共道德的信息或内容；</li>
<li>测试者同时承诺不得为他人发布上述不符合国家规定和/或本协议条款约定的信息内容提供任何便利，包括但不限于设置 URL、BANNER 链接等。</li>
</ol>
<h1 id="漏洞提交问题"><a href="#漏洞提交问题" class="headerlink" title="漏洞提交问题"></a>漏洞提交问题</h1><ol>
<li>对于在平台提交的漏洞，测试者需要保证研究漏洞的方法、方式、工具及手段的合法性，平台对此不承担任何法律责任；</li>
<li>测试者不得因为漏洞信息、测试事由等私自联系被测单位；</li>
<li>在相应的安全保障措施未到位的情况下，严禁对安全性较差，较不稳定的系统进行漏洞验证；</li>
<li>测试者可以根据漏洞提交页面的相关指引，向平台提交可能导致应用程序数据丢失或篡改、隐私泄露、财务损失等安全漏洞信息，供平台工作人员以及相应漏洞被测单位审核和确认；</li>
<li>测试者必须基于诚信原则向平台提交漏洞信息，测试者同意并确保通过平台提交漏洞信息时，测试者是依据测试者自身所拥有的知识和技能，在公有领域通过合法正当的方式和途径发现该漏洞信息的存在，并没有采用窃取或任何不道德或非法的方式获得该等漏洞信息；简而言之，测试者能够对自身所提交的漏洞信息所包含的全部权利的合法性作出保证。</li>
<li>测试者不得出于任何非法目的而使用平台漏洞及平台漏洞提供的相关信息；</li>
<li>测试者不得利用平台进行任何可能对被测单位、互联网或移动网络正常运转造成不利影响的行为；</li>
<li>测试者不得利用平台提供的网络服务上传、展示或传播任何虚假的、骚扰性的、中伤他人的、辱骂性的、恐吓性的、庸俗淫秽的或其他任何非法的信息资料；</li>
<li>测试者不得侵犯其他任何第三方的专利权、著作权、商标权、名誉权或其他任何合法权益；</li>
<li>测试者不得利用平台网络服务系统进行任何不利于平台的行为；</li>
<li>测试者不得利用平台漏洞服务和网站相关信息从事以下活动：<ol>
<li>未经允许，进入计算机信息网络或者使用计算机信息网络资源；</li>
<li>未经允许，对计算机信息网络功能进行删除、修改或者增加；</li>
<li>未经允许，对进入计算机信息网络中存储、处理或者传输的数据和应用程序进行删除、修改或者增加；</li>
<li>故意制作、传播计算机病毒等破坏性程序；</li>
<li>其他危害计算机信息网络安全的行为。</li>
</ol>
</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li>若测试者使用的某项服务中包含可下载的平台软件，则平台仅授予测试者非独占性的、不可转让的、非商业运营目的的个人使用许可。除非平台另有明示或与测试者另有约定外，测试者不得复制、修改、发布、出售或出租服务或所含软件的任何部分，也不得进行反向工程或试图提取该软件的源代码。</li>
<li>测试者在报告漏洞时，应根据本协议第一条，提供可供漏洞报告平台、信息系统管理方、软硬件被测单位用于复现漏洞安全风险、审计技术验证行为的完整步骤信息。</li>
<li>在漏洞发现、报告和相关机构响应处置期间，测试者不应向其他无关机构和个人告知已获知的漏洞风险信息。</li>
<li>涉及影响广泛的漏洞信息验证时，禁止研究机构、个人编写和传播违反本协议第一条指导原则、带有破坏性功能的漏洞验证代码和工具。</li>
<li>测试者将承诺不向其他机构、个人提交或披露受到商业测试合同条款保护的漏洞验证信息；不向任何机构和个人公开披露受到知识产权保护的软硬件产品源代码信息。</li>
</ol>
]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Penetration Test</tag>
        <tag>渗透测试</tag>
        <tag>行为准则</tag>
      </tags>
  </entry>
  <entry>
    <title>First Week of Python Notes /【第1周笔记】Python 基本语法元素</title>
    <url>/Python/1.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL0JJVC0yNjgwMDE=">中国大学 MOOC《Python语言程序设计》<i class="fa fa-external-link-alt"></i></span> 《【第1周】Python 基本语法元素》课程笔记和选择题。</p>
<span id="more"></span>

<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#TempConvert.py</span></span><br><span class="line">TempStr = <span class="built_in">input</span>(<span class="string">&quot;请输入带有符号的温度值：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> TempStr[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;f&#x27;</span>]:</span><br><span class="line">    C = (<span class="built_in">eval</span>(TempStr[<span class="number">0</span>:<span class="number">-1</span>]) - <span class="number">32</span>)/<span class="number">1.8</span></span><br><span class="line">    print(<span class="string">&quot;转换后的温度是&#123;:.2f&#125;C&quot;</span>.<span class="built_in">format</span>(C))</span><br><span class="line"><span class="keyword">elif</span> TempStr[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">    F = <span class="number">1.8</span>*<span class="built_in">eval</span>(TempStr[<span class="number">0</span>:<span class="number">-1</span>]) + <span class="number">32</span></span><br><span class="line">    print(<span class="string">&quot;转换后的温度是&#123;:.2f&#125;F&quot;</span>.<span class="built_in">format</span>(F))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;输入格式错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Python 保留字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>as</td>
<td>创建别名</td>
</tr>
<tr>
<td>assert</td>
<td>用于调试</td>
</tr>
<tr>
<td>break</td>
<td>跳出循环</td>
</tr>
<tr>
<td>class</td>
<td>定义类</td>
</tr>
<tr>
<td>continue</td>
<td>继续循环的下一个迭代</td>
</tr>
<tr>
<td>def</td>
<td>定义函数</td>
</tr>
<tr>
<td>del</td>
<td>删除对象</td>
</tr>
<tr>
<td>elif</td>
<td>在条件语句中使用，等同于 else if</td>
</tr>
<tr>
<td>else</td>
<td>用于条件语句</td>
</tr>
<tr>
<td>except</td>
<td>处理异常，发生异常时如何执行</td>
</tr>
<tr>
<td>False</td>
<td>布尔值，比较运算的结果</td>
</tr>
<tr>
<td>finally</td>
<td>处理异常，无论是否存在异常，都将执行一段代码</td>
</tr>
<tr>
<td>for</td>
<td>创建 for 循环</td>
</tr>
<tr>
<td>from</td>
<td>导入模块的特定部分</td>
</tr>
<tr>
<td>global</td>
<td>声明全局变量</td>
</tr>
<tr>
<td>if</td>
<td>写一个条件语句</td>
</tr>
<tr>
<td>import</td>
<td>导入模块</td>
</tr>
<tr>
<td>in</td>
<td>检查列表、元组等集合中是否存在某个值</td>
</tr>
<tr>
<td>is</td>
<td>测试两个变量是否相等</td>
</tr>
<tr>
<td>lambda</td>
<td>创建匿名函数</td>
</tr>
<tr>
<td>None</td>
<td>表示 null 值</td>
</tr>
<tr>
<td>nonlocal</td>
<td>声明非局部变量</td>
</tr>
<tr>
<td>not</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>or</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>pass</td>
<td>null 语句，一条什么都不做的语句</td>
</tr>
<tr>
<td>raise</td>
<td>产生异常</td>
</tr>
<tr>
<td>return</td>
<td>退出函数并返回值</td>
</tr>
<tr>
<td>True</td>
<td>布尔值，比较运算的结果</td>
</tr>
<tr>
<td>try</td>
<td>编写 try…except 语句</td>
</tr>
<tr>
<td>while</td>
<td>创建 while 循环</td>
</tr>
<tr>
<td>with</td>
<td>用于简化异常处理</td>
</tr>
<tr>
<td>yield</td>
<td>结束函数，返回生成器</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;上表摘自：<span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3B5dGhvbi9weXRob25fcmVmX2tleXdvcmRzLmFzcA==">W3school Python 关键字<i class="fa fa-external-link-alt"></i></span></p>
<table>
<thead>
<tr>
<th>Python 数据类型</th>
<th>10,011,101</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>10011101</td>
</tr>
<tr>
<td>字符串类型</td>
<td>“10,011,101”</td>
</tr>
<tr>
<td>列表类型</td>
<td>[10, 011, 101]</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;字符串的序号：正向递增序号从 0 开始，反向递减序号从 -1 开始</p>
<div class="note info"><p>&lt;字符串&gt;[M: N]：表示字符串的切片为 [M,N) 即<strong>不包括</strong> N</p>
</div>

<p>&emsp;&emsp;整数和浮点数都是数字类型</p>
<p>&emsp;&emsp;列表类型：由0个或多个数据组成的有序序列</p>
<p>&emsp;&emsp;列表使用保留字 in 判断一个元素是否在列表中</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">TempStr</span><span class="selector-attr">[-1]</span> <span class="selector-tag">in</span> <span class="selector-attr">[<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span>     # 判断前者（字符串的最后一位）是否与列表 <span class="selector-attr">[<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span> 中某个元素（大写 <span class="selector-tag">C</span> 或小写 <span class="selector-tag">c</span>）相同</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;eval()：去掉参数最外侧引号并执行余下语句的函数（最常用是将字符串转换为数字）</p>
<h1 id="测验-1"><a href="#测验-1" class="headerlink" title="测验 1"></a>测验 1</h1><ol>
<li>Guido van Rossum正式对外发布Python版本的年份是：A<br>A. 1991<br>B. 1998<br>C. 2008<br>D. 2002<ul>
<li>【解析】Python成功了，所以早年的开发历史也受到关注，以下是Guido自述的启动阶段时间表：<br>“<br>December, 1989 Implementation started<br>1990 Internal releases at CWI<br>February 20, 1991 0.9.0 (released to alt.sources)<br>February, 1991 0.9.1<br>“<br>鉴于Internal release不算对外发布，普遍认为Python语言诞生于1991年。</li>
</ul>
</li>
<li>以下关于Python语言中“缩进”说法正确的是：D<br>A. 缩进可以用在任何语句之后，表示语句间的包含关系<br>B. 缩进统一为4个空格<br>C. 缩进是非强制的，仅为了提高代码可读性<br>D. 缩进在程序中长度统一且强制使用<ul>
<li>【解析】Python语言的缩进只要统一即可，不一定是4个空格（尽管这是惯例）。</li>
</ul>
</li>
<li>以下不属于IPO模型的是：C<br>A. Input<br>B. Process<br>C. Program<br>D. Output<ul>
<li>【解析】IPO：Input Process Output</li>
</ul>
</li>
<li>字符串是一个字符序列，给字符串s，以下表示s从右侧向左第三个字符的是：D<br>A. s[3]<br>B. s[0:-3]<br>C. s[:-3]<br>D. s[-3]<ul>
<li>【解析】字符串有正向递增和反向递减两套序号体系</li>
</ul>
</li>
<li>以下不是Python语言合法命名的是：C<br>A. MyGod5<br>B. <em>MyGod</em><br>C. 5MyGod<br>D. MyGod<ul>
<li>【解析】合法命名的首字符不能是数字。</li>
</ul>
</li>
<li>在Python中，用于获取用户输入的函数是：C<br>A. eval()<br>B. get()<br>C. input()<br>D. print()<ul>
<li>【解析】get()不是Python内置函数，获得用户输入只有一种方式：input()。</li>
</ul>
</li>
<li>下面不属于Python保留字的是：D<br>A. import<br>B. elif<br>C. def<br>D. type<ul>
<li>【解析】type不是Python保留字，而是内置函数 type()。</li>
</ul>
</li>
<li>以下不是Python数据类型的是：C<br>A. 列表<br>B. 整数<br>C. 实数<br>D. 字符串<ul>
<li>【解析】实数是数学中的概念，在Python中对应浮点数。</li>
</ul>
</li>
<li>哪个选项给出的保留字不直接用于表示分支结构？A<br>A. in<br>B. if<br>C. else<br>D. elif<ul>
<li>【解析】if-elif-else是分支表达，in用来进行成员判断。</li>
</ul>
</li>
<li>利用print()格式化输出，哪个选项用于控制浮点数的小数点后两位输出？C<br>A. {.2f}<br>B. {:.2}<br>C. {:.2f}<br>D. {.2}<ul>
<li>【解析】:.2f  哪一个都不能少</li>
</ul>
</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Python/2.html">《Second Week of Python Notes /【第2周笔记】Python 基本图形绘制》</a></p>
</div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>温度转换</tag>
        <tag>保留字</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>First Week of Python Programs /【第1周程序】Python 基本语法元素</title>
    <url>/Python/11.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL0JJVC0yNjgwMDE=">中国大学 MOOC《Python语言程序设计》<i class="fa fa-external-link-alt"></i></span> 《【第1周】Python 基本语法元素》程序设计练习题和考试题。</p>
<span id="more"></span>

<h1 id="温度转换"><a href="#温度转换" class="headerlink" title="温度转换"></a>温度转换</h1><p>这是”实例”题，与课上讲解实例相同，请作答检验学习效果。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>温度的刻画有两个不同体系：摄氏度（Celsius）和华氏度（Fahrenheit）。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>请编写程序将用户输入华氏度转换为摄氏度，或将输入的摄氏度转换为华氏度。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>转换算法如下：（C表示摄氏度、F表示华氏度）‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>C = ( F - 32 ) / 1.8‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>F = C * 1.8 + 32‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>要求如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬</p>
<ol>
<li>输入输出的摄氏度可采用大小写字母C结尾，温度可以是整数或小数，如：12.34C指摄氏度12.34度；</li>
<li>输入输出的华氏度可采用大小写字母F结尾，温度可以是整数或小数，如：87.65F指华氏度87.65度；</li>
<li>输出保留小数点后两位，输入格式错误时，输出提示：输入格式错误；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬</li>
<li>使用input()获得测试用例输入时，不要增加提示字符串。</li>
</ol>
<div class="tabs" id="first-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#first-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#first-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li><li class="tab"><a href="#first-unique-name-3"><i class="fa fa-thumbs-up"></i>最优解</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#TempConvert.py</span></span><br><span class="line">TempStr = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> TempStr[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]:</span><br><span class="line">    C = (<span class="built_in">eval</span>(TempStr[<span class="number">0</span>:<span class="number">-1</span>]) - <span class="number">32</span>)/<span class="number">1.8</span></span><br><span class="line">    print(<span class="string">&quot;&#123;:.2f&#125;C&quot;</span>.<span class="built_in">format</span>(C))</span><br><span class="line"><span class="keyword">elif</span> TempStr[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">    F = <span class="number">1.8</span>*<span class="built_in">eval</span>(TempStr[<span class="number">0</span>:<span class="number">-1</span>]) + <span class="number">32</span></span><br><span class="line">    print(<span class="string">&quot;&#123;:.2f&#125;F&quot;</span>.<span class="built_in">format</span>(F))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;输入格式错误&quot;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="first-unique-name-2"><ol>
<li>将输入字符串转换为数字时使用eval()函数，不要用int()函数，因为输入的数字可能不是整数；</li>
<li>采用{:.2f}将输出数字变成两位小数点表示时，即使数学上该输出值是整数，也会按照小数方式输出，例如，转换后温度为10度，输出为10.00。</li>
</ol></div><div class="tab-pane" id="first-unique-name-3"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> T[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;f&#x27;</span>]:</span><br><span class="line">    print(<span class="string">&#x27;&#123;:.2f&#125;C&#x27;</span>.<span class="built_in">format</span>((<span class="built_in">eval</span>(T[<span class="number">0</span>:<span class="number">-1</span>])<span class="number">-32</span>)/<span class="number">1.8</span>))</span><br><span class="line"><span class="keyword">elif</span> T[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">    print(<span class="string">&#x27;&#123;:.2f&#125;F&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(T[<span class="number">0</span>:<span class="number">-1</span>])*<span class="number">1.8</span>+ <span class="number">32</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;输入格式错误&#x27;</span>)</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="Hello-World-I"><a href="#Hello-World-I" class="headerlink" title="Hello World I"></a>Hello World I</h1><p>这是学习每种程序设计语言的第一个实例。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>输出Hello World，注意大小写。</p>
<div class="tabs" id="second-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#second-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-unique-name-1"><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&#x27;Hello World&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="数字形式转换-I"><a href="#数字形式转换-I" class="headerlink" title="数字形式转换 I"></a>数字形式转换 I</h1><p>获得用户输入的一个正整数输入，输出该数字对应的中文字符表示。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>0到9对应的中文字符分别是：零一二三四五六七八九</p>
<div class="tabs" id="third-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#third-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#third-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li></ul><div class="tab-content"><div class="tab-pane active" id="third-unique-name-1"><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> = <span class="string">&quot;零一二三四五六七八九&quot;</span></span><br><span class="line"></span><br><span class="line">s = input()</span><br><span class="line"><span class="keyword">for</span> c in s:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">template</span>[eval(c)], <span class="built_in">end</span>=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="third-unique-name-2"><p>print()中增加end=””参数表示输出后不增加换行，多个print()可以连续输出。</p></div></div></div>

<h1 id="温度转换-II"><a href="#温度转换-II" class="headerlink" title="温度转换 II"></a>温度转换 II</h1><p>温度的刻画有两个不同体系：摄氏度（Celsius）和华氏度（Fahrenheit）。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>请编写程序将用户输入华氏度转换为摄氏度，或将输入的摄氏度转换为华氏度。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>转换算法如下：（C表示摄氏度、F表示华氏度）‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>C = ( F - 32 ) / 1.8‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>F = C * 1.8 + 32‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>要求如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬</p>
<ol>
<li>输入输出的摄氏度采用大写字母C开头，温度可以是整数或小数，如：C12.34指摄氏度12.34度；</li>
<li>输入输出的华氏度采用大写字母F开头，温度可以是整数或小数，如：F87.65指华氏度87.65度；</li>
<li>不考虑异常输入的问题，输出保留小数点后两位；</li>
<li>使用input()获得测试用例输入时，不要增加提示字符串。</li>
</ol>
<div class="tabs" id="fourth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fourth-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#fourth-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li><li class="tab"><a href="#fourth-unique-name-3"><i class="fa fa-thumbs-up"></i>最优解</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-unique-name-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#TempConvert.py</span></span><br><span class="line">TempStr = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> TempStr[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;F&#x27;</span>]:</span><br><span class="line">    C = (<span class="built_in">eval</span>(TempStr[<span class="number">1</span>:]) - <span class="number">32</span>)/<span class="number">1.8</span></span><br><span class="line">    print(<span class="string">&quot;C&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(C))</span><br><span class="line"><span class="keyword">elif</span> TempStr[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;C&#x27;</span>]:</span><br><span class="line">    F = <span class="number">1.8</span>*<span class="built_in">eval</span>(TempStr[<span class="number">1</span>:]) + <span class="number">32</span></span><br><span class="line">    print(<span class="string">&quot;F&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(F))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print() <span class="comment">#不输入任何错误提示</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="fourth-unique-name-2"><p>这个实例扩展自实例1，请注意以下三点：</p>
<ol>
<li>将输入字符串转换为数字时使用eval()函数，不要用int()函数，因为输入的数字可能不是整数；</li>
<li>采用{:.2f}将输出数字变成两位小数点表示时，即使数学上该输出值是整数，也会按照小数方式输出，例如，转换后温度为10度，输出为10.00；</li>
<li>TempStr[1:]表示字符串除首字符外的所有字符。</li>
</ol></div><div class="tab-pane" id="fourth-unique-name-3"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T=<span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> T[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;f&#x27;</span>]:</span><br><span class="line">    print(<span class="string">&#x27;C&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>((<span class="built_in">eval</span>(T[<span class="number">1</span>:])<span class="number">-32</span>)/<span class="number">1.8</span>))</span><br><span class="line"><span class="keyword">elif</span> T[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">    print(<span class="string">&#x27;F&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(T[<span class="number">1</span>:])*<span class="number">1.8</span>+<span class="number">32</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="货币转换-I"><a href="#货币转换-I" class="headerlink" title="货币转换 I"></a>货币转换 I</h1><p>人民币和美元是世界上通用的两种货币之一，写一个程序进行货币间币值转换，其中：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>人民币和美元间汇率固定为：1美元 = 6.78人民币。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>程序可以接受人民币或美元输入，转换为美元或人民币输出。人民币采用RMB表示，美元USD表示，符号和数值之间没有空格。<br>‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪注意：</p>
<ol>
<li>这是一个OJ题目，获得输入请使用input()；</li>
<li>不提示输出格式错误，结果小数点后保留两位。</li>
</ol>
<div class="tabs" id="fifth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fifth-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#fifth-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-unique-name-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CurStr = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> CurStr[:<span class="number">3</span>] == <span class="string">&quot;RMB&quot;</span>:</span><br><span class="line">    print(<span class="string">&quot;USD&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(CurStr[<span class="number">3</span>:])/<span class="number">6.78</span>))</span><br><span class="line"><span class="keyword">elif</span> CurStr[:<span class="number">3</span>] <span class="keyword">in</span> [<span class="string">&#x27;USD&#x27;</span>]:</span><br><span class="line">    print(<span class="string">&quot;RMB&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(CurStr[<span class="number">3</span>:])*<span class="number">6.78</span>))</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="fifth-unique-name-2"><p>这个代码是实例1的一个扩展，注意以下3点：</p>
<ol>
<li>eval()函数将字符串转换成数字，不能省略；</li>
<li>== 表示 “等于”，in 表示成员包含，对于这个题目，由于只允许输入采用全大写方式，两种方法均可；</li>
<li>:.2f输出小数点后两位。</li>
</ol></div></div></div>

<h1 id="Hello-World的条件输出"><a href="#Hello-World的条件输出" class="headerlink" title="Hello World的条件输出"></a>Hello World的条件输出</h1><p>获得用户输入的一个整数，参考该整数值，打印输出”Hello World”，要求：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>如果输入值是0，直接输出”Hello World”‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>如果输入值大于0，以两个字符一行方式输出”Hello World”（空格也是字符）‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>如果输入值小于0，以垂直方式输出”Hello World”</p>
<div class="tabs" id="sixth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#sixth-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-unique-name-1"><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">n</span> = <span class="function"><span class="title">eval</span>(<span class="title">input</span>())</span></span><br><span class="line"><span class="variable"><span class="keyword">if</span></span> <span class="variable">n</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span></span><br><span class="line"><span class="variable">elif</span> <span class="variable">n</span> &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">&quot;He\nll\no \nWo\nrl\nd&quot;</span>)</span></span><br><span class="line"><span class="variable"><span class="keyword">else</span></span>:</span><br><span class="line">    <span class="variable">for</span> <span class="variable">c</span> <span class="variable"><span class="keyword">in</span></span> <span class="string">&quot;Hello World&quot;</span>:</span><br><span class="line">        <span class="function"><span class="title">print</span>(<span class="variable">c</span>)</span></span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h1><p>获得用户输入的一个字符串，格式如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>M OP N‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>其中，M和N是任何数字，OP代表一种操作，表示为如下四种：+, -, *, /（加减乘除）‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>根据OP，输出M OP N的运算结果，统一保存小数点后2位。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>注意：M和OP、OP和N之间可以存在多个空格，不考虑输入错误情况。</p>
<div class="tabs" id="seventh-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#seventh-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#seventh-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li><li class="tab"><a href="#seventh-unique-name-3"><i class="fa fa-thumbs-up"></i>最优解</a></li></ul><div class="tab-content"><div class="tab-pane active" id="seventh-unique-name-1"><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">s = input()</span><br><span class="line">print(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>.format(<span class="name">eval</span>(<span class="name">s</span>)))</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="seventh-unique-name-2"><p>体会eval()函数的作用，在编程中用处很大。</p></div><div class="tab-pane" id="seventh-unique-name-3"><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>.format(<span class="name">eval</span>(<span class="name">input</span>())))</span><br></pre></td></tr></table></figure></div></div></div>

<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Python/12.html">《Second Week of Python Programs /【第2周程序】Python 基本图形绘制》</a></p>
</div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Program</tag>
      </tags>
  </entry>
  <entry>
    <title>Third Week of Python Notes /【第3周笔记】Python 基本数据类型</title>
    <url>/Python/3.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL0JJVC0yNjgwMDE=">中国大学 MOOC《Python语言程序设计》<i class="fa fa-external-link-alt"></i></span> 《【第3周】Python 基本数据类型》课程笔记和选择题。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Python/2.html">《Second Week of Python Notes /【第2周笔记】Python 基本图形绘制》</a></p>
</div>

<span id="more"></span>

<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>&emsp;&emsp;与数学中整数的概念一致，可正可负，<strong>没有取值范围限制</strong></p>
<p>&emsp;&emsp;pow(x,y) 函数：计算 $x^y$ ，想算多大算多大</p>
<table>
<thead>
<tr>
<th>四种进制</th>
<th>表现形式</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>十进制</td>
<td>直接表示</td>
<td>1010，99，-217</td>
</tr>
<tr>
<td>二进制</td>
<td>以 0b 或 0B 开头</td>
<td>0b010，-0B101</td>
</tr>
<tr>
<td>八进制</td>
<td>以 0o 或 0O 开头</td>
<td>0o123，-0O456</td>
</tr>
<tr>
<td>十六进制</td>
<td>以 0x 或 0X 开头</td>
<td>0x9a，-0X89</td>
</tr>
</tbody></table>
<h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>&emsp;&emsp;取值范围数量级约 $ -10^{307} $ 到 $ 10^{308} $ ，精度数量级 $ 10^{-16} $</p>
<div class="note danger"><p>注意：浮点数间运算存在不确定尾数，不是 bug</p>
</div>

<p>&emsp;&emsp;round(x, d)：对 x 四舍五入，d 是小数截取位数</p>
<p>&emsp;&emsp;浮点数间运算与比较用 round() 函数辅助</p>
<p>&emsp;&emsp;不确定尾数一般发生在 $10^{-16}$ 左右，round() 十分有效</p>
<p>&emsp;&emsp;浮点数可以采用科学计数法表示，如 aeb：表示 $ a×10^b $</p>
<p>&emsp;&emsp;例如：4.3e-3 值为 0.0043，9.6E5 值为 960000.0</p>
<h2 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h2><p>&emsp;&emsp;复数实例：z = 1.23e-4+5.6e+89j，z.real 获得实部，z.imag 获得虚部</p>
<h2 id="数字类型的关系"><a href="#数字类型的关系" class="headerlink" title="数字类型的关系"></a>数字类型的关系</h2><p>&emsp;&emsp;类型间可进行混合运算，生成结果为“最宽”类型，三种类型存在一种逐渐“扩展”或“变宽”的关系：整数 → 浮点数 → 复数，例如：123+4.0=127.0（整数+浮点数=浮点数)</p>
<table>
<thead>
<tr>
<th>数值运算函数</th>
<th>描述</th>
<th>举例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>abs(x)</td>
<td>绝对值，x 的绝对值</td>
<td>abs(-10.01)</td>
<td>10.01</td>
</tr>
<tr>
<td>divmod(x,y)</td>
<td>商余（x//y，x%y）同时输出商和余数</td>
<td>divmod(10, 3)</td>
<td>(3, 1)</td>
</tr>
<tr>
<td>pow(x, y[, z])</td>
<td>幂余，(x**y)%z，参数 z 可省略</td>
<td>pow(3, pow(3, 99), 10000)</td>
<td>4587</td>
</tr>
<tr>
<td>round(x[, d])</td>
<td>四舍五入，d 是保留小数位数，默认值为 0</td>
<td>round(-10.123, 2)</td>
<td>-10.12</td>
</tr>
<tr>
<td>max( $x_1,x_2, … ,x_n$ )</td>
<td>最大值，返回 $x_1,x_2, … ,x_n$ 中的最大值，n 不限</td>
<td>max(1, 9, 5, 4, 3)</td>
<td>9</td>
</tr>
<tr>
<td>min( $x_1,x_2, … ,x_n$ )</td>
<td>最小值，返回 $x_1,x_2, … ,x_n$ 中的最小值，n 不限</td>
<td>min(1, 9, 5, 4, 3)</td>
<td>1</td>
</tr>
<tr>
<td>int(x)</td>
<td>将 x 变成整数，舍弃小数部分</td>
<td>int(123.45) 或 int(“123”)</td>
<td>123</td>
</tr>
<tr>
<td>float(x)</td>
<td>将 x 变成浮点数，增加小数部分</td>
<td>float(12)</td>
<td>12.0</td>
</tr>
<tr>
<td>complex(x)</td>
<td>将 x 变成复数，增加虚数部分</td>
<td>complex(4)</td>
<td>4 + 0j</td>
</tr>
</tbody></table>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>&emsp;&emsp;字符串有两类共四种表示方法：一对单引号、一对双引号、一对单双引号、一对三单或三双引号（表示多行字符串）</p>
<p>&emsp;&emsp;x in s：如果 x 是 s 的子串，返回 True，否则返回 False</p>
<table>
<thead>
<tr>
<th>字符串处理函数</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>len(x)</td>
<td>长度，返回字符串 x 的长度</td>
<td>len(“一二三456”) 结果为 6</td>
</tr>
<tr>
<td>str(x)</td>
<td>任意类型 x 所对应的字符串形式</td>
<td>str(1.23) 结果为 “1.23”，str([1,2]) 结果为 “[1,2]”</td>
</tr>
<tr>
<td>hex(x) 或 oct(x)</td>
<td>整数x的十六进制或八进制<strong>小写</strong>形式字符串</td>
<td>hex(425) 结果为 “0x1a9”，oct(425) 结果为 “0o651”</td>
</tr>
<tr>
<td>chr(u)</td>
<td>x 为 Unicode 编码，返回其对应的字符</td>
<td></td>
</tr>
<tr>
<td>ord(x)</td>
<td>x 为字符，返回其对应的 Unicode 编码</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字符串处理方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>str.lower() 或 str.upper()</td>
<td>返回字符串的副本，全部字符小写/大写</td>
</tr>
<tr>
<td>str.split(sep=None)</td>
<td>返回一个列表，由 str 根据 sep 被分隔的部分组成</td>
</tr>
<tr>
<td>str.count(sub)</td>
<td>返回子串 sub 在 str 中出现的次数</td>
</tr>
<tr>
<td>str.replace(old, new)</td>
<td>返回字符串 str 副本，所有 old 子串被替换为 new</td>
</tr>
<tr>
<td>str.center(width[,fillchar])</td>
<td>字符串 str 根据宽度 width 居中，fillchar 可选</td>
</tr>
<tr>
<td>str.strip(chars)</td>
<td>从 str 中去掉在其左侧和右侧 chars 中列出的字符</td>
</tr>
<tr>
<td>str.join(iter)</td>
<td>在 iter 变量除最后元素外每个元素后增加一个 str</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>举例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>“AbCdEfGh”.lower()</td>
<td>“abcdefgh”</td>
</tr>
<tr>
<td>“A,B,C”.split(“,”)</td>
<td>[‘A’,’B’,’C’]</td>
</tr>
<tr>
<td>“an apple a day”.count(“a”)</td>
<td>4</td>
</tr>
<tr>
<td>“python”.replace(“n”,”n123.io”)</td>
<td>“python123.io”</td>
</tr>
<tr>
<td>“python”.center(20,”=”)</td>
<td>‘=======python=======’</td>
</tr>
<tr>
<td>“= python= “.strip(“ =np”)</td>
<td>“ytho”</td>
</tr>
<tr>
<td>“,”.join(“12345”)</td>
<td>“1,2,3,4,5” #主要用于字符串分隔等</td>
</tr>
</tbody></table>
<h2 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h2><p>&emsp;&emsp;统一字符编码，即覆盖几乎所有字符的编码方式</p>
<p>&emsp;&emsp;从 0 到 1114111（0x10FFFF）空间，每个编码对应一个字符</p>
<p>&emsp;&emsp;Python 字符串中每个字符都是 Unicode 编码字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    print(<span class="built_in">chr</span>(<span class="number">9800</span>+i),end=<span class="string">&quot;&quot;</span>)     <span class="comment"># 输出从星座（9800 是白羊）开始的特殊符号</span></span><br></pre></td></tr></table></figure>

<div class="pdf-container" data-target="https://www.hackme.cc/source/format方法的格式控制.pdf" data-height="500px"></div>

<h2 id="time-库"><a href="#time-库" class="headerlink" title="time 库"></a>time 库</h2><p>time 库是 Python 中处理时间的标准库</p>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><table>
<thead>
<tr>
<th>时间获取函数</th>
<th>描述</th>
<th>用法</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>time()</td>
<td>获取当前时间戳，即计算机内部时间值，浮点数</td>
<td>time.time()</td>
<td>1516939876.6022282</td>
</tr>
<tr>
<td>ctime()</td>
<td>获取当前时间并以易读方式表示，返回字符串</td>
<td>time.ctime()</td>
<td>‘Fri Jan 26 12:11:16 2018’</td>
</tr>
<tr>
<td>gmtime()</td>
<td>获取当前时间，表示为计算机可处理的时间格式</td>
<td>time.gmtime()</td>
<td>time.struct_time(tm_year=2018, tm_mon=1,……, tm_yday=26, tm_isdst=0)</td>
</tr>
</tbody></table>
<h3 id="时间格式化函数"><a href="#时间格式化函数" class="headerlink" title="时间格式化函数"></a>时间格式化函数</h3><ol>
<li>strftime(tpl, ts)<ol>
<li>tpl 是格式化模板字符串，用来定义输出效果</li>
<li>ts 是计算机内部时间类型变量<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;t = time.gmtime()</span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,t)</span><br><span class="line"><span class="string">&#x27;2018-01-26 12:55:20&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>strptime(str, tpl)<ol>
<li>str 是字符串形式的时间值</li>
<li>tpl 是格式化模板字符串，用来定义输入效果<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;timeStr = <span class="string">&#x27;2018-01-26 12:55:20&#x27;</span></span><br><span class="line">&gt;&gt;&gt;time.strptime(timeStr, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">time.struct_time(<span class="attribute">tm_year</span>=2018, <span class="attribute">tm_mon</span>=1, <span class="attribute">tm_mday</span>=26, <span class="attribute">tm_hour</span>=4, <span class="attribute">tm_min</span>=11, <span class="attribute">tm_sec</span>=16, <span class="attribute">tm_wday</span>=4, <span class="attribute">tm_yday</span>=26, <span class="attribute">tm_isdst</span>=0)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p><img data-src="https://www.hackme.cc/source/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96.webp" alt="时间格式化.webp"></p>
<table>
<thead>
<tr>
<th>格式化控制符</th>
<th>日期/时间说明</th>
<th>值范围</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>%Y</td>
<td>年份</td>
<td>0000~9999</td>
<td>1900</td>
</tr>
<tr>
<td>%m</td>
<td>月份</td>
<td>01~12</td>
<td>10</td>
</tr>
<tr>
<td>%B</td>
<td>月份名称</td>
<td>January~December</td>
<td>April</td>
</tr>
<tr>
<td>%b</td>
<td>月份名称缩写</td>
<td>Jan~Dec</td>
<td>Apr</td>
</tr>
<tr>
<td>%d</td>
<td>日期</td>
<td>01~31</td>
<td>25</td>
</tr>
<tr>
<td>%A</td>
<td>星期</td>
<td>Monday~Sunday</td>
<td>Wednesday</td>
</tr>
<tr>
<td>%a</td>
<td>星期缩写</td>
<td>Mon~Sun</td>
<td>Wed</td>
</tr>
<tr>
<td>%H</td>
<td>小时（24h 制）</td>
<td>00~23</td>
<td>12</td>
</tr>
<tr>
<td>%I</td>
<td>小时（12h 制）</td>
<td>01~12</td>
<td>7</td>
</tr>
<tr>
<td>%p</td>
<td>上/下午</td>
<td>AM, PM</td>
<td>PM</td>
</tr>
<tr>
<td>%M</td>
<td>分钟</td>
<td>00~59</td>
<td>26</td>
</tr>
<tr>
<td>%S</td>
<td>秒</td>
<td>00~59</td>
<td>26</td>
</tr>
</tbody></table>
<h3 id="程序计时"><a href="#程序计时" class="headerlink" title="程序计时"></a>程序计时</h3><ol>
<li>perf_counter()<ol>
<li>返回一个 CPU 级别的精确时间计数值，单位为秒</li>
<li>由于这个计数值起点不确定，<strong>连续调用差值才有意义</strong><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt;start = time.perf_counter()</span><br><span class="line"><span class="number">318.66599499718114</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;end = time.perf_counter()</span><br><span class="line"><span class="number">341.3905185375658</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;end - start</span><br><span class="line"><span class="number">22.724523540384666</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>sleep(s)：s 拟休眠的时间，单位是秒，可以是浮点数 <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt;<span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">time.sleep(<span class="number">3.3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;wait()     <span class="comment">#程序将等待 3.3 秒后再退出</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="测验-3"><a href="#测验-3" class="headerlink" title="测验 3"></a>测验 3</h1><ol>
<li>pow(x, 0.5)能够计算x的平方根，计算负数的平方根将产生：D‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬<br>A. 无输出<br>B. ValueError错误<br>C. 程序崩溃<br>D. 复数 <figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(<span class="number">-1</span>, <span class="number">0.5</span>)</span><br><span class="line">(<span class="number">6.123233995736766e-17</span>+<span class="number">1</span>j)</span><br></pre></td></tr></table></figure></li>
<li>以下关于字符串.strip()方法功能说明正确的是：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬D<br>A. 替换字符串中特定字符<br>B. 连接两个字符串序列<br>C. 按照指定字符分割字符串为数组<br>D. 去掉字符串两侧指定字符<ul>
<li>“去掉字符串两侧指定字符”对应功能是.strip()</li>
<li>“按照指定字符分割字符串为数组”对应功能是.split()</li>
<li>“替换字符串中特定字符”对应功能是.replace()</li>
<li>“连接两个字符串序列”对应功能是+操作符</li>
</ul>
</li>
<li>字符串是一个连续的字符序列，哪个选项可以实现打印字符信息的换行？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬C<br>A. 使用“\换行”<br>B. 使用空格<br>C. 使用\n<br>D. 使用转义符\<ul>
<li>换行符\n，与C语言中一致。</li>
</ul>
</li>
<li>val=pow(2,1000)，请用一行代码返回val结果的长度值。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬D<br>A. len(val)<br>B. 其他答案均不正确<br>C. len(pow(2,1000))<br>D. len(str(val))<ul>
<li>len(str(val))首先通过str(val)将数字类型val变成字符串，再通过len()获得字符串长度，即val的数字个数。</li>
</ul>
</li>
<li>下面关于time库引用不正确的是？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬C<br>A. from time import *<br>B. from time import strftime<br>C. from * import time<br>D. import time<ul>
<li>from * import time 应该是： from time import *</li>
</ul>
</li>
<li>哪个选项不是Python语言的整数类型？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬D<br>A. 88<br>B. 0x9a<br>C. 0B1010<br>D. 0E99<ul>
<li>十进制：一般表示</li>
<li>二进制：0b 或 0B 开头</li>
<li>八进制：0o 或 0O 开头</li>
<li>十六进制：0x 或 0X 开头</li>
<li>没有0E开头</li>
</ul>
</li>
<li>关于整数类型的4种进制表示，哪个选项的描述是正确的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬C<br>A. 二进制、四进制、十进制、十六进制<br>B. 二进制、四进制、八进制、十六进制<br>C. 二进制、八进制、十进制、十六进制<br>D. 二进制、四进制、八进制、十进制<ul>
<li>Python不支持四进制整数</li>
</ul>
</li>
<li>哪个选项是Python语言%运算符的含义？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬D<br>A. x与y之商<br>B. x的y次幂<br>C. x与y的整数商<br>D. x与y之商的余数<ul>
<li>%是取余数，与C语言相同。</li>
</ul>
</li>
<li>哪个选项是下面代码的执行结果？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬A<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">name</span>=<span class="string">&quot;Python语言程序设计课程&quot;</span></span><br><span class="line"><span class="attribute">print</span>(name[<span class="number">0</span>],name[<span class="number">2</span>:-<span class="number">2</span>],name[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪A. P thon语言程序设计 程<br>B. P thon语言程序设计课 课<br>C. P thon语言程序设计课 程<br>D. P thon语言程序设计 课<ul>
<li>s[N:M]表示对字符串s的切片操作，从N到M，但不包含M</li>
</ul>
</li>
<li>哪个选项是下面代码的执行结果？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬D<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">s</span>=<span class="string">&#x27;PYTHON&#x27;</span></span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">&quot;&#123;0:3&#125;&quot;</span>.format(s))</span><br></pre></td></tr></table></figure>
A. PYTHON<br>B. PYT<br>C. PYTH<br>D. PYTHON<ul>
<li>{0:3}表示输出的宽度是3，但如果字符串超过长度3，则以字符串长度显示。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>time</tag>
        <tag>文本进度条</tag>
      </tags>
  </entry>
  <entry>
    <title>Second Week of Python Programs /【第2周程序】Python 基本图形绘制</title>
    <url>/Python/12.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL0JJVC0yNjgwMDE=">中国大学 MOOC《Python语言程序设计》<i class="fa fa-external-link-alt"></i></span> 《【第2周】Python 基本图形绘制》程序设计练习题和考试题。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Python/11.html">《First Week of Python Programs /【第1周程序】Python 基本语法元素》</a></p>
</div>

<span id="more"></span>

<h1 id="Python蟒蛇绘制"><a href="#Python蟒蛇绘制" class="headerlink" title="Python蟒蛇绘制"></a>Python蟒蛇绘制</h1><p>这是”实例”题，与课上讲解实例相同，请作答检验学习效果。<br>‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪使用turtle库，绘制一个蟒蛇形状的图形。</p>
<div class="tabs" id="first-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#first-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#first-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PythonDraw.py</span></span><br><span class="line"><span class="attribute">import</span> turtle</span><br><span class="line"><span class="attribute">turtle</span>.setup(<span class="number">650</span>, <span class="number">350</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"><span class="attribute">turtle</span>.penup()</span><br><span class="line"><span class="attribute">turtle</span>.fd(-<span class="number">250</span>)</span><br><span class="line"><span class="attribute">turtle</span>.pendown()</span><br><span class="line"><span class="attribute">turtle</span>.pensize(<span class="number">25</span>)</span><br><span class="line"><span class="attribute">turtle</span>.pencolor(<span class="string">&quot;purple&quot;</span>)</span><br><span class="line"><span class="attribute">turtle</span>.seth(-<span class="number">40</span>)</span><br><span class="line"><span class="attribute">for</span> i in range(<span class="number">4</span>):</span><br><span class="line">    <span class="attribute">turtle</span>.circle(<span class="number">40</span>, <span class="number">80</span>)</span><br><span class="line">    <span class="attribute">turtle</span>.circle(-<span class="number">40</span>, <span class="number">80</span>)</span><br><span class="line"><span class="attribute">turtle</span>.circle(<span class="number">40</span>, <span class="number">80</span>/<span class="number">2</span>)</span><br><span class="line"><span class="attribute">turtle</span>.fd(<span class="number">40</span>)</span><br><span class="line"><span class="attribute">turtle</span>.circle(<span class="number">16</span>, <span class="number">180</span>)</span><br><span class="line"><span class="attribute">turtle</span>.fd(<span class="number">40</span> * <span class="number">2</span>/<span class="number">3</span>)</span><br><span class="line"><span class="attribute">turtle</span>.done()</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="first-unique-name-2"><p>实例2全代码，请注意：这里面的数值经过适应输出的调整。</p></div></div></div>

<h1 id="turtle正方形绘制"><a href="#turtle正方形绘制" class="headerlink" title="turtle正方形绘制"></a>turtle正方形绘制</h1><p>使用turtle库，绘制一个正方形。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬</p>
<div class="tabs" id="second-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#second-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-unique-name-1"><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#RectDraw.py</span><br><span class="line"><span class="keyword">import</span> turtle as t</span><br><span class="line">t.pensize(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    t.fd(<span class="number">150</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="turtle六边形绘制"><a href="#turtle六边形绘制" class="headerlink" title="turtle六边形绘制"></a>turtle六边形绘制</h1><p>使用turtle库，绘制一个六边形。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬</p>
<div class="tabs" id="third-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#third-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#third-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li></ul><div class="tab-content"><div class="tab-pane active" id="third-unique-name-1"><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#HexagonDraw.py</span><br><span class="line"><span class="keyword">import</span> turtle as t</span><br><span class="line">t.pensize(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    t.fd(<span class="number">150</span>)</span><br><span class="line">    t.left(<span class="number">60</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="third-unique-name-2"><p>fd(x)函数的参数可以任意设置，决定了六边形的大小。</p></div></div></div>

<h1 id="turtle叠边形绘制"><a href="#turtle叠边形绘制" class="headerlink" title="turtle叠边形绘制"></a>turtle叠边形绘制</h1><p>使用turtle库，绘制一个叠边形，其中，叠边形内角为100度。</p>
<div class="tabs" id="fourth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fourth-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#fourth-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-unique-name-1"><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#TwoRoundDraw.py</span><br><span class="line"><span class="keyword">import</span> turtle as t</span><br><span class="line">t.pensize(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    t.fd(<span class="number">150</span>)</span><br><span class="line">    t.left(<span class="number">80</span>)  #<span class="number">720</span>/<span class="number">9</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="fourth-unique-name-2"><p>一共9条边，共2圈，每次左转角度为80度（720/9）。</p></div></div></div>

<h1 id="turtle风轮绘制"><a href="#turtle风轮绘制" class="headerlink" title="turtle风轮绘制"></a>turtle风轮绘制</h1><p>使用turtle库，绘制一个风轮效果，其中，每个风轮内角为45度，风轮边长150像素。<br>提示：turtle.goto(x,y)函数，能够将turtle画笔移动到坐标(x,y)</p>
<div class="tabs" id="fifth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fifth-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-unique-name-1"><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#WindWheel.py</span><br><span class="line"><span class="keyword">import</span> turtle as t</span><br><span class="line">t.pensize(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    t.seth(<span class="number">90</span>*i)</span><br><span class="line">    t.fd(<span class="number">150</span>)</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.circle(<span class="number">-150</span>, <span class="number">45</span>)</span><br><span class="line">    t.goto(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="turtle八边形绘制"><a href="#turtle八边形绘制" class="headerlink" title="turtle八边形绘制"></a>turtle八边形绘制</h1><p>使用turtle库，绘制一个八边形。</p>
<div class="tabs" id="sixth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#sixth-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-unique-name-1"><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#OctagonDraw.py</span><br><span class="line"><span class="keyword">import</span> turtle as t</span><br><span class="line">t.pensize(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    t.fd(<span class="number">100</span>)</span><br><span class="line">    t.left(<span class="number">45</span>)</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="turtle八角图形绘制"><a href="#turtle八角图形绘制" class="headerlink" title="turtle八角图形绘制"></a>turtle八角图形绘制</h1><p>使用turtle库，绘制一个八角图形。</p>
<div class="tabs" id="seventh-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#seventh-unique-name-1"><i class="fa fa-code"></i>参考代码</a></li><li class="tab"><a href="#seventh-unique-name-2"><i class="fa fa-question"></i>答案解析</a></li></ul><div class="tab-content"><div class="tab-pane active" id="seventh-unique-name-1"><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle as t</span><br><span class="line">t.pensize(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    t.fd(<span class="number">150</span>)</span><br><span class="line">    t.left(<span class="number">135</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="seventh-unique-name-2"><p>计算循环和角度的乘积，应该为360的整数倍。</p></div></div></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Program</tag>
      </tags>
  </entry>
  <entry>
    <title>Second Week of Python Notes /【第2周笔记】Python 基本图形绘制</title>
    <url>/Python/2.html</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL0JJVC0yNjgwMDE=">中国大学 MOOC《Python语言程序设计》<i class="fa fa-external-link-alt"></i></span> 《【第2周】Python 基本图形绘制》课程笔记和选择题。</p>
<div class="note info"><p>上一节课程：<a href="https://blog.hackme.cc/Python/1.html">《First Week of Python Notes /【第1周笔记】Python 基本语法元素》</a></p>
</div>

<span id="more"></span>

<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PythonDraw.py</span></span><br><span class="line"><span class="attribute">import</span> turtle</span><br><span class="line"><span class="attribute">turtle</span>.setup(<span class="number">650</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line"><span class="attribute">turtle</span>.penup()</span><br><span class="line"><span class="attribute">turtle</span>.fd(-<span class="number">250</span>)</span><br><span class="line"><span class="attribute">turtle</span>.pendown()</span><br><span class="line"><span class="attribute">turtle</span>.pensize(<span class="number">25</span>)</span><br><span class="line"><span class="attribute">turtle</span>.pencolor(<span class="string">&quot;purple&quot;</span>)</span><br><span class="line"><span class="attribute">turtle</span>.seth(-<span class="number">40</span>)</span><br><span class="line"><span class="attribute">for</span> i in range(<span class="number">4</span>):</span><br><span class="line">    <span class="attribute">turtle</span>.circle(<span class="number">40</span>,<span class="number">80</span>)</span><br><span class="line">    <span class="attribute">turtle</span>.circle(-<span class="number">40</span>,<span class="number">80</span>)</span><br><span class="line"><span class="attribute">turtle</span>.circle(<span class="number">40</span>,<span class="number">80</span>/<span class="number">2</span>)</span><br><span class="line"><span class="attribute">turtle</span>.fd(<span class="number">40</span>)</span><br><span class="line"><span class="attribute">turtle</span>.circle(<span class="number">16</span>,<span class="number">180</span>)</span><br><span class="line"><span class="attribute">turtle</span>.fd(<span class="number">40</span>*<span class="number">2</span>/<span class="number">3</span>)</span><br><span class="line"><span class="attribute">turtle</span>.done()</span><br></pre></td></tr></table></figure>

<p>turtle（海龟）库是 Python 语言的<strong>标准库</strong>之一</p>
<p><img data-src="https://www.hackme.cc/source/turtle%E7%BB%98%E5%9B%BE%E7%AA%97%E4%BD%93.webp" alt="turtle绘图窗体.webp"></p>
<table>
<thead>
<tr>
<th align="center">英文名称</th>
<th align="center">RGB 整数值</th>
<th align="center">RGB 小数值</th>
<th align="center">中文名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">white</td>
<td align="center">255，255，255</td>
<td align="center">1，1，1</td>
<td align="center">白色</td>
</tr>
<tr>
<td align="center">yellow</td>
<td align="center">255，255，0</td>
<td align="center">1，1，0</td>
<td align="center">黄色</td>
</tr>
<tr>
<td align="center">megenta</td>
<td align="center">255，0，255</td>
<td align="center">1，0，1</td>
<td align="center">洋红</td>
</tr>
<tr>
<td align="center">cyan</td>
<td align="center">0，255，255</td>
<td align="center">0，1，1</td>
<td align="center">青色</td>
</tr>
<tr>
<td align="center">blue</td>
<td align="center">0，0，255</td>
<td align="center">0，0，1</td>
<td align="center">蓝色</td>
</tr>
<tr>
<td align="center">black</td>
<td align="center">0，0，0</td>
<td align="center">0，0，0</td>
<td align="center">黑色</td>
</tr>
<tr>
<td align="center">seashell</td>
<td align="center">255，245，238</td>
<td align="center">1，0.96，0.93</td>
<td align="center">海贝色</td>
</tr>
<tr>
<td align="center">gold</td>
<td align="center">255，215，0</td>
<td align="center">1，0.84，0</td>
<td align="center">金色</td>
</tr>
<tr>
<td align="center">pink</td>
<td align="center">255，192，203</td>
<td align="center">1，0.75，0.80</td>
<td align="center">粉红色</td>
</tr>
<tr>
<td align="center">brown</td>
<td align="center">165，42，42</td>
<td align="center">0.65，0.16，0.16</td>
<td align="center">棕色</td>
</tr>
<tr>
<td align="center">purple</td>
<td align="center">160，32，240</td>
<td align="center">0.63，0.13，0.94</td>
<td align="center">紫色</td>
</tr>
<tr>
<td align="center">tomato</td>
<td align="center">255，99，71</td>
<td align="center">1，0.39，0.28</td>
<td align="center">番茄色</td>
</tr>
</tbody></table>
<h2 id="turtle-画笔控制函数"><a href="#turtle-画笔控制函数" class="headerlink" title="turtle 画笔控制函数"></a>turtle 画笔控制函数</h2><p>&emsp;&emsp;画笔操作后一直有效，一般成对出现</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">别名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">turtle.penup()</td>
<td align="center">turtle.pu()</td>
<td align="center">抬起画笔，海龟在飞行</td>
</tr>
<tr>
<td align="center">turtle.pendown()</td>
<td align="center">turtle.pd()</td>
<td align="center">落下画笔，海龟在爬行</td>
</tr>
<tr>
<td align="center">turtle.pensize(width)</td>
<td align="center">turtle.width(width)</td>
<td align="center">画笔宽度，海龟的腰围</td>
</tr>
<tr>
<td align="center">turtle.pencolor(color)</td>
<td align="center">-</td>
<td align="center">画笔颜色，海龟在涂装</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>pencolor(color)</th>
<th>color 三种形式</th>
</tr>
</thead>
<tbody><tr>
<td>颜色字符串</td>
<td>turtle.pencolor(“purple”)</td>
</tr>
<tr>
<td>RGB的小数值</td>
<td>turtle.pencolor(0.63, 0.13, 0.94)</td>
</tr>
<tr>
<td>RGB的元组值</td>
<td>turtle.pencolor((0.63,0.13,0.94))</td>
</tr>
</tbody></table>
<h2 id="turtle-运动控制函数"><a href="#turtle-运动控制函数" class="headerlink" title="turtle 运动控制函数"></a>turtle 运动控制函数</h2><p>&emsp;&emsp;控制海龟行进：走直线 &amp; 走曲线</p>
<p>&emsp;&emsp;画笔设置后一直有效，直至下次重新设置</p>
<ol>
<li>turtle.forward(d)<ol>
<li>别名：turtle.fd(d)</li>
<li>向前行进，海龟走直线</li>
<li>d：行进距离，可以为负数</li>
</ol>
</li>
<li>turtle.circle(r, extent=None)<ol>
<li>根据半径 r 绘制 extent 角度的弧形</li>
<li>r：默认圆心在海龟左侧 r 距离的位置</li>
<li>extent：绘制角度，默认是 360 度整圆</li>
</ol>
</li>
</ol>
<h2 id="turtle-方向控制函数"><a href="#turtle-方向控制函数" class="headerlink" title="turtle 方向控制函数"></a>turtle 方向控制函数</h2><p>&emsp;&emsp;控制海龟面对方向：绝对角度 &amp; 海龟角度</p>
<ol>
<li>turtle.setheading(angle)<ol>
<li>别名：turtle.seth(angle)</li>
<li>改变行进方向，海龟走角度</li>
<li>angle：行进方向的绝对角度</li>
</ol>
</li>
<li>turtle.left(angle)：海龟向左转（angle：在海龟当前行进方向上旋转的角度）</li>
<li>turtle.right(angle)：海龟向右转（angle：在海龟当前行进方向上旋转的角度）</li>
</ol>
<p>range(N)：产生 0 到 N-1 的整数序列，共 N 个<br>range(M,N)：产生 M 到 N-1 的整数序列，共 N-M 个</p>
<h1 id="测验-2"><a href="#测验-2" class="headerlink" title="测验 2"></a>测验 2</h1><ol>
<li>哪个选项不能正确引用turtle库进而使用setup()函数？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬D<br>A. from turtle import*<br>B. import turtle as t<br>C. import turtle<br>D. import setup from turtle<ul>
<li>import只有三种使用方法，以turtle库为例：<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="title">from</span> turtle <span class="keyword">import</span> setup   或  from turtle <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t  （其中t是别名，可以更换其他名称）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>关于turtle库，哪个选项的描述是错误的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬D<br>A. turtle库是一个直观有趣的图形绘制函数库<br>B. turtle绘图体系以水平右侧为绝对方位的0度<br>C. turtle库最早成功应用于LOGO编程语言<br>D. turtle坐标系的原点默认在屏幕左上角<ul>
<li>turtle坐标系的原点默认在窗体正中间</li>
</ul>
</li>
<li>哪个选项是turtle绘图中角度坐标系的绝对0度方向？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬A<br>A. 画布正右方<br>B. 画布正左方<br>C. 画布正上方<br>D. 画布正下方<ul>
<li>坐标系类似这样，角度坐标系的绝对0度方向是右侧</li>
</ul>
</li>
<li>哪个选项是下面代码的执行结果？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬B<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">turtle.circle(<span class="number">-90</span>,<span class="number">90</span>)</span><br></pre></td></tr></table></figure>
‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪A. 绘制一个半径为90像素的整圆形<br>B. 绘制一个半径为90像素的弧形，圆心在小海龟当前行进的右侧<br>C. 绘制一个半径为90像素的弧形，圆心在小海龟当前行进的左侧<br>D. 绘制一个半径为90像素的弧形，圆心在画布正中心<ul>
<li>circle(x, y) 表示 以x长度为半径，y为角度，当前方向左侧x出为圆心，画圆。其中x和y都可以是负数，相应取反。</li>
</ul>
</li>
<li>关于turtle库绘图函数，哪个选项的描述是错误的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬C<br>A. turtle.pensize(size)函数的作用是改变画笔的宽度为size像素<br>B. turtle.fd(distance)函数的作用是向小海龟当前行进方向前进distance距离<br>C. turtle.circle(radius, extent=None)函数的作用是绘制一个椭圆形，extent参数可选<br>D. turtle.seth(to_angle)函数的作用是设置小海龟当前行进方向为to_angle，to_angle是角度的整数值<ul>
<li>circle()函数不能绘制椭圆形。</li>
</ul>
</li>
<li>关于turtle库的画笔控制函数，哪个选项的描述是错误的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬B<br>A. turtle.width()和turtle.pensize()都可以用来设置画笔尺寸<br>B. turtle.pendown()作用是落下画笔，并移动画笔绘制一个点<br>C. turtle.penup()的别名有turtle.pu(),turtle.up()<br>D. turtle.colormode()的作用是设置画笔RGB颜色的表示模式<ul>
<li>turtle.pendown()只是放下画笔，并不绘制任何内容。</li>
</ul>
</li>
<li>哪个选项不能改变turtle画笔的运行方向？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬B<br>A. left()<br>B. bk()<br>C. seth()<br>D. right()<ul>
<li>bk()只能后退，但不改变方向，”后退”不是”转向”。</li>
</ul>
</li>
<li>哪个选项所列保留字能够实现对一组语句的循环执行？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬C<br>A. if和else<br>B. range()<br>C. for和in<br>D. while和def<ul>
<li>循环相关保留字是：for..in和while，但def用于定义函数，不相关。</li>
</ul>
</li>
<li>哪个选项能够使用turtle库绘制一个半圆形？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬D<br>A. turtle.circle(100, 90)<br>B. turtle.fd(100)<br>C. turtle.circle(100)<br>D. turtle.circle(100, -180)<ul>
<li>circle(x,y)函数的用法，绘制半圆，第二个参数y是180的奇数倍。</li>
</ul>
</li>
<li>哪个选项对turtle.done()的描述是正确的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬B<br>A. turtle.done()用来暂停画笔绘制，用户响应后还可以继续绘制<br>B. turtle.done()用来停止画笔绘制，但绘图窗体不关闭<br>C. turtle.done()放在代码最后，是turtle绘图的必要要求，表示绘制完成<br>D. turtle.done()用来隐藏turtle绘制画笔，一般放在代码最后<ul>
<li>建议在每个turtle绘图最后增加turtle.done()。</li>
</ul>
</li>
</ol>
<div class="note success"><p>本节结束，点击进入下一节课程：<a href="https://blog.hackme.cc/Python/3.html">《Third Week of Python Notes /【第3周笔记】Python 基本数据类型》</a></p>
</div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>画笔控制函数</tag>
        <tag>运动控制函数</tag>
        <tag>方向控制函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry Pi Intranet Penetration / 树莓派内网穿透</title>
    <url>/IT/14.html</url>
    <content><![CDATA[<p>&emsp;&emsp;博主的站群长年无人问津，广告收入几乎没有，于是再也负担不起高额的服务器费用了😭。可能是老天爷还想逛博主的网站吧，让博主无意之间看到了树莓派，好奇之心顿起，火速下单，到手以后一番折腾，终于把网站从云端迁移到了本地。本文就记录了折腾过程（主要是内网穿透方面）。</p>
<span id="more"></span>

<h1 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h1><ul>
<li>Raspberry Pi / 树莓派一个（博主用的是 8G 内存的 4B）</li>
<li>有（最好固定）公网 IP 的服务器一台（博主用的是：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> Ubuntu 20.04）</li>
</ul>
<div class="note warning"><p>友情提示：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> 可能需要先翻墙才可访问！</p>
</div>

<h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><h2 id="安装-frps"><a href="#安装-frps" class="headerlink" title="安装 frps"></a>安装 frps</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">wget</span> https://github.com/fatedier/frp/releases/download/v<span class="number">0</span>.<span class="number">36</span>.<span class="number">2</span>/frp_<span class="number">0</span>.<span class="number">36</span>.<span class="number">2</span>_linux_amd<span class="number">64</span>.tar.gz     # 下载系统内核版本对应的 frp 压缩包</span><br><span class="line"><span class="attribute">tar</span> -xzvf frp_<span class="number">0</span>.<span class="number">36</span>.<span class="number">2</span>_linux_amd<span class="number">64</span>.tar.gz     # 解压到当前文件夹</span><br><span class="line"><span class="attribute">nano</span> frp_<span class="number">0</span>.<span class="number">36</span>.<span class="number">2</span>_linux_amd<span class="number">64</span>/frps.ini     # 编辑 frps 配置文件</span><br></pre></td></tr></table></figure>

<h2 id="公网服务器端-frps-配置"><a href="#公网服务器端-frps-配置" class="headerlink" title="公网服务器端 frps 配置"></a>公网服务器端 frps 配置</h2><p>&emsp;&emsp;服务器端（frps）详细配置请查看官方 Wiki：<span class="exturl" data-url="aHR0cHM6Ly9nb2ZycC5vcmcvZG9jcy9yZWZlcmVuY2Uvc2VydmVyLWNvbmZpZ3VyZXMv">服务端配置<i class="fa fa-external-link-alt"></i></span></p>
<p>&emsp;&emsp;贴上博主的 frps.ini</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span>     <span class="comment"># frp 运行端口</span></span><br><span class="line"><span class="attr">log_file</span> = /root/frp_0.<span class="number">36.2</span>_linux_amd64/frps.log     <span class="comment"># frps 日志文件路径</span></span><br><span class="line"><span class="attr">token</span> = **请输入你的 token**     <span class="comment"># 为服务器安全建议使用 token</span></span><br><span class="line"><span class="attr">tls_only</span> = <span class="literal">true</span>     <span class="comment"># 为了安全请启用</span></span><br><span class="line"><span class="attr">allow_ports</span> = **remote_port1,remote_port2**     <span class="comment"># 填入公网要访问的端口</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span>     <span class="comment"># frps 管理地址</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin     <span class="comment"># frps 管理员账号</span></span><br><span class="line"><span class="attr">dashboard_pwd</span> = <span class="number">123456</span>     <span class="comment"># frps 管理员密码</span></span><br></pre></td></tr></table></figure>

<h2 id="将-frps-写入系统服务"><a href="#将-frps-写入系统服务" class="headerlink" title="将 frps 写入系统服务"></a>将 frps 写入系统服务</h2><p><code>nano /lib/systemd/system/frps.service</code> # 新建一个 service 并写入以下配置保存</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description = frps service</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line">ExecStart = /root/frp_0.36.2_linux_amd64/frps -c /root/frp_0.36.2_linux_amd64/frps.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>

<h2 id="启动-frps-并设置开机自启"><a href="#启动-frps-并设置开机自启" class="headerlink" title="启动 frps 并设置开机自启"></a>启动 frps 并设置开机自启</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">systemctl <span class="keyword">start</span> frps</span><br><span class="line">systemctl <span class="keyword">enable</span> frps</span><br></pre></td></tr></table></figure>

<div class="note success"><p>至此内网穿透服务器端的配置就完成了，下面进行内网客户端（树莓派）的配置</p>
</div>

<h1 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h1><h2 id="使用官方-64-位-Raspbian"><a href="#使用官方-64-位-Raspbian" class="headerlink" title="使用官方 64 位 Raspbian"></a>使用官方 64 位 Raspbian</h2><p>&emsp;&emsp;建议使用树莓派官方 64 位系统：<span class="exturl" data-url="aHR0cDovL2Rvd25sb2Fkcy5yYXNwYmVycnlwaS5vcmcvcmFzcGlvc19hcm02NC9pbWFnZXMvcmFzcGlvc19hcm02NC0yMDIwLTA4LTI0LzIwMjAtMDgtMjAtcmFzcGlvcy1idXN0ZXItYXJtNjQuemlw">2020-08-20-raspios-buster-arm64.zip<i class="fa fa-external-link-alt"></i></span> （如何写入内存卡此处不再赘述）</p>
<div class="note warning"><p>重大提示：树莓派系统写入内存卡以后，需要在 boot 目录下新建一个文件 <strong>ssh</strong>，否则无法通过 SSH 连接树莓派！！！（博主在这里踩了个大坑好不容易才找到解决办法）</p>
</div>

<h2 id="电脑直连树莓派"><a href="#电脑直连树莓派" class="headerlink" title="电脑直连树莓派"></a>电脑直连树莓派</h2><p>&emsp;&emsp;电脑无线网共享给以太网，然后用网线直连树莓派，通过 <code>arp -a</code> 查看树莓派 IP（一般是：192.168.137.x）</p>
<h2 id="SSH-登录"><a href="#SSH-登录" class="headerlink" title="SSH 登录"></a>SSH 登录</h2><p>&emsp;&emsp;找到树莓派 IP 后用 SSH 登录，账号：<code>pi</code>，密码：<code>raspberry</code></p>
<h2 id="中国内地请换源"><a href="#中国内地请换源" class="headerlink" title="中国内地请换源"></a>中国内地请换源</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">nano <span class="regexp">/etc/</span>apt/sources.list</span><br><span class="line">三行前面的网址都换成清华源（仅前面的网址，不包括后面的路劲）：https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn/</span><br><span class="line"></span><br><span class="line">nano <span class="regexp">/etc/</span>apt<span class="regexp">/sources.list.d/</span>raspi.list</span><br><span class="line">整体换成清华源：https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/raspberrypi/</span></span><br></pre></td></tr></table></figure>

<h2 id="升级系统"><a href="#升级系统" class="headerlink" title="升级系统"></a>升级系统</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">apt <span class="keyword">update</span></span><br><span class="line">apt <span class="keyword">full</span>-<span class="keyword">upgrade</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-frpc"><a href="#安装-frpc" class="headerlink" title="安装 frpc"></a>安装 frpc</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">wget</span> https://github.com/fatedier/frp/releases/download/v<span class="number">0</span>.<span class="number">36</span>.<span class="number">2</span>/frp_<span class="number">0</span>.<span class="number">36</span>.<span class="number">2</span>_linux_arm<span class="number">64</span>.tar.gz     # 下载系统内核版本对应的 frp 压缩包</span><br><span class="line"><span class="attribute">tar</span> -xzvf frp_<span class="number">0</span>.<span class="number">36</span>.<span class="number">2</span>_linux_amd<span class="number">64</span>.tar.gz     # 解压到当前文件夹</span><br><span class="line"><span class="attribute">nano</span> frp_<span class="number">0</span>.<span class="number">36</span>.<span class="number">2</span>_linux_amd<span class="number">64</span>/frpc.ini     # 编辑 frpc 配置文件</span><br></pre></td></tr></table></figure>

<h2 id="内网客户端（树莓派）-frpc-配置"><a href="#内网客户端（树莓派）-frpc-配置" class="headerlink" title="内网客户端（树莓派） frpc 配置"></a>内网客户端（树莓派） frpc 配置</h2><p>&emsp;&emsp;内网客户端（树莓派）frpc 详细配置请查看官方 Wiki：<span class="exturl" data-url="aHR0cHM6Ly9nb2ZycC5vcmcvZG9jcy9yZWZlcmVuY2UvY2xpZW50LWNvbmZpZ3VyZXMv">客户端配置<i class="fa fa-external-link-alt"></i></span></p>
<p>&emsp;&emsp;贴上博主的 frpc.ini</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = **请输入服务器端公网 IP**</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span>     <span class="comment"># 端口号与服务器端 bind_port 一致</span></span><br><span class="line"><span class="attr">log_file</span> = /home/pi/frp_0.<span class="number">36.2</span>_linux_arm64/frpc.log     <span class="comment"># frpc 日志文件路径</span></span><br><span class="line"><span class="attr">tls_enable</span> = <span class="literal">true</span>     <span class="comment"># 服务器端若配置了 tls_only = true，此处也需启用</span></span><br><span class="line"><span class="attr">token</span> = **请输入与服务器端一致的 token**</span><br><span class="line"></span><br><span class="line"><span class="comment">#[ssh]     # 为了安全起见，博主没有开启树莓派 SSH 的内网穿透</span></span><br><span class="line"><span class="comment">#type = tcp</span></span><br><span class="line"><span class="comment">#local_ip = 127.0.0.1</span></span><br><span class="line"><span class="comment">#local_port = 22</span></span><br><span class="line"><span class="comment">#remote_port = 6000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[bt]</span>     <span class="comment"># 宝塔</span></span><br><span class="line"><span class="attr">type</span> = tcp     <span class="comment"># 使用 TCP 连接</span></span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span>     <span class="comment"># 启用传输加密</span></span><br><span class="line"><span class="attr">use_compression</span> = <span class="literal">true</span>     <span class="comment"># 启用传输压缩</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">8888</span>     <span class="comment"># 树莓派的宝塔端口</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8888</span>     <span class="comment"># 从公网要访问宝塔的端口</span></span><br><span class="line"></span><br><span class="line"><span class="section">[web]</span>     <span class="comment"># 网站</span></span><br><span class="line"><span class="attr">type</span> = tcp     <span class="comment"># 使用 TCP 连接</span></span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span>     <span class="comment"># 启用传输加密</span></span><br><span class="line"><span class="attr">use_compression</span> = <span class="literal">true</span>     <span class="comment"># 启用传输压缩</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span>     <span class="comment"># 宝塔上网站的端口</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">443</span>     <span class="comment"># 从公网访问网站的端口</span></span><br></pre></td></tr></table></figure>

<h2 id="将-frpc-写入系统服务"><a href="#将-frpc-写入系统服务" class="headerlink" title="将 frpc 写入系统服务"></a>将 frpc 写入系统服务</h2><p><code>nano /lib/systemd/system/frpc.service</code>     # 新建一个 service 并写入以下配置保存</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description = frpc service</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line">ExecStart = /home/pi/frp_0.36.2_linux_arm64/frpc -c /home/pi/frp_0.36.2_linux_arm64/frpc.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>

<h2 id="启动-frpc-并设置开机自启"><a href="#启动-frpc-并设置开机自启" class="headerlink" title="启动 frpc 并设置开机自启"></a>启动 frpc 并设置开机自启</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">systemctl <span class="keyword">start</span> frpc</span><br><span class="line">systemctl <span class="keyword">enable</span> frpc</span><br></pre></td></tr></table></figure>

<div class="note success"><p>至此树莓派内网穿透工作就完成咯。可以访问“公网IP:7500”查看内网穿透的状态啦！</p>
</div>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>树莓派</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>Resolutions for VMware Tools Installation Failure / VMware Tools 安装失败的解决办法</title>
    <url>/IT/15.html</url>
    <content><![CDATA[<p>&emsp;&emsp;虽然 Windows 10 才是“The Future”，但奈何还有很多 Windows 7 的遗留产物，故电脑里少不了 Windows 7 的虚拟机。而前些天博主在习惯性的创建 Windows 7 虚拟机的时候，出现了一个新问题——VMware Tools 不能自动安装需要手动安装了。通过查阅官方提示和百度搜索，得出了解决办法。网上尚没有太多的说明，所以写下此篇博文，以记录和指路。</p>
<p>&emsp;&emsp;首先祭出官方的说明文档：<span class="exturl" data-url="aHR0cHM6Ly9rYi52bXdhcmUuY29tL3MvYXJ0aWNsZS83ODcwOA==">VMware Tools upgrade fails on Windows without SHA-2 code signing support (78708)<i class="fa fa-external-link-alt"></i></span><br>&emsp;&emsp;大概意思就是因为微软签名版本的问题，所以如果需要在旧版 Windows 上安装 VMware Tools，需要先打两个补丁。<br>&emsp;&emsp;附上需要打的两个补丁的官方下载链接，注意选择和自己系统相对应的版本。</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2F0YWxvZy51cGRhdGUubWljcm9zb2Z0LmNvbS9zZWFyY2guYXNweD9xPWtiNDQ3NDQxOQ==">KB4474419<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2F0YWxvZy51cGRhdGUubWljcm9zb2Z0LmNvbS9zZWFyY2guYXNweD9xPWtiNDQ5MDYyOA==">KB4490628<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>&emsp;&emsp;打完上述两个补丁再安装 VMware Tools 就没有问题啦~</p>
]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>Steam Free Games 27 / Steam 免费游戏 代码一键领取 27 个</title>
    <url>/Welfare/3.html</url>
    <content><![CDATA[<p>&emsp;&emsp;利用 F12 Console+代码，Enter 一键领取 Steam 27 个免费游戏/DLC</p>
<span id="more"></span>

<div class="note primary"><p>登陆 <span class="exturl" data-url="aHR0cHM6Ly9zdG9yZS5zdGVhbXBvd2VyZWQuY29tL2FjY291bnQvbGljZW5zZXMv">Steam<i class="fa fa-external-link-alt"></i></span> → F12 → Console → 复制以下代码</p>
</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( location.href.match( <span class="regexp">/^https:\/\/store\.steampowered\.com\/account\/licenses\/?$/</span> ) === <span class="literal">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">                alert( <span class="string">&#x27;请在Steam帐号明细页面运行这些代码: https://store.steampowered.com/account/licenses/&#x27;</span> );</span><br><span class="line"> </span><br><span class="line">                <span class="built_in">window</span>.location = <span class="string">&#x27;https://store.steampowered.com/account/licenses/&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> freePackages =</span><br><span class="line">        [</span><br><span class="line">                <span class="comment">//本体</span></span><br><span class="line">                <span class="number">39166</span>,<span class="comment">//Heroine&#x27;s Quest: The Herald of Ragnarok</span></span><br><span class="line">                <span class="number">13261</span>,<span class="comment">//RACE 07: Andy Priaulx Crowne Plaza Raceway</span></span><br><span class="line">                <span class="number">32032</span>,<span class="comment">//Portal 2 Sixense Perceptual Pack</span></span><br><span class="line">                <span class="number">59373</span>,<span class="comment">//Penumbra: Necrologue</span></span><br><span class="line">                <span class="number">33694</span>,<span class="comment">//Grimm&amp;Episode 1 - A Boy Learns What Fear Is</span></span><br><span class="line">                <span class="number">88162</span>,<span class="comment">//Romance of the Three Kingdoms Maker</span></span><br><span class="line">                <span class="number">36561</span>,<span class="comment">//Serena</span></span><br><span class="line">                <span class="number">58514</span>,<span class="comment">//Voxelized</span></span><br><span class="line">        <span class="number">117526</span>,<span class="comment">//Amnesia: Final Revelations</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//dlc</span></span><br><span class="line">                <span class="number">85604</span>,<span class="comment">//RTK Maker - Face CG “RTK13” Set / 三国志ツクール顔登録素材 『三國志13』セット+シナリオ</span></span><br><span class="line">                <span class="number">21478</span>,<span class="comment">//Free to Play免费本体</span></span><br><span class="line">                <span class="number">50861</span>,<span class="comment">//Free to Play Soundtrack</span></span><br><span class="line">                <span class="number">21473</span>,<span class="comment">//Prime World免费本体</span></span><br><span class="line">                <span class="number">31538</span>,<span class="comment">//Prime World - Prime Machine</span></span><br><span class="line">                <span class="number">32287</span>,<span class="comment">//Z3TA+ 2 - Polybius 8-bit Game Pack</span></span><br><span class="line">                <span class="number">38085</span>,<span class="comment">//Saints Row IV - Reverse Cosplay Pack</span></span><br><span class="line">                <span class="number">72261</span>,<span class="comment">//The Secret of Tremendous Corporation免费本体</span></span><br><span class="line">                <span class="number">81026</span>,<span class="comment">//The Sources of Tremendous Corporation</span></span><br><span class="line">                <span class="number">47333</span>,<span class="comment">//Aura Kingdom免费本体</span></span><br><span class="line">                <span class="number">38820</span>,<span class="comment">//Aura Kingdom - Winter Gift</span></span><br><span class="line">                <span class="number">69802</span>,<span class="comment">//Fuse免费本体</span></span><br><span class="line">                <span class="number">60341</span>,<span class="comment">//Fuse - Free Brute Character Pack</span></span><br><span class="line">                <span class="number">21416</span>,<span class="comment">//Elsword免费本体</span></span><br><span class="line">                <span class="number">63207</span>,<span class="comment">//Time Tracer&#x27;s DLC Package</span></span><br><span class="line">                <span class="number">59253</span>,<span class="comment">//Vindictus - New User Package</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//软件&amp;工具</span></span><br><span class="line">                <span class="number">35063</span>,<span class="comment">//Star Swarm Stress Test</span></span><br><span class="line">                <span class="number">74465</span>,<span class="comment">//Arma 3 Samples</span></span><br><span class="line">        ];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> ownedPackages = &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        jQuery( <span class="string">&#x27;.account_table a&#x27;</span> ).each( <span class="function"><span class="keyword">function</span>(<span class="params"> i, el </span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> match = el.href.match( <span class="regexp">/javascript:RemoveFreeLicense\( ([0-9]+), &#x27;/</span> );</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>( match !== <span class="literal">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                        ownedPackages[ +match[ <span class="number">1</span> ] ] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">            loaded = <span class="number">0</span>,</span><br><span class="line">            package = <span class="number">0</span>,</span><br><span class="line">            total = freePackages.length,</span><br><span class="line">            modal = ShowBlockingWaitDialog( <span class="string">&#x27;努力执行中...&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;请耐心等待，如果有错误请无视，请耐心等待脚本加载完毕&#x27;</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; total; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">                package = freePackages[ i ];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>( ownedPackages[ package ] )</span><br><span class="line">                &#123;</span><br><span class="line">                        loaded++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                jQuery.post(</span><br><span class="line">                        <span class="string">&#x27;//store.steampowered.com/checkout/addfreelicense&#x27;</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                                action: <span class="string">&#x27;add_to_cart&#x27;</span>,</span><br><span class="line">                                sessionid: g_sessionID,</span><br><span class="line">                                subid: package</span><br><span class="line">                        &#125;</span><br><span class="line">                ).always( <span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span></span><br><span class="line"><span class="function">                        </span>&#123;</span><br><span class="line">                                loaded++;</span><br><span class="line">                                </span><br><span class="line">                                modal.Dismiss();</span><br><span class="line">                                </span><br><span class="line">                                <span class="keyword">if</span>( loaded &gt;= total )</span><br><span class="line">                                &#123;</span><br><span class="line">                                        location.reload();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                        modal = ShowBlockingWaitDialog( <span class="string">&#x27;执行中...&#x27;</span>,</span><br><span class="line">                                                <span class="string">&#x27;加载至 &lt;b&gt;&#x27;</span> + loaded + <span class="string">&#x27;&lt;/b&gt;/&#x27;</span> + total + <span class="string">&#x27;.&#x27;</span> );</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<div class="note success"><p>敲下 Enter 键，Start enjoying Steam!</p>
</div>]]></content>
      <categories>
        <category>Welfare</category>
      </categories>
      <tags>
        <tag>一键脚本</tag>
        <tag>Steam</tag>
        <tag>games</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Optimization / Ubuntu 优化</title>
    <url>/IT/16.html</url>
    <content><![CDATA[<p>&emsp;&emsp;博主比较喜欢新鲜事物，且总认为新版的比旧版的好，于是拿到一个服务器，第一件事就是更新。而对于 Linux 来说，kernel 内核的升级就显得尤为重要。而博主无意间发现了一个对博主超级无敌友好的升级内核方式，简直就是为博主这种人量身定制的——HWE kernel——会自动更新的 kernel.所以赶紧记录下来，同时也附带一些简单的 Ubuntu 优化。</p>
<span id="more"></span>

<div class="note primary"><p>本文适用系统版本为：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> <strong>Ubuntu 20.04</strong></p>
</div>

<div class="note warning"><p>友情提示：<span class="exturl" data-url="aHR0cHM6Ly9iYW5kd2Fnb25ob3N0LmNvbS9hZmYucGhwP2FmZj01MzAxMQ==">搬瓦工<i class="fa fa-external-link-alt"></i></span> 可能需要先翻墙才可访问！</p>
</div>

<h1 id="Time-时间"><a href="#Time-时间" class="headerlink" title="Time / 时间"></a>Time / 时间</h1><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">tzselect     <span class="comment"># 选时区</span></span><br><span class="line">cp <span class="regexp">/usr/</span>share<span class="regexp">/zoneinfo/</span>Asia<span class="regexp">/Shanghai /</span>etc/localtime     <span class="comment"># 改为中国时间</span></span><br></pre></td></tr></table></figure>

<h1 id="Source-源"><a href="#Source-源" class="headerlink" title="Source / 源"></a>Source / 源</h1><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">nano <span class="regexp">/etc/</span>apt/sources.list     <span class="comment"># 换源</span></span><br><span class="line">http:<span class="regexp">//</span>archive.ubuntu.com<span class="regexp">/ubuntu/</span>     <span class="comment"># 官方源</span></span><br><span class="line">apt update     <span class="comment"># 更新源</span></span><br></pre></td></tr></table></figure>

<h1 id="install-HWE-kernel-安装自动更新内核"><a href="#install-HWE-kernel-安装自动更新内核" class="headerlink" title="install HWE-kernel / 安装自动更新内核"></a>install HWE-kernel / 安装自动更新内核</h1><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt</span> install --install-recommends linux-generic-hwe-<span class="number">20</span>.<span class="number">04</span> -y</span><br></pre></td></tr></table></figure>

<h1 id="bbr（加速）"><a href="#bbr（加速）" class="headerlink" title="bbr（加速）"></a>bbr（加速）</h1><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">echo net.core.default_qdisc = fq &gt;&gt; <span class="regexp">/etc/</span>sysctl.conf     <span class="comment"># 设置 bbr 队列算法</span></span><br><span class="line">echo net.ipv4.tcp_congestion_control = bbr &gt;&gt; <span class="regexp">/etc/</span>sysctl.conf     <span class="comment"># 开启 bbr</span></span><br><span class="line">sysctl -p     <span class="comment"># 保存生效</span></span><br><span class="line">sysctl net.ipv4.tcp_available_congestion_control     <span class="comment"># 查看是否有 bbr</span></span><br><span class="line">lsmod | grep bbr     <span class="comment"># 查看 bbr 是否开启</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>kernel</tag>
        <tag>HWE</tag>
      </tags>
  </entry>
  <entry>
    <title>Uszcn Invitation Code / 转运中国（注册）邀请码</title>
    <url>/Welfare/2.html</url>
    <content><![CDATA[<p>&emsp;&emsp;<a href="https://blog.hackme.cc/">信安 - HACK ME</a> 福利：<strong>送</strong> <span class="exturl" data-url="aHR0cHM6Ly93d3cudXN6Y24uY29tLw==">转运中国<i class="fa fa-external-link-alt"></i></span> 注册邀请码。</p>
<div class="note danger"><p>因本站邀请码资源枯竭，故暂停发放转运中国邀请码，恢复时间待定，如有需求请至其它渠道索取，对您造成的不便，敬请谅解！</p>
</div>

<span id="more"></span>

<div class="note primary"><p>转运中国官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cudXN6Y24uY29tLw==">www.uszcn.com<i class="fa fa-external-link-alt"></i></span></p>
</div>

<blockquote>
<p>我公司主要是通过互联网进行物流信息的追踪查询、物流订单的下达。客户自行在海外电子商务公司下单(此公司与我公司没有任何关联)，将货物送达海外仓储公司，海外仓储公司将货物到达信息通知我公司，我公司通知客户，并等待客户反馈。用户出库时，我们代收运费和清关相关的材料，同时通知海外仓储公司发货。海外仓储公司会选择一家或几家物流公司(如FEDEX，USPS等)向客户发货，货物到达中国后，经过海关、商检部门的检验，由国内快递公司完成派送工作。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——<em>摘自 <span class="exturl" data-url="aHR0cHM6Ly93d3cudXN6Y24uY29tL21pc2MvaW50cm8=">转运中国 公司简介<i class="fa fa-external-link-alt"></i></span></em></p>
</blockquote>
<p>&emsp;&emsp;<span class="exturl" data-url="aHR0cHM6Ly93d3cudXN6Y24uY29tLw==">转运中国<i class="fa fa-external-link-alt"></i></span>注册为邀请制，本链接为 <span class="exturl" data-url="aHR0cHM6Ly93d3cudXN6Y24uY29tLw==">转运中国<i class="fa fa-external-link-alt"></i></span> 注册邀请码的赠送链接，每日14时后不定时发放一个邀请码。</p>
<p>&emsp;&emsp;有同为转运中国的海淘玩家，通过 <a href="https://blog.hackme.cc/">信安 - HACK ME</a> 的邀请码进行注册的，注册完后有多余的邀请码，特意联系到博主，希望通过 <a href="https://blog.hackme.cc/">信安 - HACK ME</a> 这个平台来分享给大家，博主感到很激动，同时也很欣慰，他成功的通过 <a href="https://blog.hackme.cc/">信安 - HACK ME</a> 注册到了转运中国的会员。使用了下面激活码的朋友们，你们以后有多余的邀请码也都可以联系发送给博主，博主在此对你们表示感谢！祝你们海淘顺利、开心！😄</p>
<h1 id="转运中国-邀请码："><a href="#转运中国-邀请码：" class="headerlink" title="转运中国 邀请码："></a>转运中国 邀请码：</h1><ul>
<li><del>i1xjelbf61s1</del></li>
<li><del>i1qxtwaqzpz5</del></li>
<li><del>i1k3av2x4c5c</del></li>
<li><del>i1cdn7exp4ch</del></li>
<li><del>i0kq1r9d34g1</del></li>
<li><del>i0egpb3az4ao</del></li>
<li><del>i089fztd88w1</del></li>
<li><del>i001x3akqvsx</del></li>
<li><del>hzfmlucoi70h</del></li>
<li><del>hz15xdpgxow0</del></li>
<li><del>hyafwug3445d</del></li>
<li><del>hy2fpt19vk01</del></li>
<li><del>hxv5nnbc37gg</del></li>
<li><del>hxpzn9i0gp4w</del></li>
<li><del>hxidwvrowim9</del></li>
<li><del>hx3jov62wnnl</del></li>
<li><del>hww2z96d01ts</del></li>
<li><del>hww8bs421s5d</del></li>
<li><del>hwpdtywlva2p</del></li>
<li><del>hwimro6ekh1c</del></li>
<li><del>hwblgmlzdj41</del></li>
<li><del>hw4d52viex6p</del></li>
<li><del>hvx9g6clizcw</del></li>
<li><del>hvqacddieuyo</del></li>
<li><del>hvkw3cf09m80</del></li>
<li><del>hvdkzn69di81</del></li>
<li><del>hv6aehlqln40</del></li>
<li><del>huyg0b2rt3wg</del></li>
<li><del>huri8jxitsld</del></li>
<li><del>hukfte1zkq68</del></li>
<li><del>hufcg0nhudxc</del></li>
<li><del>hu6m5tsr2475</del></li>
<li><del>htzpfv3pds74</del></li>
<li><del>htsrfsaim6ps</del></li>
<li><del>htlnexeqm5hc</del></li>
<li><del>hrov2wjreqwx</del></li>
</ul>
]]></content>
      <categories>
        <category>Welfare</category>
      </categories>
      <tags>
        <tag>转运中国</tag>
        <tag>邀请码</tag>
        <tag>注册邀请码</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulfocus Building Guide / Vulfocus 搭建指南</title>
    <url>/IT/8.html</url>
    <content><![CDATA[<p>&emsp;&emsp;在 <a href="https://blog.hackme.cc/IT/7.html">搭建 vulstudy</a> 的时候无意间发现了一个好像可以作为 CTF 的平台“Vulfocus”，打算也搭一个试试。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvZmFwcm8vdnVsZm9jdXMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1k">README<i class="fa fa-external-link-alt"></i></span> 里没看到安装说明，后来百度到了搭建指南在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvZmFwcm8vdnVsZm9jdXMvYmxvYi9tYXN0ZXIvSU5TVEFMTC5tZA==">INSTALL.md<i class="fa fa-external-link-alt"></i></span> 里，于是搬运过来作为博文，便于查看。<strong>直接搬运，内容未作改动</strong>。</p>
<div class="note primary"><p>GitHub 项目地址： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvZmFwcm8vdnVsZm9jdXM=">fofapro/vulfocus<i class="fa fa-external-link-alt"></i></span></p>
</div>

<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>系统为前后端分离项目，<code>vulfocus-api</code>  为后端项目、 <code>vulfocus-frontend</code>  为前端项目。</p>
<h2 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h2><p>拉取 Vulfocus 镜像：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">docker pull vulfocus/<span class="attr">vulfocus:</span>latest</span><br></pre></td></tr></table></figure>
<p>运行 Vulfocus</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker create -p <span class="number">80</span>:<span class="number">80</span> -v <span class="regexp">/var/</span>run<span class="regexp">/docker.sock:/</span>var<span class="regexp">/run/</span>docker.sock  -e VUL_IP=xxx.xxx.xxx.xxx vulfocus/vulfocus</span><br><span class="line">docker start container id</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">80</span>:<span class="number">80</span> -v <span class="regexp">/var/</span>run<span class="regexp">/docker.sock:/</span>var<span class="regexp">/run/</span>docker.sock  -e VUL_IP=xxx.xxx.xxx.xxx vulfocus/vulfocus</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-v /var/run/docker.sock:/var/run/docker.sock</code> 为 docker 交互连接。</li>
<li><code>-e DOCKER_URL</code> 为 Docker 连接方式，默认通过 <code>unix://var/run/docker.sock</code> 进行连接，也可以通过 <code>tcp://xxx.xxx.xxx.xxx:2375</code> 进行连接（必须开放 2375 端口）。</li>
<li><code>-v /vulfocus-api/db.sqlite3:db.sqlite3</code> 映射数据库为本地文件。</li>
<li><code>-e VUL_IP=xxx.xxx.xxx.xxx</code> 为 Docker 服务器 IP ，不能为 127.0.0.1。</li>
<li>默认账户密码为 <code>admin/admin</code>。</li>
</ul>
<h2 id="自定义安装"><a href="#自定义安装" class="headerlink" title="自定义安装"></a>自定义安装</h2><p><strong>以 Centos 7 为例主机已经关闭 <code>selinux</code></strong></p>
<p>环境：</p>
<ul>
<li>语言：python3</li>
<li>数据库：sqlite3、redis</li>
<li>框架：Django、Celery</li>
<li>API：djangorestframework</li>
<li>系统：Centos 7 , Other</li>
</ul>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><h4 id="安装需要的软件和开发环境"><a href="#安装需要的软件和开发环境" class="headerlink" title="安装需要的软件和开发环境"></a>安装需要的软件和开发环境</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> epel-<span class="keyword">release</span></span><br><span class="line">yum <span class="keyword">install</span> gcc -y</span><br><span class="line">yum <span class="keyword">install</span>  nginx supervisor net-tools wget git -y</span><br><span class="line">yum <span class="keyword">install</span> redis -y</span><br></pre></td></tr></table></figure>

<h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><h4 id="安装-docker-1"><a href="#安装-docker-1" class="headerlink" title="安装 docker"></a>安装 docker</h4><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwv">https://docs.docker.com/engine/install/<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> docker -y</span><br></pre></td></tr></table></figure>

<h4 id="Docker-配置"><a href="#Docker-配置" class="headerlink" title="Docker 配置"></a>Docker 配置</h4><p>配置 Docker <code>2375</code> 端口（可根据实际情况进行修改），修改 docker 配置文件，加入以下信息：</p>
<p><strong>位置：</strong>  <code>/usr/lib/systemd/system/docker.service</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ExecStart=<span class="regexp">/usr/</span>bin<span class="regexp">/dockerd -H tcp:/</span><span class="regexp">/127.0.0.1:2375 -H unix:/</span><span class="regexp">/var/</span>run/docker.sock \</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/dockerd-current -H tcp:/</span><span class="regexp">/127.0.0.1:2375 -H unix:/</span><span class="regexp">/var/</span>run/docker.sock \</span><br></pre></td></tr></table></figure>

<p>重载配置文件</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl daemon-reload</span></span><br></pre></td></tr></table></figure>



<h3 id="安装-Vulfocus-API"><a href="#安装-Vulfocus-API" class="headerlink" title="安装 Vulfocus API"></a>安装 Vulfocus API</h3><h4 id="安装-Python3-不想源码编译"><a href="#安装-Python3-不想源码编译" class="headerlink" title="安装 Python3 (不想源码编译)"></a>安装 Python3 (不想源码编译)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">chmod 755 Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">./Miniconda3-latest-Linux-x86_64.sh  # 安装位置选  /opt/anaconda3/  </span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h4 id="更新-pip"><a href="#更新-pip" class="headerlink" title="更新 pip"></a>更新 pip</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/anaconda3/bin/pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</span><br><span class="line">/opt/anaconda3/bin/pip install virtualenv -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h4 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/data/</span>&#123;etc,log,tmp&#125;</span><br><span class="line"><span class="regexp">/opt/</span>anaconda3<span class="regexp">/bin/</span>virtualenv <span class="regexp">/data/</span>venv_py --python=<span class="regexp">/opt/</span>anaconda3<span class="regexp">/bin/</span>python</span><br><span class="line">echo <span class="string">&quot;source /data/venv_py/bin/activate&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="keyword">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h4 id="拉取-vulfocus-和安装项目依赖"><a href="#拉取-vulfocus-和安装项目依赖" class="headerlink" title="拉取 vulfocus 和安装项目依赖"></a>拉取 vulfocus 和安装项目依赖</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /data</span><br><span class="line">git clone https://github.com/fofapro/vulfocus.git web</span><br><span class="line">cd /data/web/vulfocus-api/</span><br><span class="line">pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><h4 id="如果使用mysql"><a href="#如果使用mysql" class="headerlink" title="如果使用mysql"></a>如果使用mysql</h4><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">yum install mysql-devel </span><br><span class="line">pip3 install mysqlclient -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>修改setting文件</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;vulfocus&#x27;,</span><br><span class="line">        &#x27;HOST&#x27;:&#x27;127.0.0.1&#x27;,</span><br><span class="line">        &#x27;PORT&#x27;:3306,</span><br><span class="line">        &#x27;USER&#x27;:&#x27;root&#x27;,</span><br><span class="line">        &#x27;PASSWORD&#x27;:os.environ[&#x27;MYSQLPWD&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">bug MySQL does not allow unique CharFields to have a max_length &gt; 255</span></span><br><span class="line">SILENCED_SYSTEM_CHECKS = [&#x27;mysql.E001&#x27;]</span><br></pre></td></tr></table></figure>

<h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /data/web/vulfocus-api</span><br><span class="line">python manage.py migrate</span><br><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<h4 id="靶场配置："><a href="#靶场配置：" class="headerlink" title="靶场配置："></a>靶场配置：</h4><ol>
<li><p>配置 Docker URL（<code>vulfocus/settings.py</code>），默认为：<code>tcp://127.0.0.1:2375</code>，修改为 Docker 服务器的 IP。</p>
</li>
<li><p>配置 VUL_IP（<code>vulfocus/settings.py</code>），修改为 Docker 服务器的 IP。</p>
</li>
<li><p>修改 CELERY_BROKER_URL（<code>vulfocus/settings.py</code>），修改为 Redis 连接地址。</p>
</li>
</ol>
<h4 id="启动-Celery-Celery不需要操做后面有自启"><a href="#启动-Celery-Celery不需要操做后面有自启" class="headerlink" title="启动 Celery(Celery不需要操做后面有自启)"></a>启动 Celery(Celery不需要操做后面有自启)</h4><p>在 <code>vulfocus-api</code> 中启动 Celery：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">celery</span> -A vulfocus worker -l <span class="literal">info</span> -E</span><br></pre></td></tr></table></figure>
<p>后端启动：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">celery multi start worker -A vulfocus -l <span class="builtin-name">info</span> <span class="attribute">--logfile</span>=celery.log</span><br></pre></td></tr></table></figure>

<h4 id="安装uwsgi"><a href="#安装uwsgi" class="headerlink" title="安装uwsgi"></a>安装uwsgi</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install uwsgi -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h5 id="uwsgi-配置"><a href="#uwsgi-配置" class="headerlink" title="uwsgi 配置"></a>uwsgi 配置</h5><p><strong>位置：</strong> <code>/data/etc/vulfocus_uwsgi.ini</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">uid=nginx</span><br><span class="line">chdir = /data/web/vulfocus-api</span><br><span class="line">;module = vulfocus.wsgi  </span><br><span class="line">mount = /api=vulfocus.wsgi:application  # nginx配置子目录</span><br><span class="line">manage-script-name = true</span><br><span class="line">;route-run = fixpathinfo:  </span><br><span class="line">home = /data/venv_py</span><br><span class="line">socket = /data/tmp/vulfocus_uwsgi.sock</span><br><span class="line">processes = 8</span><br><span class="line">master = true</span><br><span class="line">max-requests = 6000</span><br><span class="line">chmod-socket = 777</span><br><span class="line">vacuum = true</span><br><span class="line">enable-threads = true</span><br><span class="line">single-interpreter = true</span><br></pre></td></tr></table></figure>

<h3 id="安装-Vulfocus-Frontend"><a href="#安装-Vulfocus-Frontend" class="headerlink" title="安装 Vulfocus Frontend"></a>安装 Vulfocus Frontend</h3><p>vulfocus 前端项目，通过 Element-ui + VUE 构建。</p>
<p>环境：</p>
<ul>
<li>UI：Element UI</li>
<li>框架：vue</li>
<li>node：v12.16.2</li>
<li>npm：6.14.4</li>
</ul>
<h4 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h4><p>安装依赖：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install </span><br></pre></td></tr></table></figure>

<p>构建项目：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> build:prod</span></span><br></pre></td></tr></table></figure>

<p>错误处理:</p>
<p><strong>node sass error</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line">yarn install <span class="keyword">node</span><span class="title">-sass</span></span><br></pre></td></tr></table></figure>

<h4 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h4><p>通过 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvZmFwcm8vdnVsZm9jdXMvcmVsZWFzZXM=">https://github.com/fofapro/vulfocus/releases<i class="fa fa-external-link-alt"></i></span> 下载最新发布的版本。</p>
<h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><p>配置上传文件大小，修改 <code>nginx.conf</code> 文件，http 中加入：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">client_max_body_size <span class="number">4096</span>M<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>其中 4096M（4GB） 为上传文件最大限制，可根据实际进行修改，最小配置为 200M 。</p>
<h4 id="带证书多-vhost-的-nginx-配置文件"><a href="#带证书多-vhost-的-nginx-配置文件" class="headerlink" title="带证书多 vhost 的 nginx 配置文件"></a>带证书多 vhost 的 nginx 配置文件</h4><p><strong>位置：</strong><code>/etc/nginx/conf.d/vulfocus.xxx.net.conf</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">     server_name vulfocus.xxx.net;</span><br><span class="line">     rewrite ^(.*) https:<span class="regexp">//</span><span class="variable">$host</span><span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen <span class="number">443</span> ssl http2;</span><br><span class="line">server_name vulfocus.xxx.net;</span><br><span class="line">ssl_certificate <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span><span class="number">1</span>_vulfocus.xxx.net_bundle.crt;</span><br><span class="line">ssl_certificate_key <span class="regexp">/etc/</span>nginx<span class="regexp">/ssl/</span><span class="number">2</span>_vulfocus.xxx.net.key;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+<span class="number">3</span>DES:RSA+<span class="number">3</span>DES:!MD5;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">ssl_session_timeout <span class="number">10</span>m;</span><br><span class="line">ssl_session_cache builtin:<span class="number">1000</span> shared:SSL:<span class="number">10</span>m;</span><br><span class="line">ssl_stapling on;</span><br><span class="line">ssl_stapling_verify on;</span><br><span class="line">client_max_body_size <span class="number">2048</span>M;</span><br><span class="line">location /&#123;</span><br><span class="line">root <span class="regexp">/data/</span>vulfocus<span class="regexp">/vulfocus-frontend/</span>dist;</span><br><span class="line"> index index.html;</span><br><span class="line">&#125;</span><br><span class="line">location /api &#123;</span><br><span class="line">	      uwsgi_pass  unix:<span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span>data<span class="regexp">/tmp/</span>vulfocus_uwsgi.sock;</span><br><span class="line">        uwsgi_read_timeout <span class="number">600</span>;</span><br><span class="line">        uwsgi_param SCRIPT_NAME /api;</span><br><span class="line">        <span class="comment"># the uwsgi_params file you installed</span></span><br><span class="line">        include     <span class="regexp">/etc/</span>nginx/uwsgi_params;</span><br><span class="line">&#125;</span><br><span class="line">    access_log  <span class="regexp">/data/</span>log/vulfocus.xxx.net.log;</span><br><span class="line">    error_log  <span class="regexp">/data/</span>log/vulfocus.xxx.net.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不带证书仅有一个项目配置文件"><a href="#不带证书仅有一个项目配置文件" class="headerlink" title="不带证书仅有一个项目配置文件"></a>不带证书仅有一个项目配置文件</h4><p><strong>位置：</strong><code>/etc/nginx/nginx.conf</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>             /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">       <span class="attribute">location</span> /&#123;</span><br><span class="line">           <span class="attribute">root</span> /data/web/vulfocus-frontend/dist;</span><br><span class="line">       <span class="attribute">index</span> index.html;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="attribute">location</span> /api &#123;</span><br><span class="line">              <span class="attribute">uwsgi_pass</span>  unix:/data/tmp/vulfocus_uwsgi.sock;</span><br><span class="line">              <span class="attribute">uwsgi_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">              <span class="attribute">uwsgi_param</span> SCRIPT_NAME /api;</span><br><span class="line">              <span class="attribute">include</span>     /etc/nginx/uwsgi_params;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="attribute">access_log</span>  /data/log/vulfocus.xxx.net.log;</span><br><span class="line">    <span class="attribute">error_log</span>  /data/log/vulfocus.xxx.net.log;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置supervisor"><a href="#配置supervisor" class="headerlink" title="配置supervisor"></a>配置supervisor</h3><p><strong>位置：</strong><code>/etc/supervisord.d/vulfoucs.ini</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[program:vulfocus]</span></span><br><span class="line"><span class="attr">directory</span>=/data/venv_py</span><br><span class="line"><span class="attr">command</span>=/data/venv_py/bin/uwsgi --ini /data/etc/vulfocus_uwsgi.ini</span><br><span class="line"><span class="attr">numprocs</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">user</span>=nginx</span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stopsignal</span>=INT</span><br><span class="line"><span class="attr">stopasgroup</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">killasgroup</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/log/vulfoucs_uwsgi.log</span><br></pre></td></tr></table></figure>
<p><strong>位置：</strong><code>/etc/supervisord.d/celery.ini</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[program:celeryworker]</span></span><br><span class="line"><span class="attr">command</span>=/data/venv_py/bin/celery -A vulfocus worker -l info -E</span><br><span class="line"><span class="attr">directory</span>=/data/web/vulfocus-api</span><br><span class="line"><span class="attr">user</span>=nginx</span><br><span class="line"><span class="attr">numprocs</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/log/worker_celery.log</span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">10</span></span><br><span class="line"><span class="attr">stopasgroup</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">priority</span>=<span class="number">999</span></span><br></pre></td></tr></table></figure>
<h3 id="权限以及自启"><a href="#权限以及自启" class="headerlink" title="权限以及自启"></a>权限以及自启</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">chown</span> -<span class="type">R</span> nginx. /<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure>

<p>使用 <code>unix://var/run/docker.sock</code> <strong>连接 docker 需要配置</strong> 使用 tcp 套接字无需修改</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">groupadd</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">usermod</span> <span class="string">-aG docker nginx</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart docker</span></span><br></pre></td></tr></table></figure>

<h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> nginx</span><br><span class="line">systemctl <span class="builtin-name">enable</span> supervisord</span><br><span class="line">systemctl <span class="builtin-name">enable</span> docker</span><br><span class="line">systemctl <span class="builtin-name">enable</span> redis</span><br></pre></td></tr></table></figure>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> supervisord</span><br><span class="line">systemctl <span class="literal">start</span> nginx</span><br><span class="line">systemctl <span class="literal">start</span> docker</span><br><span class="line">systemctl <span class="literal">start</span> redis</span><br></pre></td></tr></table></figure>

<h4 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h4><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=443/tcp --permanent</span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>拉取镜像会报 500 错误这个是 <code>/var/run/docker.sock</code> 权限问题</p>
<p>三种解决方案</p>
<ol>
<li><p>修改 <code>/etc/supervisord.d/vulfoucs.ini</code> 配置文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># user=nginx # 改前</span></span><br><span class="line"><span class="attr">user</span>=root <span class="comment"># 改后</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置 Docker URL（<code>vulfocus/settings.py</code>），启用 <code>tcp://127.0.0.1:2375</code></p>
</li>
<li><p>添加 docker 用户组把 nginx 用户加进去</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">groupadd</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">usermod</span> <span class="string">-aG docker nginx</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart docker</span></span><br></pre></td></tr></table></figure></li>
</ol>
<div class="note primary"><p><span class="exturl" data-url="aHR0cHM6Ly9mb2ZhcHJvLmdpdGh1Yi5pby92dWxmb2N1cy8jLw==">Vulfocus 官方文档<i class="fa fa-external-link-alt"></i></span></p>
</div>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>vulfocus</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulnerability Directory / 漏洞目录</title>
    <url>/Vulnerabilities/1.html</url>
    <content><![CDATA[<p>&emsp;&emsp;最近正想整理一个漏洞合辑，就遇上了护网。于是乎就利用【护网漏洞提交平台】的漏洞分类，作为一个漏洞类型的目录指引，在往后的学习工作中，再逐一补充漏洞的详细信息。</p>
<span id="more"></span>

<p>&emsp;&emsp;本漏洞合辑的编写呢，将会分为几步走</p>
<ol>
<li>漏洞分类<ol>
<li>列出所有的漏洞分类</li>
<li>漏洞分类作综述</li>
<li>将单一漏洞编入漏洞分类</li>
</ol>
</li>
<li>单一漏洞<ol>
<li>给每一个漏洞评定“漏洞等级”（High、Medium、Low）</li>
<li>给每一个漏洞增加“漏洞简述”</li>
<li>给危害大或可利用性高的漏洞发布单独的博文，补充漏洞的详细信息、POC 请求包、复现步骤、修复方案等等</li>
</ol>
</li>
<li>单一漏洞组合利用（这个近几年是写不粗来了）</li>
<li>最后就是永久的更新、补充、完善。</li>
</ol>
<h1 id="IT信息系统漏洞"><a href="#IT信息系统漏洞" class="headerlink" title="IT信息系统漏洞"></a>IT信息系统漏洞</h1><h2 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h2><h2 id="任意文件上传漏洞"><a href="#任意文件上传漏洞" class="headerlink" title="任意文件上传漏洞"></a>任意文件上传漏洞</h2><h2 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h2><h2 id="文件遍历漏洞"><a href="#文件遍历漏洞" class="headerlink" title="文件遍历漏洞"></a>文件遍历漏洞</h2><h2 id="远程命令执行漏洞"><a href="#远程命令执行漏洞" class="headerlink" title="远程命令执行漏洞"></a>远程命令执行漏洞</h2><h2 id="弱口令漏洞"><a href="#弱口令漏洞" class="headerlink" title="弱口令漏洞"></a>弱口令漏洞</h2><h2 id="其他漏洞"><a href="#其他漏洞" class="headerlink" title="其他漏洞"></a>其他漏洞</h2><h2 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h2><h2 id="拒绝服务漏洞"><a href="#拒绝服务漏洞" class="headerlink" title="拒绝服务漏洞"></a>拒绝服务漏洞</h2><h2 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h2><h2 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h2><h2 id="错误配置漏洞"><a href="#错误配置漏洞" class="headerlink" title="错误配置漏洞"></a>错误配置漏洞</h2><h2 id="任意文件操作漏洞"><a href="#任意文件操作漏洞" class="headerlink" title="任意文件操作漏洞"></a>任意文件操作漏洞</h2><h2 id="缓冲区溢出漏洞"><a href="#缓冲区溢出漏洞" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h2><h2 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h2><h2 id="信息泄露漏洞"><a href="#信息泄露漏洞" class="headerlink" title="信息泄露漏洞"></a>信息泄露漏洞</h2><h2 id="支付逻辑漏洞"><a href="#支付逻辑漏洞" class="headerlink" title="支付逻辑漏洞"></a>支付逻辑漏洞</h2><h2 id="密码重置漏洞"><a href="#密码重置漏洞" class="headerlink" title="密码重置漏洞"></a>密码重置漏洞</h2><h2 id="任意注册"><a href="#任意注册" class="headerlink" title="任意注册"></a>任意注册</h2><h2 id="任意登陆"><a href="#任意登陆" class="headerlink" title="任意登陆"></a>任意登陆</h2><h2 id="撞库-扫号-暴力破解"><a href="#撞库-扫号-暴力破解" class="headerlink" title="撞库/扫号/暴力破解"></a>撞库/扫号/暴力破解</h2><h2 id="其他认证缺陷"><a href="#其他认证缺陷" class="headerlink" title="其他认证缺陷"></a>其他认证缺陷</h2><h2 id="系统-服务器补丁不及时漏洞"><a href="#系统-服务器补丁不及时漏洞" class="headerlink" title="系统/服务器补丁不及时漏洞"></a>系统/服务器补丁不及时漏洞</h2><h2 id="JSONP漏洞"><a href="#JSONP漏洞" class="headerlink" title="JSONP漏洞"></a>JSONP漏洞</h2><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h2 id="URL重定向漏洞"><a href="#URL重定向漏洞" class="headerlink" title="URL重定向漏洞"></a>URL重定向漏洞</h2><h2 id="任意文件下载漏洞"><a href="#任意文件下载漏洞" class="headerlink" title="任意文件下载漏洞"></a>任意文件下载漏洞</h2><h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><h2 id="水平越权漏洞"><a href="#水平越权漏洞" class="headerlink" title="水平越权漏洞"></a>水平越权漏洞</h2><h2 id="垂直越权漏洞"><a href="#垂直越权漏洞" class="headerlink" title="垂直越权漏洞"></a>垂直越权漏洞</h2><h2 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h2><h2 id="疑似入侵-存在后门"><a href="#疑似入侵-存在后门" class="headerlink" title="疑似入侵/存在后门"></a>疑似入侵/存在后门</h2><h2 id="释放重引用"><a href="#释放重引用" class="headerlink" title="释放重引用"></a>释放重引用</h2><h2 id="双重释放"><a href="#双重释放" class="headerlink" title="双重释放"></a>双重释放</h2><h2 id="权限提升-绕过"><a href="#权限提升-绕过" class="headerlink" title="权限提升/绕过"></a>权限提升/绕过</h2><h2 id="数组越界访问"><a href="#数组越界访问" class="headerlink" title="数组越界访问"></a>数组越界访问</h2><h2 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h2><h2 id="注入漏洞"><a href="#注入漏洞" class="headerlink" title="注入漏洞"></a>注入漏洞</h2><h1 id="工业系统漏洞"><a href="#工业系统漏洞" class="headerlink" title="工业系统漏洞"></a>工业系统漏洞</h1><h1 id="车联网漏洞"><a href="#车联网漏洞" class="headerlink" title="车联网漏洞"></a>车联网漏洞</h1><h1 id="移动终端漏洞"><a href="#移动终端漏洞" class="headerlink" title="移动终端漏洞"></a>移动终端漏洞</h1><h2 id="组件暴露-权限漏洞"><a href="#组件暴露-权限漏洞" class="headerlink" title="组件暴露/权限漏洞"></a>组件暴露/权限漏洞</h2><h2 id="WebView命令执行"><a href="#WebView命令执行" class="headerlink" title="WebView命令执行"></a>WebView命令执行</h2><h2 id="SSL证书验证错误"><a href="#SSL证书验证错误" class="headerlink" title="SSL证书验证错误"></a>SSL证书验证错误</h2><h2 id="不安全存储"><a href="#不安全存储" class="headerlink" title="不安全存储"></a>不安全存储</h2><h2 id="硬编码敏感信息"><a href="#硬编码敏感信息" class="headerlink" title="硬编码敏感信息"></a>硬编码敏感信息</h2>]]></content>
      <categories>
        <category>Vulnerabilities</category>
      </categories>
      <tags>
        <tag>Vulnerability</tag>
        <tag>漏洞</tag>
        <tag>漏洞分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Website Image &amp; Video Optimization / 网站图片、视频优化处理</title>
    <url>/IT/12.html</url>
    <content><![CDATA[<p>&emsp;&emsp;5G 时代了，每一个网站都少不了图片和视频，图片和视频文件越大，占用的服务器空间就越大，要花的 money 就越多。而且大型文件的加载速度也更慢，还浪费用户宝贵的流量。有些和博主一样聪明的站长会想到“压缩”，可是如果要压缩，势必会影响画质，总不能为了省钱影响观感。所以相信广大站长朋友们，也一定和博主一样，试图寻找一个“最佳图片格式”和“最佳视频格式”。所谓的“最佳”便是——<strong>牺牲最小的画质，占用最小的空间！</strong></p>
<p>&emsp;&emsp;而现在，它来了！</p>
<span id="more"></span>

<h1 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h1><p>&emsp;&emsp;先来讲讲图片优化。要压缩图片，同时也要尽可能地“无损画质”，当然首先要确定一种图片格式。常见的图片格式大家也一定不陌生，例如 png、jpg、jpeg、gif、bmp 等等。但是今天博主要安利的是一种船新的图片格式：WebP</p>
<h2 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h2><blockquote>
<p>WebP is a modern image format that provides superior lossless and lossy compression for images on the web. Using WebP, webmasters and web developers can create smaller, richer images that make the web faster.<br>WebP lossless images are 26% smaller in size compared to PNGs. WebP lossy images are 25-34% smaller than comparable JPEG images at equivalent SSIM quality index.<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——<em>摘自 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvd2VicA==">Google WebP<i class="fa fa-external-link-alt"></i></span></em></p>
</blockquote>
<p>WebP 是由谷歌推出的一种图片格式，由它的名字就可以知道，这个图片格式就是“为网络而生”。将图片压缩为 WebP 格式，可以完美的解决本文开头的问题。经博主少量测试，图片压缩为 WebP 格式后，画质会有一定的影响，但是不影响肉眼的观看，而图片大小<strong>惊人地缩小了 N 倍</strong>。大部分一般的图片都能缩小到 <strong>4KB</strong>！少数则可能为<strong>十几 K</strong>。所以下面博主给出谷歌官方压缩工具和用法</p>
<h2 id="libwebp"><a href="#libwebp" class="headerlink" title="libwebp"></a>libwebp</h2><p>&emsp;&emsp;“libwebp”就是谷歌<strong>官方</strong>的图片压缩工具了，谷歌官方下载地址：<span class="exturl" data-url="aHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL2Rvd25sb2Fkcy53ZWJtcHJvamVjdC5vcmcvcmVsZWFzZXMvd2VicC9pbmRleC5odG1s">libwebp<i class="fa fa-external-link-alt"></i></span></p>
<p>&emsp;&emsp;下载完成后，我们进入文件夹中的<code>bin</code>目录，将其中的<code>cwebp.exe</code>copy 到要压缩的图片文件目录下，并使用这一行命令进行压缩</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cwebp</span><span class="selector-class">.exe</span> 要压缩的图片文件名<span class="selector-class">.png</span> <span class="selector-tag">-o</span> 压缩后的图片文件名<span class="selector-class">.webp</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后就得到压缩后的图片咯。</p>
<h1 id="视频优化"><a href="#视频优化" class="headerlink" title="视频优化"></a>视频优化</h1><p>&emsp;&emsp;同样的再来讲讲视频优化。因为本文要压缩的视频是针对网站上的，所以在选择视频格式的时候，肯定优先选择又是“谷歌出品”的 WebM。可能是因为技术太前卫，将视频压缩为 WebM 格式，所需消耗的时间是视频本身时长的好几倍，为了兼顾那些长视频的压缩，无奈只能放弃 WebM 格式，转而寻求其它视频格式。<br>&emsp;&emsp;在博主尝试了多种常用视频格式，并考虑了 CDN 的因素（现在主流的 CDN，都会对 mp4 格式的文件进行“分片缓存”）后，决定还是采用 mp4 的视频格式，只不过是 H.264 编码的 mp4 格式。</p>
<h2 id="H-264-编码"><a href="#H-264-编码" class="headerlink" title="H.264 编码"></a>H.264 编码</h2><blockquote>
<p>H.264，又称为MPEG-4第10部分，高级视频编码（英语：MPEG-4 Part 10, Advanced Video Coding，缩写为MPEG-4 AVC）是一种面向块，基于运动补偿的视频编码标准 。到2014年，它已经成为高精度视频录制、压缩和发布的最常用格式之一。第一版标准的最终草案于2003年5月完成。<br>H.264因其是蓝光盘的其中一种编解码标准而著名，所有蓝光盘播放器都必须能解码H.264。它也被广泛用于网络流媒体数据如Vimeo、YouTube、以及iTunes Store，网络软件如Adobe Flash Player和Microsoft Silverlight，以及各种高清晰度电视地面电视（ATSC、ISDB-T、DVB-T或DVB-T2）、线缆（DVB-C）以及卫星（DVB-S和DVB-S2）。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——<em>摘自 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSC4yNjQvTVBFRy00X0FWQw==">《维基百科》H.264/MPEG-4 AVC 词条<i class="fa fa-external-link-alt"></i></span></em></p>
</blockquote>
<p>&emsp;&emsp;博主在这里要澄清下：为什么选用 H.264 编码而不是更先进的 H.265 编码？<br>&emsp;&emsp;答：因为在 Windows 10 上，需要购买解码器才能播放。</p>
<h2 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h2><p>&emsp;&emsp;视频处理博主选用了国外开源软件：FFmpeg。听说国内好多视频处理软件都是这个开源软件加的壳？博主怕被封，话不多说，直接放出官方下载地址：<span class="exturl" data-url="aHR0cHM6Ly9mZm1wZWcub3JnLw==">FFmpeg<i class="fa fa-external-link-alt"></i></span></p>
<p>&emsp;&emsp;和上面 libwebp 一样的操作，进入文件夹中的<code>bin</code>目录，然后将其中的<code>ffmpeg.exe</code>copy 到要压缩的视频文件目录下，然后博主教大家两种优化，分别是“压缩”和“剪辑”</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ffmpeg</span> -i 要压缩的视频文件名.mp<span class="number">4</span> -c:v libx<span class="number">264</span> 压缩后的视频文件名.mp<span class="number">4</span>     # 视频压缩</span><br><span class="line"><span class="attribute">ffmpeg</span> -i 要剪辑的视频文件名.mp<span class="number">4</span> -ss <span class="number">01</span>:<span class="number">22</span>:<span class="number">33</span>.<span class="number">0</span> -c copy -t <span class="number">04</span>:<span class="number">55</span>:<span class="number">66</span>.<span class="number">0</span> 剪辑后的视频文件名.mp<span class="number">4</span>     # 剪出视频的 <span class="number">01</span>(h):<span class="number">22</span>(m):<span class="number">33</span>(s):<span class="number">0</span>(ms) 至 <span class="number">04</span>:<span class="number">55</span>:<span class="number">66</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>libwebp</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows File Recovery Help / Windows File Recovery 使用帮助</title>
    <url>/IT/6.html</url>
    <content><![CDATA[<p>Microsoft Store 上架了一款<strong>微软官方</strong>的 Windows 文件恢复工具。百度一圈只看到了新闻，连使用帮助都没有。博主在 Microsoft Support 找到了英文版使用帮助，借助谷歌翻译，将基础使用帮助翻译成了中文版，方便大家食用。</p>
<span id="more"></span>

<blockquote>
<p>If you can’t locate a lost file from your backup, then you can use Windows File Recovery, which is a command line app available from the Microsoft Store. Use this app to try to recover lost files that have been deleted from your local storage device (including internal drives, external drives, and USB devices) and can’t be restored from the Recycle Bin. Recovery on cloud storage and network file shares is not supported.<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——<em>摘自 <span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0Lm1pY3Jvc29mdC5jb20vemgtY24vaGVscC80NTM4NjQyL3dpbmRvd3MtMTAtcmVzdG9yZS1sb3N0LWZpbGVz">Microsoft 支持<i class="fa fa-external-link-alt"></i></span></em></p>
</blockquote>
<div class="note info"><p>这个程序需要 Windows 10 版本 19041 以上</p>
</div>

<div class="note warning"><p>如果要增加恢复文件的机会，请尽量减少或避免使用计算机。在 Windows 文件系统中，已删除文件使用的空间标记为可用空间，这意味着文件数据仍然可以存在并恢复。但是，任何使用您的计算机都可以创建文件，这随时可能会过度写入此可用空间。</p>
</div>

<h2 id="如有必要，请从-Microsoft-应用商店-下载并启动应用"><a href="#如有必要，请从-Microsoft-应用商店-下载并启动应用" class="headerlink" title="如有必要，请从 Microsoft 应用商店 下载并启动应用"></a>如有必要，请从 <em><span class="exturl" data-url="aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9zdG9yZS9yLzlOMjZTNTBMTjcwNQ==">Microsoft 应用商店<i class="fa fa-external-link-alt"></i></span></em> 下载并启动应用</h2><h2 id="按-Windows-键，在搜索框中输入“Windows-文件恢复”，然后选择“窗口文件恢复”"><a href="#按-Windows-键，在搜索框中输入“Windows-文件恢复”，然后选择“窗口文件恢复”" class="headerlink" title="按 Windows 键，在搜索框中输入“Windows 文件恢复”，然后选择“窗口文件恢复”"></a>按 Windows 键，在搜索框中输入“Windows 文件恢复”，然后选择“窗口文件恢复”</h2><h2 id="当系统提示您允许应用对您的设备进行更改时，请选择“是”"><a href="#当系统提示您允许应用对您的设备进行更改时，请选择“是”" class="headerlink" title="当系统提示您允许应用对您的设备进行更改时，请选择“是”"></a>当系统提示您允许应用对您的设备进行更改时，请选择“是”</h2><h2 id="在“命令提示符”窗口中，以以下格式输入命令"><a href="#在“命令提示符”窗口中，以以下格式输入命令" class="headerlink" title="在“命令提示符”窗口中，以以下格式输入命令"></a>在“命令提示符”窗口中，以以下格式输入命令</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">winfr source-<span class="attr">drive:</span> destination-<span class="attr">drive:</span> [/switches]</span><br></pre></td></tr></table></figure>

<ol>
<li>源驱动器和目标驱动器必须不同。从操作系统驱动器恢复时（通常为 C:），请使用 /n <filter> 和 /y：&lt;type&lt;(s)&gt; 开关来指定用户文件或文件夹。</li>
<li>Microsoft 会自动为您创建一个恢复文件夹，Recovery_&lt;日期和时间&gt; 在目标驱动器上。</li>
<li>有三种模式可用于恢复文件：默认、Segment、Signature</li>
</ol>
<h3 id="默认模式示例"><a href="#默认模式示例" class="headerlink" title="默认模式示例"></a>默认模式示例</h3><ol>
<li>将特定文件从 C: 驱动器恢复到 E: 驱动器上的恢复文件夹<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">winfr C: E: /n <span class="symbol">\U</span>sers<span class="symbol">\&lt;</span>username&gt;<span class="symbol">\D</span>ocuments<span class="symbol">\Q</span>uarterlyStatement.docx</span><br></pre></td></tr></table></figure></li>
<li>将 jpeg 和 png 照片从图片文件夹恢复到 E: 驱动器上的恢复文件夹<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">winfr C: E: /n <span class="symbol">\U</span>sers<span class="symbol">\&lt;</span>username&gt;<span class="symbol">\P</span>ictures<span class="symbol">\*</span>.JPEG /n <span class="symbol">\U</span>sers<span class="symbol">\&lt;</span>username&gt;<span class="symbol">\P</span>ictures<span class="symbol">\*</span>.PNG</span><br></pre></td></tr></table></figure></li>
<li>从 C: 驱动器恢复到 E: 驱动器上的恢复文件夹。将文档文件夹恢复到 E: 驱动器<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">winfr C: E: /n <span class="symbol">\U</span>sers<span class="symbol">\&lt;</span>username&gt;<span class="symbol">\D</span>ocuments\</span><br></pre></td></tr></table></figure></li>
</ol>
<div class="note info"><p>不要忘记文件夹末尾的斜杠</p>
</div>

<h3 id="Segment-模式示例"><a href="#Segment-模式示例" class="headerlink" title="Segment 模式示例"></a>Segment 模式示例</h3><ol>
<li>从 C: 驱动器恢复到 E: 驱动器上的恢复文件夹，恢复 PDF 和 Word 文件<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">winfr C: E: <span class="string">/r</span> <span class="string">/n</span> *<span class="string">.pdf</span> <span class="string">/n</span> *<span class="string">.docx</span></span><br></pre></td></tr></table></figure></li>
<li>使用通配符恢复文件名中字符串“发票”中的任何文件<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">winfr <span class="attr">C:</span> <span class="attr">E:</span> <span class="regexp">/r /</span>n *invoice*</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Signature-模式示例"><a href="#Signature-模式示例" class="headerlink" title="Signature 模式示例"></a>Signature 模式示例</h3><ol>
<li>使用 Signature 模式时，首先查看受支持的扩展组和相应的文件类型会很有帮助<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">winfr</span> /<span class="comment">#</span></span><br></pre></td></tr></table></figure></li>
<li>从 C: 驱动器恢复到 E: 驱动器上的恢复文件夹，恢复 JPEG、jpeg、jpe、jif、jfif、jfi）和 PNG 照片<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">winfr <span class="attr">C:</span> <span class="attr">E:</span> <span class="regexp">/x /</span><span class="attr">y:</span>JPEG,PNG</span><br></pre></td></tr></table></figure></li>
<li>从 C: 驱动器恢复到 E: 驱动器上的恢复文件夹，将 ZIP 文件（zip、docx、xlsx、ptpx 等）恢复<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">winfr <span class="attr">C:</span> <span class="attr">E:</span>\RecoveryTest <span class="regexp">/x /</span><span class="attr">y:</span>ZIP</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="当系统提示您继续确认时，输入-Y-以启动恢复操作。根据源驱动器的大小，这可能需要一段时间。要停止恢复过程，请按-Ctrl-C"><a href="#当系统提示您继续确认时，输入-Y-以启动恢复操作。根据源驱动器的大小，这可能需要一段时间。要停止恢复过程，请按-Ctrl-C" class="headerlink" title="当系统提示您继续确认时，输入 Y 以启动恢复操作。根据源驱动器的大小，这可能需要一段时间。要停止恢复过程，请按 Ctrl+C"></a>当系统提示您继续确认时，输入 Y 以启动恢复操作。根据源驱动器的大小，这可能需要一段时间。要停止恢复过程，请按 Ctrl+C</h2>]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>文件恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>Zhenhua School Song / 振华校歌</title>
    <url>/Misc/1.html</url>
    <content><![CDATA[<p>&emsp;&emsp;莫名突然哼起振华的校歌，但有些字词只记得读音了。有幸从网上找到了歌谱，黏贴在此，谨以此文纪念我的母校。</p>
<span id="more"></span>

<p><img data-src="https://www.hackme.cc/source/%E6%8C%AF%E5%8D%8E%E6%A0%A1%E6%AD%8C.webp" alt="振华校歌.webp"></p>
]]></content>
      <categories>
        <category>Misc</category>
      </categories>
      <tags>
        <tag>振华</tag>
        <tag>校歌</tag>
      </tags>
  </entry>
</search>
